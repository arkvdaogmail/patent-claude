{"version":3,"sources":["../src/core.ts","../src/vcdm/Hex.ts","../src/vcdm/abi/ABI.ts","../src/vcdm/abi/ABIItem.ts","../src/vcdm/abi/ABIEvent.ts","../src/vcdm/abi/ABIFunction.ts","../src/vcdm/abi/ABIContract.ts","../src/vcdm/account/Account.ts","../src/vcdm/Txt.ts","../src/vcdm/FixedPointNumber.ts","../src/vcdm/HexInt.ts","../src/vcdm/HexUInt.ts","../src/vcdm/hash/Sha256.ts","../src/secp256k1/Secp256k1.ts","../src/hdkey/HDKey.ts","../src/vcdm/hash/Keccak256.ts","../src/vcdm/Address.ts","../src/vcdm/BlockRef.ts","../src/vcdm/hash/Blake2b256.ts","../src/vcdm/BloomFilter.ts","../src/vcdm/currency/Coin.ts","../src/vcdm/currency/Units.ts","../src/vcdm/currency/VET.ts","../src/vcdm/currency/VTHO.ts","../src/vcdm/currency/Token.ts","../src/vcdm/encoding/rlp/kind/ScalarKind.ts","../src/vcdm/encoding/rlp/RLP.ts","../src/vcdm/encoding/rlp/RLPProfiler.ts","../src/vcdm/encoding/rlp/helpers/numerickind.ts","../src/vcdm/encoding/rlp/helpers/hexblobkind.ts","../src/vcdm/encoding/rlp/helpers/fixedhexblobkind.ts","../src/vcdm/encoding/rlp/helpers/compactfixedhexblobkind.ts","../src/vcdm/encoding/rlp/kind/BufferKind.ts","../src/vcdm/encoding/rlp/kind/NumericKind.ts","../src/vcdm/encoding/rlp/kind/hexblob/HexBlobKind.ts","../src/vcdm/encoding/rlp/kind/hexblob/FixedHexBlobKind.ts","../src/vcdm/encoding/rlp/kind/hexblob/OptionalFixedHexBlobKind.ts","../src/vcdm/encoding/rlp/kind/hexblob/CompactFixedHexBlobKind.ts","../src/vcdm/Mnemonic.ts","../src/vcdm/Quantity.ts","../src/vcdm/Revision.ts","../src/vcdm/BlockId.ts","../src/certificate/Certificate.ts","../src/keystore/cryptography/ethers/const/keystore.ts","../src/keystore/cryptography/ethers/keystore.ts","../src/keystore/cryptography/experimental/keystore.ts","../src/keystore/keystore.ts","../src/utils/const/abi.ts","../src/utils/const/data.ts","../src/utils/data/data.ts","../src/utils/const/network.ts","../src/transaction/Clause.ts","../src/transaction/TransactionType.ts","../src/transaction/Transaction.ts"],"names":["core_exports","__export","ABI","ABIContract","ABIEvent","ABIFunction","ABIItem","Account","Address","Blake2b256","BlockId","BlockRef","BloomFilter","BufferKind","Certificate","Clause","Coin","CompactFixedHexBlobKind","ERC1155_ABI","ERC20_ABI","ERC721_ABI","FixedHexBlobKind","FixedPointNumber","HDKey","Hex","HexBlobKind","HexInt","HexUInt","Keccak256","MAINNET_NETWORK","Mnemonic","NUMERIC_REGEX","NumericKind","OptionalFixedHexBlobKind","Quantity","RLP","RLPProfiler","Revision","SOLO_NETWORK","ScalarKind","Secp256k1","Sha256","TESTNET_NETWORK","ThorId","Token","Transaction","TransactionType","Txt","Units","VET","VIP180_ABI","VIP181_ABI","VIP210_ABI","VTHO","VTHO_ADDRESS","ZERO_ADDRESS","ZERO_BYTES","assertCompactFixedHexBlobBuffer","assertFixedHexBlobKindBuffer","assertFixedHexBlobKindData","assertValidHexBlobKindData","assertValidNumericKindBuffer","dataUtils","decodeBufferToHexWithLeadingZeros","decodeBufferToNumberOrHex","encodeBigIntToBuffer","encodeCompactFixedHexBlob","fromTransactionType","keystore","networkInfo","toTransactionType","validateNumericKindData","_Hex","sign","digits","normalize","v","InvalidOperation","that","thisBytes","thatBytes","i","compareByte","cue","InvalidDataType","exp","dataView","e","bytes","ut","compact","stripped","compactDigits","_ABI","types","values","parseAbiParameters","type","index","value","error","InvalidAbiDataToEncodeOrDecode","dataEncoded","hexDataEncoded","parsedAbiParams","decodeAbiParameters","obj","recursiveParse","currentObj","currentValues","key","abiParametersEncoded","encodeAbiParameters","signature","toFunctionSignature","parseAbiItem","ABIItemConstructor","formatType","toFunctionHash","_ABIEvent","InvalidAbiItem","abi","eventData","viemDecodeEventLog","topic","t","event","rawDecodedData","dataToEncode","topics","dataTypes","dataValues","param","valuesToEncode","valuesToEncodeLength","encodeEventTopics","data","decodeFunctionData","encodeFunctionData","decodeFunctionResult","resultDecoded","_ABIContract","name","functionAbiItem","getAbiItem","eventAbiItem","functionName","functionData","encodedFunctionInput","encodedFunctionOutput","eventName","eventArgs","eventToDecode","eventLogDecoded","address","balance","transactions","transaction","typeDiff","addressDiff","codeDiff","_Txt","_FixedPointNumber","fd","sv","ef","delta","dividend","divisor","decimalPlaces","dp","cmp","minFixedDigits","modulo","multiplicand","multiplicator","exponent","base","result","sf","iteration","actualResult","storedResult","decimalSeparator","padded","decimals","integers","integersShow","decimalsShow","str","sub","fc","di","ie","fe","_HexInt","bi","hex","_HexUInt","hint","_Sha256","hash","gt","_Secp256k1","publicKey","x","y","isYOdd","V","privateKey","isCompressed","nc_secp256k1","InvalidSecp256k1PrivateKey","resolve","reject","bytesLength","nh_randomBytes","messageHash","sig","InvalidSecp256k1MessageHash","InvalidSecp256k1Signature","recovery","te","words","path","master","Et","InvalidHDKeyMnemonic","InvalidHDKey","chainCode","header","ne","checksum","expandedPrivateKey","base58","expandedPublicKey","component","derivationPath","_Keccak256","nh_keccak_256","_Address","huint","stringAddress","pad","addressChecksummed","publicKeyInflated","publicKeyHash","mnemonic","root","_BlockRef","_Blake2b256","nh_blake2b","_BloomFilter","k","Se","distribute","bit","m","other","joinedBytes","keys","builder","BloomFilterBuilder","_BloomFilterBuilder","nBytes","bits","nBits","UINT32_LIMIT","addAndWrapAsUInt32","a","b","collision","bitPos","code","formatEther","wei","formatUnits","unit","fpn","parseEther","ether","parseUnits","convertUnits","fromUnits","toUnits","diffUnits","formatFromUnits","displayDecimals","targetValue","decimalValue","decimalParts","_VET","_VTHO","valueUnits","valueWei","_RLP","EthereumjsRLP","bytesToNumberBE","InvalidRLP","encodedData","profile","context","kind","item","part","packed","parts","_RLPProfiler","validObject","packedData","_validateNumericKindNumber","_validateNumericKindString","num","isHexUInt","isDecimal","buf","maxBytes","buffer","zeroIndex","byte","dataBI","_context","encoder","decoder","_Mnemonic","_that","numberOfWords","Ft","U","wordlistSize","randomGenerator","strength","numberOfBytes","wordlist","wordsToValidate","_Quantity","_Revision","txtValue","_BlockId","_ThorId","blockId","_Certificate","purpose","payload","domain","timestamp","signer","object","fastJsonStableStringify","CertificateSignatureMismatch","SCRYPT_PARAMS","encrypt","password","derivePublicKey","keystoreAccount","encryptOptions","keystoreJsonString","ethers","decrypt","isValid","InvalidKeystore","stringifyData","InvalidKeystoreParams","KEYSTORE_CRYPTO_CIPHER","KEYSTORE_CRYPTO_PARAMS_DKLEN","KEYSTORE_CRYPTO_KDF","KEYSTORE_VERSION","decodeScryptParams","salt","Y","N","r","p","dkLen","encodeScryptParams","options","encryptKeystore","kdf","scrypt","iv","uuidRandom","macPrefix","ciphertext","ctr","uuidV4","decryptKeystore","copy","EXPERIMENTAL_CRYPTOGRAPHY","useExperimentalCryptography","experimentalCryptography","VeChainSDKLogger","size","decodeBytes32String","valueInBytes","firstZeroIndex","firstNotZeroIndex","encodeBytes32String","zeroPadding","et","mainnetGenesisBlock","testnetGenesisBlock","soloGenesisBlock","_Clause","to","comment","contractAddress","functionAbi","args","amount","clauseOptions","contractBytecode","deployParams","senderAddress","recipientAddress","tokenId","vthoAddress","token","tokenValueWei","TRANSACTION_TYPE_VALUES","VALID_TRANSACTION_TYPES","InvalidTransactionType","_Transaction","body","gasPayer","gasPayerPublicKey","UnavailableTransactionField","NotDelegatedTransaction","Q","rawTransaction","isSigned","rawPrefix","txType","decodedRLPBody","bodyWithoutReservedField","correctTransactionBody","sender","txHash","clauses","sum","clause","isValidCommonFields","isValidEip1559Fields","isValidLegacyFields","InvalidTransactionField","senderPrivateKey","gasPayerPrivateKey","senderHash","transactionHash","gasPayerHash","reserved","featuresField","encodedBody","featuresList","expectedSignatureLength"],"mappings":"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","file":"index.js","sourcesContent":["// Our core library\nexport * from './certificate';\nexport * from './hdkey';\nexport * from './keystore';\nexport * from './secp256k1';\nexport * from './transaction';\nexport * from './utils';\nexport * from './vcdm';\n","import * as nc_utils from '@noble/curves/abstract/utils';\nimport * as nh_utils from '@noble/hashes/utils';\nimport { InvalidDataType, InvalidOperation } from '@vechain/sdk-errors';\nimport { type VeChainDataModel } from './VeChainDataModel';\n\n/**\n * Represents a hexadecimal value expressed as\n * * `-` sign if the value is negative,\n * * `0x` hexadecimal notation tag,\n * * a not empty string of hexadecimal digits from `0` to `9` and from `a` to `f`.\n *\n * @description This hexadecimal notation is coherent with the decimal notation:\n * * the sign is only expressed for negative values, and it is always the first symbol,\n * * the `0x` tags the string as a hexadecimal expression,\n * * hexadecimal digits follow.\n * * An empty content results is no digits.\n *\n * @implements {VeChainDataModel<Hex>}\n */\nclass Hex implements VeChainDataModel<Hex> {\n    /**\n     * Negative multiplier of the {@link digits} absolute value.\n     *\n     * @type {number}\n     */\n    protected static readonly NEGATIVE: number = -1;\n\n    /**\n     * Positive multiplier of the {@link digits} absolute value.\n     *\n     * @type {number}\n     */\n    protected static readonly POSITIVE: number = 1;\n\n    /**\n     * A constant string prefix used in hexadecimal notation.\n     */\n    public static readonly PREFIX = '0x';\n\n    /**\n     * The radix used for representing numbers base 16 in a positional numeral notation system.\n     *\n     * @typedef {number} RADIX\n     */\n    public static readonly RADIX: number = 16;\n\n    /**\n     * Regular expression for matching hexadecimal strings.\n     * An empty input is represented as a empty digits.\n     *\n     * @type {RegExp}\n     */\n    private static readonly REGEX_HEX: RegExp = /^-?(0x)?[0-9a-f]*$/i;\n\n    /**\n     * Regular expression pattern to match a prefix indicating hexadecimal number.\n     *\n     * @type {RegExp}\n     */\n    protected static readonly REGEX_HEX_PREFIX: RegExp = /^-?0x/i;\n\n    /**\n     * Returns the hexadecimal digits expressing this absolute value, sign and `0x` prefix omitted.\n\n     * @remarks An empty content results in an empty string returned.\n     */\n    public readonly digits: string;\n\n    /**\n     * Represents the sign multiplier of a given number:\n     * * {@link NEGATIVE} `-1` if negative,\n     * * {@link POSITIVE} `1` if positive.\n     */\n    public readonly sign: number;\n\n    /**\n     * Creates a new instance of this class to represent the value\n     * built multiplying `sign` for the absolute value expressed by the hexadecimal `digits`.\n     *\n     * @param {number} sign - The sign of the value.\n     * @param {string} digits - The digits of the absolute value in hexadecimal base.\n     * @param {function} [normalize] - The function used to normalize the digits. Defaults to converting digits to lowercase.\n     */\n    protected constructor(\n        sign: number,\n        digits: string,\n        normalize: (digits: string) => string = (digits) => digits.toLowerCase()\n    ) {\n        this.digits = normalize(digits);\n        this.sign = sign;\n    }\n\n    /**\n     * Returns the absolute value of this Hex object.\n     *\n     * @return {Hex} A new Hex object representing the absolute value of this Hex.\n     */\n    public get abs(): Hex {\n        return new Hex(Hex.POSITIVE, this.digits);\n    }\n\n    /**\n     * Returns the value of `bi` as a `BigInt` type.\n     *\n     * @returns {bigint} The value of `bi` as a `BigInt`.\n     */\n    get bi(): bigint {\n        return BigInt(this.sign) * nc_utils.hexToNumber(this.digits);\n    }\n\n    /**\n     * Returns the Uint8Array representation of the aligned bytes.\n     *\n     * @return {Uint8Array} The Uint8Array representation of the aligned bytes.\n     */\n    get bytes(): Uint8Array {\n        return nc_utils.hexToBytes(this.alignToBytes().digits);\n    }\n\n    /**\n     * Returns the value of n.\n     *\n     * @return {number} The value of n.\n     *\n     * @throws {InvalidOperation<Hex>} Throws an error if this instance doesn't represent\n     * an [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).\n     */\n    get n(): number {\n        if (this.isNumber()) {\n            // The sign is part of the IEEE 754 representation hence no need to consider `this.sign` property.\n            return new DataView(this.bytes.buffer).getFloat64(0);\n        }\n        throw new InvalidOperation('Hex.n', 'not an IEEE 754 float 64 number', {\n            hex: this.toString()\n        });\n    }\n\n    /**\n     * Aligns the hexadecimal string to bytes by adding a leading '0' if the string length is odd.\n     *\n     * @returns {Hex} - The aligned hexadecimal string.\n     */\n    public alignToBytes(): Hex {\n        return this.digits.length % 2 === 0\n            ? this\n            : new Hex(this.sign, '0' + this.digits);\n    }\n\n    /**\n     * Compares the current Hex object with another Hex object.\n     *\n     * @param {Hex} that - The Hex object to compare with.\n     *\n     * @return {number} - Returns a negative number if the current Hex object is less than the given Hex object,\n     *                    zero if they are equal, or a positive number if the current Hex object is greater than the given Hex object.\n     */\n    compareTo(that: Hex): number {\n        if (this.sign === that.sign) {\n            const digits = Math.max(this.digits.length, that.digits.length);\n            const thisBytes = this.fit(digits).bytes;\n            const thatBytes = that.fit(digits).bytes;\n            let i = 0;\n            let compareByte = 0;\n            while (compareByte === 0 && i < thisBytes.length) {\n                compareByte = thisBytes[i] - thatBytes[i];\n                i++;\n            }\n            return compareByte;\n        }\n        return this.sign - that.sign;\n    }\n\n    /**\n     * Returns a new instance of the Hex class, its value fits to the specified number of digits.\n     *\n     * @param {number} digits - The number of digits to fit the Hex value into.\n     *\n     * @returns {Hex} - A new Hex instance that represents the fitted Hex value.\n     *\n     * @throws {InvalidDataType} - If the Hex value cannot be fit into the specified number of digits.\n     */\n    public fit(digits: number): Hex {\n        if (digits < this.digits.length) {\n            // Cut.\n            let cue = 0;\n            while (\n                this.digits.length - cue > digits &&\n                this.digits.at(cue) === '0'\n            ) {\n                cue++;\n            }\n            if (this.digits.length - cue === digits) {\n                return new Hex(this.sign, this.digits.slice(cue));\n            }\n            throw new InvalidDataType(\n                'Hex.fit',\n                `can't fit in ${digits} digits`,\n                { digits, hex: this }\n            );\n        }\n        if (digits > this.digits.length) {\n            // Pad.\n            return new Hex(\n                this.sign,\n                '0'.repeat(digits - this.digits.length) + this.digits\n            );\n        }\n        return this;\n    }\n\n    /**\n     * Determines whether this Hex instance is equal to the given Hex instance.\n     *\n     * @param {Hex} that - The Hex instance to compare with.\n     * @return {boolean} - True if the Hex instances are equal, otherwise false.\n     */\n    isEqual(that: Hex): boolean {\n        return this.compareTo(that) === 0;\n    }\n\n    /**\n     * Checks if this instance expresses a valid {@link Number} value\n     * according the\n     * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).\n     *\n     * @returns {boolean} Returns true if this instance expresses 32 hex digits (16 bytes, 128 bits) needed to represent\n     * a {@link Number} value, else it returns false.\n     */\n    isNumber(): boolean {\n        return this.digits.length === 32;\n    }\n\n    /**\n     * Checks if the given string expression is a valid hexadecimal value.\n     *\n     * @param {string} exp - The string representation of a hexadecimal value.\n     *\n     * @return {boolean} - True if the expression is a valid hexadecimal value, case-insensitive,\n     * optionally prefixed with `0x`; false otherwise.\n     */\n    public static isValid(exp: string): boolean {\n        return Hex.REGEX_HEX.test(exp);\n    }\n\n    /**\n     * Determines whether the given string is a valid hexadecimal number prefixed with '0x'.\n     *\n     * @param {string} exp - The string to be evaluated.\n     * @return {boolean} - True if the string is a valid hexadecimal number prefixed with '0x', otherwise false.\n     */\n    public static isValid0x(exp: string): boolean {\n        return Hex.REGEX_HEX_PREFIX.test(exp) && Hex.isValid(exp);\n    }\n\n    /**\n     * Create a Hex instance from a bigint, number, string, or Uint8Array.\n     *\n     * @param {bigint | number | string | Uint8Array} exp - The value to represent in a Hex instance:\n     * * bigint is always representable in hexadecimal base notation;\n     * * number, encoded as [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format);\n     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;\n     * * Uint8Array is interpreted as the sequence of bytes.\n     *\n     * @returns {Hex} - A Hex instance representing the input value.\n     *\n     * @throws {InvalidDataType} if the given `exp` can't be represented as a hexadecimal expression.\n     */\n    public static of(exp: bigint | number | string | Uint8Array): Hex {\n        try {\n            if (typeof exp === 'bigint') {\n                if (exp < 0n) {\n                    return new Hex(\n                        this.NEGATIVE,\n                        nc_utils.numberToHexUnpadded(-1n * exp)\n                    );\n                }\n                return new Hex(\n                    this.POSITIVE,\n                    nc_utils.numberToHexUnpadded(exp)\n                );\n            } else if (typeof exp === 'number') {\n                const dataView = new DataView(new ArrayBuffer(16));\n                dataView.setFloat64(0, exp);\n                return new Hex(\n                    exp < 0 ? this.NEGATIVE : this.POSITIVE,\n                    nc_utils.bytesToHex(new Uint8Array(dataView.buffer))\n                );\n            } else if (typeof exp === 'string') {\n                if (!this.isValid(exp)) {\n                    throw new InvalidDataType(\n                        'Hex.of',\n                        'not an hexadecimal string',\n                        { exp }\n                    );\n                }\n                if (exp.startsWith('-')) {\n                    return new Hex(\n                        this.NEGATIVE,\n                        this.REGEX_HEX_PREFIX.test(exp)\n                            ? exp.slice(3)\n                            : exp.slice(1)\n                    );\n                }\n                return new Hex(\n                    this.POSITIVE,\n                    this.REGEX_HEX_PREFIX.test(exp) ? exp.slice(2) : exp\n                );\n            }\n            return new Hex(this.POSITIVE, nc_utils.bytesToHex(exp));\n        } catch (e) {\n            throw new InvalidDataType(\n                'Hex.of',\n                'not an hexadecimal expression',\n                { exp: `${exp}` }, // Needed to serialize bigint values.\n                e\n            );\n        }\n    }\n\n    /**\n     * Generates a random Hex value of the given number of bytes length.\n     *\n     * @param {number} bytes - The number of bytes to generate.\n     * @throws {InvalidDataType} - If the bytes argument is not greater than 0.\n     * @returns {Hex} - A randomly generated Hex value.\n     *\n     * @remarks Security auditable method, depends on\n     * * [`nh_utils.randomBytes`](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#utils).\n     */\n    public static random(bytes: number): Hex {\n        if (bytes > 0) {\n            return Hex.of(nh_utils.randomBytes(bytes));\n        }\n        throw new InvalidDataType('Hex.random', 'bytes argument not > 0', {\n            bytes\n        });\n    }\n\n    /**\n     * Returns a string representation of the object.\n     *\n     * @param {boolean} compact - Whether to compact the string representation.\n     * @return {string} The string representation of the object.\n     */\n    public toString(compact: boolean = false): string {\n        if (compact) {\n            const stripped = this.digits.replace(/^0+/, '');\n            const compactDigits = stripped === '' ? '0' : stripped;\n            return (this.sign < 0 ? '-0x' : '0x') + compactDigits;\n        }\n\n        return (this.sign < 0 ? '-0x' : '0x') + this.digits;\n    }\n}\n\nexport { Hex };\n","import {\n    InvalidAbiDataToEncodeOrDecode,\n    InvalidOperation\n} from '@vechain/sdk-errors';\nimport {\n    decodeAbiParameters,\n    encodeAbiParameters,\n    parseAbiParameters,\n    type AbiParameter\n} from 'viem';\nimport { Hex } from '../Hex';\nimport { type VeChainDataModel } from '../VeChainDataModel';\n\n/**\n * Represents an ABI (Application Binary Interface).\n * @extends VeChainDataModel\n */\nclass ABI implements VeChainDataModel<ABI> {\n    private readonly types: readonly AbiParameter[];\n    private readonly values: unknown[];\n    /**\n     * ABI constructor from types and values.\n     *\n     * @param {string | AbiParameter[]} types - A list of ABI types representing the types of the values.\n     * @param {unknown[]} values - An array of values according to the specified ABI types.\n     **/\n    protected constructor(\n        types: string | AbiParameter[] = [],\n        values: unknown[] = []\n    ) {\n        this.types =\n            typeof types === 'string' ? parseAbiParameters(types) : types;\n        this.values = values;\n    }\n\n    /**\n     * Compares the current ABI instance with another ABI instance.\n     * @param that The ABI to compare with.\n     * @returns {number} A non-zero number if the current ABI is different to the other ABI or zero if they are equal.\n     * @override {@link VeChainDataModel#compareTo}\n     * @remark The comparison is done by comparing the types and values of the ABI instances.\n     **/\n    public compareTo(that: ABI): number {\n        this.types.forEach((type, index) => {\n            if (type !== that.types[index]) {\n                return -1;\n            }\n        });\n        this.values.forEach((value, index) => {\n            if (value !== that.values[index]) {\n                return 1;\n            }\n        });\n\n        return 0;\n    }\n\n    /**\n     * Checks if the current ABI object is equal to the given ABI object.\n     * @param that The ABI object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     * @override {@link VeChainDataModel#isEqual}\n     * @remark The comparison is done by comparing the types and values of the ABI instances.\n     **/\n    public isEqual(that: ABI): boolean {\n        return this.compareTo(that) === 0;\n    }\n\n    /**\n     * Throws an exception because the ABI cannot be represented as a big integer.\n     * @returns {bigint} The BigInt representation of the ABI.\n     * @throws {InvalidOperation} The ABI cannot be represented as a bigint.\n     * @override {@link VeChainDataModel#bi}\n     * @remark The conversion to BigInt is not supported for an ABI.\n     */\n    public get bi(): bigint {\n        throw new InvalidOperation(\n            'ABI.bi',\n            'There is no big integer representation for an ABI.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * Encodes the values according to the specified ABI types when creating the ABI instance.\n     *\n     * @returns The ABI-encoded bytes representing the given values.\n     * @throws {InvalidAbiDataToEncodeOrDecode, InvalidDataType}\n     */\n    public get bytes(): Uint8Array {\n        return this.toHex().bytes;\n    }\n\n    /**\n     * Throws an exception because the ABI cannot be represented as a number.\n     * @returns {bigint} The number representation of the ABI.\n     * @throws {InvalidOperation} The mnemonic cannot be represented as a number.\n     * @override {@link VeChainDataModel#n}\n     * @remark The conversion to number is not supported for an ABI.\n     */\n    public get n(): number {\n        throw new InvalidOperation(\n            'ABI.n',\n            'There is no number representation for an ABI.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * Instantiates an ABI object from the given types and values.\n     * @param {string | AbiParameter[]} types ABI parameters representing the types of the values.\n     * @param {unknown[]} values ABI values.\n     * @returns {ABI} The ABI object with the given types and values.\n     */\n    public static of(types: string | AbiParameter[], values: unknown[]): ABI {\n        try {\n            return new ABI(types, values);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABI.of',\n                'Types and values must be valid ABI parameters.',\n                {\n                    types,\n                    values\n                },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decodes the ABI values from the given ABI types and encoded data.\n     * @param {string| AbiParameter[]} types The list of ABI types representing the types of the values to decode.\n     * @param {Hex} dataEncoded The encoded data to decode.\n     * @returns An ABI instance with the decoded values.\n     */\n    public static ofEncoded(\n        types: string | AbiParameter[],\n        dataEncoded: string | Uint8Array\n    ): ABI {\n        try {\n            const hexDataEncoded = Hex.of(dataEncoded);\n            let values: readonly unknown[];\n            if (typeof types === 'string') {\n                const parsedAbiParams = parseAbiParameters(types);\n                values = decodeAbiParameters(\n                    parsedAbiParams,\n                    hexDataEncoded.bytes\n                );\n            } else {\n                values = decodeAbiParameters([...types], hexDataEncoded.bytes);\n            }\n            return new ABI(types, [...values]);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABI.of',\n                'Decoding failed: Data must be a valid ABI type with corresponding valid data.',\n                {\n                    types,\n                    data: dataEncoded\n                },\n                error\n            );\n        }\n    }\n\n    /**\n     * Recursively parses an object and collects the values of each attribute into an array,\n     * with nested arrays for nested objects.\n     * @param {object} obj - The object to parse.\n     * @returns {unknown[]} An array of values from the object, with nested arrays for nested objects.\n     */\n    public parseObjectValues(obj: object): unknown[] {\n        const values: unknown[] = [];\n\n        const recursiveParse = (currentObj: object): unknown[] => {\n            const currentValues: unknown[] = [];\n            for (const key in currentObj) {\n                if (Object.prototype.hasOwnProperty.call(currentObj, key)) {\n                    const value = (currentObj as never)[key];\n                    if (typeof value === 'object' && value !== null) {\n                        currentValues.push(recursiveParse(value));\n                    } else {\n                        currentValues.push(value);\n                    }\n                }\n            }\n            return currentValues;\n        };\n\n        values.push(...recursiveParse(obj));\n        return values;\n    }\n\n    /**\n     * It gets the first decoded value from the ABI.\n     * @returns {ReturnType} The first decoded value from the ABI.\n     */\n    public getFirstDecodedValue<ReturnType>(): ReturnType {\n        if (this.values[0] instanceof Object) {\n            return this.parseObjectValues(\n                this.values[0] as object\n            ) as ReturnType;\n        }\n        return this.values[0] as ReturnType;\n    }\n\n    /**\n     * Parses an ABI to its Hex representation.\n     * @returns {Hex} The Hex representation of the ABI.\n     */\n    public toHex(): Hex {\n        try {\n            const abiParametersEncoded = encodeAbiParameters(\n                this.types,\n                this.values\n            );\n            return Hex.of(abiParametersEncoded);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABI.toHex',\n                'Encoding failed: Data must be a valid ABI type with corresponding valid data.',\n                {\n                    types: this.types,\n                    values: this.values\n                },\n                error\n            );\n        }\n    }\n}\n\nexport { ABI };\n","import {\n    parseAbiItem,\n    toFunctionHash,\n    toFunctionSignature,\n    type AbiEvent,\n    type AbiFunction\n} from 'viem';\nimport { ABI } from './ABI';\n\ntype SignatureType = string | AbiFunction | AbiEvent;\n\n/**\n * Represents an ABI (Application Binary Interface) item.\n * @extends ABI\n */\nabstract class ABIItem extends ABI {\n    public readonly signature: AbiFunction | AbiEvent;\n    public readonly stringSignature: string;\n\n    /**\n     * ABIItem constructor from item (Event, Function...) signature.\n     *\n     * @param {SignatureType} signature - The signature of the ABI item (Function, Event...).\n     **/\n    public constructor(signature: SignatureType) {\n        super();\n        switch (typeof signature) {\n            case 'string':\n                this.stringSignature = signature;\n                break;\n            case 'object':\n                this.stringSignature = toFunctionSignature(signature);\n                break;\n            default:\n                this.stringSignature = '';\n        }\n        this.signature =\n            typeof signature === 'string'\n                ? parseAbiItem([signature])\n                : signature;\n    }\n\n    public static ofSignature<T extends ABIItem>(\n        ABIItemConstructor: new (signature: string) => T,\n        signature: string\n    ): T;\n\n    public static ofSignature<T extends ABIItem>(\n        ABIItemConstructor: new (signature: AbiFunction) => T,\n        signature: AbiFunction\n    ): T;\n\n    public static ofSignature<T extends ABIItem>(\n        ABIItemConstructor: new (signature: AbiEvent) => T,\n        signature: AbiEvent\n    ): T;\n\n    /**\n     * Returns and instance of an ABIItem from a signature.\n     * @param ABIItemConstructor ABIItem constructor.\n     * @param {SignatureType} signature Signature of the ABIIItem.\n     * @returns {T} An instance of the ABIItem.\n     */\n    public static ofSignature<T extends ABIItem>(\n        ABIItemConstructor: new (signature: SignatureType) => T,\n        signature: SignatureType\n    ): T {\n        return new ABIItemConstructor(signature);\n    }\n\n    /**\n     * Returns a string representation of a JSON object or a string.\n     * @param {'json' | 'string'} formatType Either JSON or String\n     * @returns The string representation of the ABI item.\n     */\n    public format(formatType: 'json' | 'string' = 'string'): string {\n        return formatType === 'json'\n            ? JSON.stringify(this.signature)\n            : this.stringSignature;\n    }\n\n    /**\n     * The signature hash of the ABIItem.\n     * @returns {string} The signature hash of the ABIItem.\n     * @remarks Wrapper for {@link toFunctionHash}.\n     **/\n    public get signatureHash(): string {\n        return toFunctionHash(this.stringSignature);\n    }\n\n    /**\n     * Compares the current ABIItem instance with another ABIItem instance.\n     * @param {ABIItem} that The item to compare with.\n     * @returns {number} A non-zero number if the current ABIItem is different to the other ABI or zero if they are equal.\n     * @override {@link VeChainDataModel#compareTo}\n     **/\n    public override compareTo(that: ABIItem): number {\n        if (super.compareTo(that) !== 0) {\n            return -1;\n        }\n        return this.stringSignature.localeCompare(that.stringSignature);\n    }\n}\n\nexport { ABIItem };\n","import {\n    InvalidAbiDataToEncodeOrDecode,\n    InvalidAbiItem\n} from '@vechain/sdk-errors';\nimport { type AbiEventParameter } from 'abitype';\nimport {\n    type AbiEvent,\n    type ContractEventName,\n    type DecodeEventLogReturnType,\n    encodeEventTopics,\n    type EncodeEventTopicsReturnType,\n    type Abi as ViemABI,\n    decodeEventLog as viemDecodeEventLog,\n    type Hex as ViemHex\n} from 'viem';\nimport { Hex } from '../Hex';\nimport { ABI } from './ABI';\nimport { ABIItem } from './ABIItem';\n\ntype Topics = [] | [signature: ViemHex, ...args: ViemHex[]];\n\ninterface ABIEventData {\n    data: Hex;\n    topics: Array<null | Hex | Hex[]>;\n}\n\n/**\n * Represents a function call in the Event ABI.\n * @extends ABIItem\n */\nclass ABIEvent<\n    TAbi extends ViemABI = ViemABI,\n    TEventName extends ContractEventName<TAbi> = ContractEventName<TAbi>\n> extends ABIItem {\n    private readonly abiEvent: AbiEvent;\n    public constructor(signature: string);\n    public constructor(signature: AbiEvent);\n    public constructor(signature: string | AbiEvent) {\n        try {\n            super(signature);\n            this.abiEvent = this.signature as AbiEvent;\n        } catch (error) {\n            throw new InvalidAbiItem(\n                'ABIEvent constructor',\n                'Initialization failed: Cannot create Event ABI. Event format is invalid.',\n                {\n                    type: 'event',\n                    value: signature\n                },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decode event log data using the event's ABI.\n     *\n     * @param abi - Event to decode.\n     * @returns Decoding results.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public static parseLog<\n        TAbi extends ViemABI,\n        TEventName extends ContractEventName<TAbi>\n    >(\n        abi: TAbi,\n        eventData: ABIEventData\n    ): DecodeEventLogReturnType<TAbi, TEventName> {\n        try {\n            return viemDecodeEventLog({\n                abi,\n                data: eventData.data.toString() as ViemHex,\n                topics: eventData.topics.map((topic) => {\n                    if (topic === null) {\n                        return topic;\n                    } else if (Array.isArray(topic)) {\n                        return topic.map((t) => t.toString());\n                    }\n                    return topic.toString();\n                }) as Topics\n            });\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIEvent.parseLog',\n                'Decoding failed: Data must be a valid hex string encoding a compliant ABI type.',\n                {\n                    data: {\n                        abi,\n                        data: eventData.data,\n                        topics: eventData.topics\n                    }\n                },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decode event log data using the event's ABI.\n     *\n     * @param event - Event to decode.\n     * @returns Decoding results.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public decodeEventLog(\n        event: ABIEventData\n    ): DecodeEventLogReturnType<TAbi, TEventName> {\n        try {\n            return ABIEvent.parseLog([this.abiEvent] as ViemABI, event);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIEvent.decodeEventLog',\n                'Decoding failed: Data must be a valid hex string encoding a compliant ABI type.',\n                { data: event },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decode event log data as an array of values\n     * @param {ABIEvent} event The data to decode.\n     * @returns {unknown[]} The decoded data as array of values.\n     */\n    public decodeEventLogAsArray(event: ABIEventData): unknown[] {\n        const rawDecodedData = this.decodeEventLog(event);\n\n        if (rawDecodedData.args === undefined) {\n            return [];\n        }\n\n        return this.parseObjectValues(rawDecodedData.args as unknown as object);\n    }\n\n    /**\n     * Encode event log data returning the encoded data and topics.\n     * @param dataToEncode - Data to encode.\n     * @returns {ABIEventData} Encoded data along with topics.\n     * @remarks There is no equivalent to encodeEventLog in viem {@link https://viem.sh/docs/ethers-migration}. Discussion started here {@link https://github.com/wevm/viem/discussions/2676}.\n     */\n    public encodeEventLog(dataToEncode: unknown[]): ABIEventData {\n        try {\n            const topics = this.encodeFilterTopics(dataToEncode);\n            const dataTypes: AbiEventParameter[] = [];\n            const dataValues: unknown[] = [];\n            this.abiEvent.inputs.forEach((param, index) => {\n                if (param.indexed ?? false) {\n                    // Skip indexed parameters\n                    return;\n                }\n                const value = dataToEncode[index];\n                dataTypes.push(param);\n                dataValues.push(value);\n            });\n            return {\n                data: ABI.of(dataTypes, dataValues).toHex(),\n                topics: topics.map((topic) => {\n                    if (topic === null) {\n                        return topic;\n                    } else if (Array.isArray(topic)) {\n                        return topic.map((t) => Hex.of(t));\n                    }\n                    return Hex.of(topic);\n                })\n            };\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIEvent.encodeEventLog',\n                'Encoding failed: Data format is invalid. Event data must be correctly formatted for ABI-compliant encoding.',\n                { dataToEncode },\n                error\n            );\n        }\n    }\n\n    /**\n     * Encode event log topics using the event's ABI.\n     *\n     * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.\n     *                         Only the values of the indexed parameters are needed.\n     * @returns Encoded topics array.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public encodeFilterTopics(\n        valuesToEncode: Record<string, unknown> | unknown[] | undefined\n    ): EncodeEventTopicsReturnType {\n        const valuesToEncodeLength = Array.isArray(valuesToEncode)\n            ? valuesToEncode.length\n            : Object.values(valuesToEncode ?? {}).length;\n        if (this.abiEvent.inputs.length < valuesToEncodeLength) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIEvent.encodeEventLog',\n                'Encoding failed: Data format is invalid. Number of values to encode is greater than the inputs.',\n                { valuesToEncode }\n            );\n        }\n\n        try {\n            return encodeEventTopics({\n                abi: [this.abiEvent],\n                args: valuesToEncode\n            });\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIEvent.encodeEventLog',\n                'Encoding failed: Data format is invalid. Event topics values must be correctly formatted for ABI-compliant encoding.',\n                { valuesToEncode },\n                error\n            );\n        }\n    }\n\n    /**\n     * Encode event log topics using the event's ABI, replacing null values with undefined.\n     * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.\n     *                         Only the values of the indexed parameters are needed.\n     * @returns Encoded topics array.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public encodeFilterTopicsNoNull(\n        valuesToEncode: Record<string, unknown> | unknown[] | undefined\n    ): Array<string | undefined> {\n        const encodedTopics = this.encodeFilterTopics(\n            valuesToEncode\n        ) as unknown as Array<string | undefined>;\n        return encodedTopics.map((topic) =>\n            topic === null ? undefined : topic\n        );\n    }\n}\n\nexport { ABIEvent, type ABIEventData };\n","import {\n    InvalidAbiDataToEncodeOrDecode,\n    InvalidAbiItem\n} from '@vechain/sdk-errors';\nimport {\n    type AbiFunction,\n    type ContractFunctionName,\n    decodeFunctionData,\n    type DecodeFunctionDataReturnType,\n    decodeFunctionResult,\n    type DecodeFunctionResultReturnType,\n    encodeFunctionData,\n    type Abi as ViemABI,\n    type Hex as ViemHex\n} from 'viem';\nimport { Hex } from '../Hex';\nimport { ABIItem } from './ABIItem';\n\n/**\n * Represents a function call in the Function ABI.\n * @extends ABIItem\n */\nclass ABIFunction<\n    TAbi extends ViemABI = ViemABI,\n    TFunctionName extends\n        ContractFunctionName<TAbi> = ContractFunctionName<TAbi>\n> extends ABIItem {\n    private readonly abiFunction: AbiFunction;\n    public constructor(signature: string);\n    public constructor(signature: AbiFunction);\n    public constructor(signature: string | AbiFunction) {\n        try {\n            super(signature);\n            this.abiFunction = this.signature as AbiFunction;\n        } catch (error) {\n            throw new InvalidAbiItem(\n                'ABIFunction constructor',\n                'Initialization failed: Cannot create Function ABI. Function format is invalid.',\n                {\n                    type: 'function',\n                    value: signature\n                },\n                error\n            );\n        }\n    }\n\n    /**\n     * Get the function selector.\n     * @returns {string} The function selector.\n     * @override {@link ABIItem#signatureHash}\n     */\n    public get signatureHash(): string {\n        return super.signatureHash.substring(0, 10);\n    }\n\n    /**\n     * Decode data using the function's ABI.\n     *\n     * @param {Hex} data - Data to decode.\n     * @returns Decoding results.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public decodeData(\n        data: Hex\n    ): DecodeFunctionDataReturnType<TAbi, TFunctionName> {\n        try {\n            return decodeFunctionData({\n                abi: [this.abiFunction],\n                data: data.toString() as ViemHex\n            });\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIFunction.decodeData',\n                'Decoding failed: Data must be a valid hex string encoding a compliant ABI type.',\n                { data },\n                error\n            );\n        }\n    }\n\n    /**\n     * Encode data using the function's ABI.\n     *\n     * @param dataToEncode - Data to encode.\n     * @returns {Hex} Encoded data.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public encodeData<TValue>(dataToEncode?: TValue[]): Hex {\n        try {\n            return Hex.of(\n                encodeFunctionData({\n                    abi: [this.abiFunction],\n                    args: dataToEncode\n                })\n            );\n        } catch (e) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIFunction.encodeData',\n                'Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.',\n                { dataToEncode },\n                e\n            );\n        }\n    }\n\n    /**\n     * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.\n     * This method attempts to decode the given hex-like data into a readable format using the contract's interface.\n     *\n     * @param {Hex} data - The data to be decoded, typically representing the output of a contract function call.\n     * @returns {DecodeFunctionResultReturnType} An object containing the decoded data.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     *\n     * @example\n     * ```typescript\n     *   const decoded = abiFunctionInstance.decodeResult(rawTransactionOutput);\n     *   console.log('Decoded Output:', decoded);\n     * ```\n     */\n    public decodeResult(\n        data: Hex\n    ): DecodeFunctionResultReturnType<TAbi, TFunctionName> {\n        try {\n            const result = decodeFunctionResult({\n                abi: [this.abiFunction],\n                data: data.toString() as ViemHex\n            });\n\n            return result as DecodeFunctionResultReturnType<\n                TAbi,\n                TFunctionName\n            >;\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIFunction.decodeResult',\n                'Decoding failed: Data must be a valid hex string encoding a compliant ABI type.',\n                { data },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decodes a function output returning an array of values.\n     * @param {Hex} data The data to be decoded\n     * @returns {unknown[]} The decoded data as array of values\n     */\n    public decodeOutputAsArray(data: Hex): unknown[] {\n        const resultDecoded = this.decodeResult(data);\n        if (this.abiFunction.outputs.length > 1) {\n            return this.parseObjectValues(resultDecoded as object);\n        } else if (\n            this.abiFunction.outputs.length === 1 &&\n            this.abiFunction.outputs[0].type === 'tuple'\n        ) {\n            return [this.parseObjectValues(resultDecoded as object)];\n        }\n        return [resultDecoded];\n    }\n}\nexport { ABIFunction };\n","import {\n    InvalidAbiDataToEncodeOrDecode,\n    InvalidAbiItem\n} from '@vechain/sdk-errors';\nimport {\n    getAbiItem,\n    type AbiEvent,\n    type AbiFunction,\n    type ContractEventName,\n    type ContractFunctionName,\n    type DecodeEventLogReturnType,\n    type DecodeFunctionDataReturnType,\n    type DecodeFunctionResultReturnType,\n    type Abi as ViemABI\n} from 'viem';\nimport { type Hex } from '../Hex';\nimport { ABI } from './ABI';\nimport { ABIEvent, type ABIEventData } from './ABIEvent';\nimport { ABIFunction } from './ABIFunction';\n\nclass ABIContract<TAbi extends ViemABI> extends ABI {\n    private readonly viemABI: ViemABI;\n\n    constructor(readonly abi: TAbi) {\n        super();\n        this.viemABI = abi as ViemABI;\n    }\n\n    /**\n     * Creates an ABIContract instance from a viem ABI.\n     * @param {ViemABI} abi representation of the contract.\n     * @returns New instance of ABIContract.\n     */\n    public static ofAbi<TAbi extends ViemABI>(abi: TAbi): ABIContract<TAbi> {\n        return new ABIContract(abi);\n    }\n\n    /**\n     * Returns the function with the given name.\n     * @param {string} name The function's name.\n     * @returns {ABIFunction} The function with the given name.\n     * @throws {InvalidAbiItem}\n     */\n    public getFunction<TFunctionName extends ContractFunctionName<TAbi>>(\n        name: TFunctionName | string\n    ): ABIFunction<TAbi, TFunctionName> {\n        const functionAbiItem = getAbiItem({\n            abi: this.viemABI,\n            name: name as string\n        });\n        if (functionAbiItem === null || functionAbiItem === undefined) {\n            throw new InvalidAbiItem(\n                'ABIContract.getFunction()',\n                `Function '${name}' not found in contract ABI.`,\n                {\n                    type: 'function',\n                    value: name\n                }\n            );\n        }\n        return new ABIFunction<TAbi, TFunctionName>(\n            functionAbiItem as AbiFunction\n        );\n    }\n\n    /**\n     * Returns the event with the given name.\n     * @param {string} name The event's name.\n     * @returns {ABIEvent} The event with the given name.\n     * @throws {InvalidAbiItem}\n     */\n    public getEvent<TEventName extends ContractEventName<TAbi>>(\n        name: TEventName | string\n    ): ABIEvent<TAbi, TEventName> {\n        const eventAbiItem = getAbiItem({\n            abi: this.viemABI,\n            name: name as string\n        });\n        if (eventAbiItem === null || eventAbiItem === undefined) {\n            throw new InvalidAbiItem(\n                'ABIContract.getEvent()',\n                `Function '${name}' not found in contract ABI.`,\n                {\n                    type: 'event',\n                    value: name\n                }\n            );\n        }\n        return new ABIEvent<TAbi, TEventName>(eventAbiItem as AbiEvent);\n    }\n\n    /**\n     * Encode function data that can be used to send a transaction.\n     * @param {string} functionName The name of the function defined in the ABI.\n     * @param {unknown[]} functionData The data to pass to the function.\n     * @returns {Hex} The encoded data in hexadecimal that can be used to send a transaction.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public encodeFunctionInput<\n        TFunctionName extends ContractFunctionName<TAbi>\n    >(functionName: TFunctionName | string, functionData?: unknown[]): Hex {\n        try {\n            const functionAbiItem = getAbiItem({\n                abi: this.viemABI,\n                name: functionName as string\n            });\n            const functionAbi = new ABIFunction<TAbi, TFunctionName>(\n                functionAbiItem as AbiFunction\n            );\n\n            return functionAbi.encodeData(functionData);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIContract.encodeFunctionInput()',\n                `Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.`,\n                { functionName, functionData },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decode the function data of an encoded function\n     * @param {string} functionName The name of the function defined in the ABI.\n     * @param {Hex} encodedFunctionInput The encoded function data.\n     * @returns {DecodeFunctionDataReturnType} an array of the decoded function data\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public decodeFunctionInput<\n        TFunctionName extends ContractFunctionName<TAbi>\n    >(\n        functionName: TFunctionName | string,\n        encodedFunctionInput: Hex\n    ): DecodeFunctionDataReturnType<TAbi, TFunctionName> {\n        try {\n            const functionAbiItem = getAbiItem({\n                abi: this.viemABI,\n                name: functionName as string\n            });\n            const functionAbi = new ABIFunction<TAbi, TFunctionName>(\n                functionAbiItem as AbiFunction\n            );\n\n            return functionAbi.decodeData(encodedFunctionInput);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIContract.decodeFunctionInput()',\n                'Decoding failed: Data must be a valid hex string encoding a compliant ABI type.',\n                { functionName, encodedFunctionInput },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decodes the output from a contract function using the specified ABI and function name.\n     * It takes the encoded function output and attempts to decode it according to the ABI definition.\n     *\n     * @param {string} functionName - The name of the function in the contract to decode the output for.\n     * @param {Hex} encodedFunctionOutput - The encoded output data from the contract function.\n     * @returns {DecodeFunctionResultReturnType} - The decoded output, which provides a user-friendly way\n     * to interact with the decoded data.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     *\n     * @example\n     * // Example of decoding output for a function called \"getValue\":\n     * const decodedOutput = decodeFunctionOutput('getValue', encodedValue);\n     *\n     */\n    public decodeFunctionOutput<\n        TFunctionName extends ContractFunctionName<TAbi>\n    >(\n        functionName: TFunctionName | string,\n        encodedFunctionOutput: Hex\n    ): DecodeFunctionResultReturnType<TAbi, TFunctionName> {\n        try {\n            const functionAbiItem = getAbiItem({\n                abi: this.viemABI,\n                name: functionName as string\n            });\n            const functionAbi = new ABIFunction<TAbi, TFunctionName>(\n                functionAbiItem as AbiFunction\n            );\n\n            return functionAbi.decodeResult(encodedFunctionOutput);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIContract.decodeFunctionOutput()',\n                'Decoding failed: Data must be a valid hex string encoding a compliant ABI type.',\n                { functionName, encodedFunctionOutput },\n                error\n            );\n        }\n    }\n\n    /**\n     * Encodes event log data based on the provided event name, and data to encode.\n     * @param {string} eventName - The name of the event to be encoded.\n     * @param {unknown[]} eventArgs - An array of data to be encoded in the event log.\n     * @returns {ABIEventData} An object containing the encoded data and topics.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public encodeEventLog<TEventName extends ContractEventName<TAbi>>(\n        eventName: TEventName | string,\n        eventArgs: unknown[]\n    ): ABIEventData {\n        try {\n            const eventAbiItem = getAbiItem({\n                abi: this.viemABI,\n                name: eventName as string\n            });\n            const eventAbi = new ABIEvent<TAbi, TEventName>(\n                eventAbiItem as AbiEvent\n            );\n            return eventAbi.encodeEventLog(eventArgs);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIContract.encodeEventLog()',\n                `Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.`,\n                { eventName, dataToEncode: eventArgs },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decodes event log data based on the provided event name, and data/topics to decode.\n     * @param {string} eventName - The name of the event to be decoded.\n     * @param {ABIEventData} eventToDecode - An object containing the data and topics to be decoded.\n     * @returns {DecodeEventLogReturnType} The decoded data of the event log.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public decodeEventLog<TEventName extends ContractEventName<TAbi>>(\n        eventName: TEventName | string,\n        eventToDecode: ABIEventData\n    ): DecodeEventLogReturnType<TAbi, TEventName> {\n        try {\n            const eventAbiItem = getAbiItem({\n                abi: this.viemABI,\n                name: eventName as string\n            });\n            const eventAbi = new ABIEvent<TAbi, TEventName>(\n                eventAbiItem as AbiEvent\n            );\n            return eventAbi.decodeEventLog(eventToDecode);\n        } catch (error) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIContract.encodeEventLog()',\n                `Encoding failed: Data format is invalid. Event data does not match the expected format for ABI type encoding.`,\n                { eventName, dataToDecode: eventToDecode },\n                error\n            );\n        }\n    }\n\n    /**\n     * Decodes a VeChain log based on the ABI definition.\n     *\n     * This method takes raw `data` and `topics` from a VeChain log and attempts\n     * to decode them using the contract's ABI definition. If the decoding is successful,\n     * it returns a log object representing the decoded information. If the decoding fails,\n     * it throws a custom error with detailed information.\n     *\n     * @param {Hex} data - The hexadecimal string of the data field in the log.\n     * @param {Hex[]} topics - An array of hexadecimal strings representing the topics of the log.\n     * @returns {DecodeEventLogReturnType} - A log object representing the decoded log or null if decoding fails.\n     * @throws {InvalidAbiDataToEncodeOrDecode}\n     */\n    public parseLog<TEventName extends ContractEventName<TAbi>>(\n        data: Hex,\n        topics: Hex[]\n    ): DecodeEventLogReturnType<TAbi, TEventName> {\n        try {\n            return ABIEvent.parseLog(this.abi, {\n                data,\n                topics\n            });\n        } catch (e) {\n            throw new InvalidAbiDataToEncodeOrDecode(\n                'ABIContract.parseLog()',\n                `Decoding failed: Data must be a valid hex string encoding a compliant ABI type.`,\n                { data, topics },\n                e\n            );\n        }\n    }\n\n    /**\n     *\n     * Parses the log data and topics into an array of values.\n     *\n     * @param {Hex} data - The hexadecimal string of the data field in the log.\n     * @param {Hex[]} topics - An array of hexadecimal strings representing the topics of the log.\n     * @returns {unknown[]} - An array of values of the decoded log data.\n     */\n    public parseLogAsArray(data: Hex, topics: Hex[]): unknown[] {\n        const eventLogDecoded = this.parseLog(data, topics);\n        if (eventLogDecoded.args === undefined) {\n            return [];\n        }\n\n        return this.parseObjectValues(\n            eventLogDecoded.args as unknown as object\n        );\n    }\n}\n\nexport { ABIContract };\n","import { InvalidOperation } from '@vechain/sdk-errors';\nimport { type Address } from '../Address';\nimport { type Currency } from '../currency/Currency';\nimport { type VeChainDataModel } from '../VeChainDataModel';\n\ntype AccountType = 'EOA' | 'Contract';\n\n/**\n * Represents a VeChain account.\n *\n * @implements {VeChainDataModel<Account>}\n */\nclass Account implements VeChainDataModel<Account> {\n    public readonly address: Address;\n    public readonly balance: Currency;\n    // Replace the string array with a Transaction class #1162\n    public readonly transactions: string[];\n\n    public readonly type: AccountType;\n\n    constructor(\n        address: Address,\n        balance: Currency,\n        type: AccountType = 'EOA',\n        transactions?: string[]\n    ) {\n        this.address = address;\n        this.balance = balance;\n        this.type = type;\n        this.transactions = transactions ?? [];\n    }\n\n    /**\n     * Throws an exception because the account cannot be represented as a big integer.\n     * @returns {bigint} The BigInt representation of the account.\n     * @throws {InvalidOperation} The account cannot be represented as a bigint.\n     * @override {@link VeChainDataModel#bi}\n     * @remarks The conversion to BigInt is not supported for an account.\n     */\n    public get bi(): bigint {\n        throw new InvalidOperation(\n            'Account.bi',\n            'There is no big integer representation for an account.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * Throws an exception because the account cannot be represented as a byte array.\n     * @returns {Uint8Array} The byte array representation of the account.\n     * @throws {InvalidOperation} The account cannot be represented as a byte array.\n     * @override {@link VeChainDataModel#bytes}\n     * @remarks The conversion to byte array is not supported for an account.\n     */\n    public get bytes(): Uint8Array {\n        throw new InvalidOperation(\n            'Account.bytes',\n            'There is no bytes representation for an account.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * Throws an exception because the account cannot be represented as a number.\n     * @returns {bigint} The number representation of the account.\n     * @throws {InvalidOperation} The account cannot be represented as a number.\n     * @override {@link VeChainDataModel#n}\n     * @remarks The conversion to number is not supported for an account.\n     */\n    public get n(): number {\n        throw new InvalidOperation(\n            'Account.n',\n            'There is no number representation for an account.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * Adds a transaction to the account.\n     * @param {string} transaction The transaction to add.\n     */\n    public addTransaction(transaction: string): void {\n        // Replace body once Transaction class is implemented #1162\n        this.transactions.push(transaction);\n    }\n\n    /**\n     * Compare this instance with `that` in a meaningful way.\n     *\n     * @param {Account} that object to compare.\n     * @return a negative number if `this` < `that`, zero if `this` = `that`, a positive number if `this` > that`.\n     * @override {@link VeChainDataModel#compareTo}\n     */\n    public compareTo(that: Account): number {\n        const typeDiff = this.type.localeCompare(that.type);\n        if (typeDiff === 0) {\n            const addressDiff = this.address.compareTo(that.address);\n            if (addressDiff === 0) {\n                const codeDiff = this.balance.code.compareTo(that.balance.code);\n                if (codeDiff === 0) {\n                    return this.balance.value.compareTo(that.balance.value);\n                }\n                return codeDiff;\n            }\n            return addressDiff;\n        }\n        return typeDiff;\n    }\n\n    /**\n     * Checks if the given value is equal to the current instance.\n     *\n     * @param {Account} that - The value to compare.\n     * @returns {boolean} - True if the values are equal, false otherwise.\n     * @override {@link VeChainDataModel#isEqual}\n     */\n    public isEqual(that: Account): boolean {\n        return this.compareTo(that) === 0;\n    }\n\n    /**\n     * Returns a string representation of the account.\n     *\n     * @returns {string} A string representation of the account.\n     */\n    public toString(): string {\n        return `${this.type} Address: ${this.address.toString()} Balance: ${this.balance.value} ${this.balance.code}`;\n    }\n}\n\nexport { Account };\nexport type { AccountType };\n","import { InvalidOperation } from '@vechain/sdk-errors';\nimport { type VeChainDataModel } from './VeChainDataModel';\n\n/**\n * Represents a text string encoded according the *Normalization Form Canonical Composition*\n * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).\n *\n * @implements {VeChainDataModel<Txt>}\n */\nclass Txt extends String implements VeChainDataModel<Txt> {\n    /**\n     * Decoder object used for decoding bytes as text data.\n     *\n     * @class\n     * @constructor\n     */\n    private static readonly DECODER = new TextDecoder();\n\n    /**\n     * *Normalization Form Canonical Composition*\n     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)\n     * flag.\n     *\n     * @type {string}\n     * @constant\n     */\n    private static readonly NFC = 'NFC';\n\n    /**\n     * A TextEncoder instance used for encoding text to bytes.\n     *\n     * @type {TextEncoder}\n     */\n    private static readonly ENCODER = new TextEncoder();\n\n    /**\n     * Creates a new instance of this class representing the `exp` string\n     * normalized according the *Canonical Composition Form*\n     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence).\n     *\n     * @param {string} exp - The expression to be passed to the constructor.\n     * @protected\n     * @constructor\n     */\n    protected constructor(exp: string) {\n        super(exp.normalize(Txt.NFC));\n    }\n\n    /**\n     * Converts the current Txt string to a BigInt.\n     *\n     * @returns {bigint} The BigInt representation of the Txt string.\n     *\n     *  @throws {InvalidOperation} If the conversion to BigInt fails because this Txt string doesn't represent an integer.\n     */\n    get bi(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) {\n            throw new InvalidOperation(\n                'Txt.bi()',\n                \"Can't cast to big integer\",\n                { txt: this.toString() },\n                e\n            );\n        }\n    }\n\n    /**\n     * Converts the current Txt string to a buffer of bytes.\n     *\n     * @returns {Uint8Array} The bytes representation of the Txt string.\n     */\n    get bytes(): Uint8Array {\n        return Txt.ENCODER.encode(this.toString());\n    }\n\n    /**\n     * Returns the value of n as a number.\n     *\n     * @returns {number} The value of n as a number.\n     */\n    /**\n     * Converts the current Txt string to a number.\n     *\n     * @returns {number} The numeric value of the Txt string.\n     *\n     * @throws {InvalidOperation} If the conversion to number fails because this Txt string doesn't represent a decimal number.\n     */\n    get n(): number {\n        return Number(this.toString());\n    }\n\n    /**\n     * Compares the current instance to another instance of Txt.\n     *\n     * @param {Txt} that - The instance to compare with.\n     *\n     * @return {number} - A negative number if the current instance is less than the specified instance,\n     *                    zero if they are equal, or a positive number if the current instance is greater.\n     */\n    public compareTo(that: Txt): number {\n        return this.toString().localeCompare(that.toString());\n    }\n\n    /**\n     * Checks if the current Txt object is equal to the given Txt object.\n     *\n     * @param {Txt} that - The Txt object to compare with.\n     *\n     *  @return {boolean} - True if the objects are equal, false otherwise.\n     */\n    public isEqual(that: Txt): boolean {\n        return this.compareTo(that) === 0;\n    }\n\n    /**\n     * Returns a string representation of the object.\n     *\n     * @returns {string} A string representation of the object.\n     */\n    public toString(): string {\n        return this.valueOf();\n    }\n\n    /**\n     * Creates a new Txt instance from the provided expression.\n     *\n     * @param {bigint | number | string | Uint8Array} exp - The expression to convert to Txt:\n     * * {@link bigint} is represented as a {@link NFC} encoded string expressing the value in base 10;\n     * * {@link number} is represented as a {@link NFC} encoded string expressing the value in base 10;\n     * * {@link string} is encoded as {@link NFC} string;\n     * * {@link Uint8Array} is {@link NFC} decoded to a string.\n     *\n     * @returns {Txt} - A new Txt instance.\n     */\n    public static of(exp: bigint | number | string | Uint8Array): Txt {\n        if (typeof exp === 'string') {\n            return new Txt(exp);\n        } else if (typeof exp === 'bigint' || typeof exp === 'number') {\n            return new Txt(exp.toString());\n        }\n        return new Txt(Txt.DECODER.decode(exp));\n    }\n}\n\nexport { Txt };\n","import { InvalidDataType, InvalidOperation } from '@vechain/sdk-errors';\nimport { type VeChainDataModel } from './VeChainDataModel';\nimport { Txt } from './Txt';\n\n/**\n * Represents a fixed-point number for precision arithmetic.\n */\nclass FixedPointNumber implements VeChainDataModel<FixedPointNumber> {\n    /**\n     * Base of value notation.\n     */\n    private static readonly BASE = 10n;\n\n    /**\n     * The default number of decimal places to use for fixed-point math.\n     *\n     * @see\n     * [bignumber.js DECIMAL_PLACES](https://mikemcl.github.io/bignumber.js/#decimal-places)\n     *\n     * @constant {bigint}\n     */\n    protected static readonly DEFAULT_FRACTIONAL_DECIMALS = 20n;\n\n    /**\n     * Not a Number.\n     *\n     * @remarks {@link fractionalDigits} and {@link scaledValue} not meaningful.\n     *\n     * @see [Number.NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN)\n     *\n     */\n    public static readonly NaN = new FixedPointNumber(0n, 0n, NaN);\n\n    /**\n     * The negative Infinity value.\n     *\n     * @remarks {@link fractionalDigits} and {@link scaledValue} not meaningful.\n     *\n     * @see [Number.NEGATIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY)\n     */\n    public static readonly NEGATIVE_INFINITY = new FixedPointNumber(\n        0n,\n        0n,\n        Number.NEGATIVE_INFINITY\n    );\n\n    /**\n     * Represents the one constant.\n     */\n    public static readonly ONE = FixedPointNumber.of(1n);\n\n    /**\n     * The positive Infinite value.\n     *\n     * @remarks {@link fractionalDigits} and {@link scaledValue} not meaningful.\n     *\n     * @see [Number.POSITIVE_INFINITY](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY)\n     */\n    public static readonly POSITIVE_INFINITY = new FixedPointNumber(\n        0n,\n        0n,\n        Number.POSITIVE_INFINITY\n    );\n\n    /**\n     * Regular expression pattern for matching integers expressed as base 10 strings.\n     */\n    private static readonly REGEX_INTEGER: RegExp = /^[-+]?\\d+$/;\n\n    /**\n     * Regular expression for matching numeric values expressed as base 10 strings.\n     */\n    private static readonly REGEX_NUMBER =\n        /(^[-+]?\\d+(\\.\\d+)?)$|(^[-+]?\\.\\d+)$/;\n\n    /**\n     * Regular expression pattern for matching natural numbers expressed as base 10 strings.\n     */\n    private static readonly REGEX_NATURAL: RegExp = /^\\d+$/;\n\n    /**\n     * Represents the zero constant.\n     */\n    public static readonly ZERO = new FixedPointNumber(0n, 0n, 0);\n\n    /**\n     * Edge Flag denotes the {@link NaN} or {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY} value.\n     *\n     * @remarks If `ef` is not zero, {@link fractionalDigits} and {@link scaledValue} are not meaningful.\n     */\n    protected readonly edgeFlag: number;\n\n    /**\n     * Fractional Digits or decimal places.\n     *\n     * @see [bignumber.js precision](https://mikemcl.github.io/bignumber.js/#sd)\n     */\n    public readonly fractionalDigits: bigint;\n\n    /**\n     * Scaled Value = value * 10 ^ {@link fractionalDigits}.\n     */\n    public readonly scaledValue: bigint;\n\n    /**\n     * Returns the integer part of this FixedPointNumber value.\n     *\n     * @return {bigint} the integer part of this FixedPointNumber value.\n     *\n     * @throws {InvalidOperation} If the value is not finite.\n     */\n    get bi(): bigint {\n        if (this.isFinite()) {\n            return (\n                this.scaledValue /\n                FixedPointNumber.BASE ** this.fractionalDigits\n            );\n        }\n        throw new InvalidOperation(\n            'FixedPointNumber.bi',\n            'not finite value cannot cast to big integer',\n            { this: this.toString() }\n        );\n    }\n\n    /**\n     * Returns the array of bytes representing the *Normalization Form Canonical Composition*\n     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)\n     * of this value expressed in decimal base.\n     */\n    get bytes(): Uint8Array {\n        return Txt.of(this.toString()).bytes;\n    }\n\n    /**\n     * Return this value approximated as {@link number}.\n     */\n    get n(): number {\n        if (this.isNaN()) return Number.NaN;\n        if (this.isNegativeInfinite()) return Number.NEGATIVE_INFINITY;\n        if (this.isPositiveInfinite()) return Number.POSITIVE_INFINITY;\n        if (this.isZero()) return 0;\n        return Number(this.scaledValue) * 10 ** -Number(this.fractionalDigits);\n    }\n\n    /**\n     * Returns the new Fixed-Point Number (FixedPointNumber) instance having\n     *\n     * @param {bigint} fd - Number of Fractional Digits (or decimal places).\n     * @param {bigint} sv - Scaled Value.\n     * @param {number} [ef=0] - Edge Flag.\n     */\n    protected constructor(fd: bigint, sv: bigint, ef: number = 0) {\n        this.fractionalDigits = fd;\n        this.edgeFlag = ef;\n        this.scaledValue = sv;\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the absolute value, i.e. the magnitude, of the value of this FixedPointNumber.\n     *\n     * @return {FixedPointNumber} the absolute value of this FixedPointNumber.\n     *\n     * @see [bignumber.js absoluteValue](https://mikemcl.github.io/bignumber.js/#abs)\n     */\n    public abs(): FixedPointNumber {\n        if (this.isNaN()) return FixedPointNumber.NaN;\n        if (this.isNegativeInfinite())\n            return FixedPointNumber.POSITIVE_INFINITY;\n        return new FixedPointNumber(\n            this.fractionalDigits,\n            this.scaledValue < 0n ? -this.scaledValue : this.scaledValue,\n            this.edgeFlag\n        );\n    }\n\n    /**\n     * Compares this instance with `that` FixedPointNumber instance.\n     * * Returns 0 if this is equal to `that` FixedPointNumber, including infinite with equal sign;\n     * * Returns -1, if this is -Infinite or less than `that` FixedPointNumber;,\n     * * Returns 1 if this is +Infinite or greater than `that` FixedPointNumber.\n     *\n     * @param {FixedPointNumber} that - The instance to compare with this instance.\n     * @return {number} Returns -1, 0, or 1 if this instance is less than, equal to, or greater\n     * than the specified instance, respectively.\n     * @throw InvalidOperation If this or `that` FixedPointNumber is {@link NaN}.\n     *\n     * @see [bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)\n     */\n    public compareTo(that: FixedPointNumber): number {\n        if (this.isNaN() || that.isNaN())\n            throw new InvalidOperation(\n                'FixedPointNumber.compareTo',\n                'compare between NaN',\n                {\n                    this: `${this}`,\n                    that: `${that}`\n                }\n            );\n        if (this.isNegativeInfinite())\n            return that.isNegativeInfinite() ? 0 : -1;\n        if (this.isPositiveInfinite()) return that.isPositiveInfinite() ? 0 : 1;\n        if (that.isNegativeInfinite()) return 1;\n        if (that.isPositiveInfinite()) return -1;\n        const fd = this.maxFractionalDigits(that, this.fractionalDigits); // Max common fractional decimals.\n        const delta = this.dp(fd).scaledValue - that.dp(fd).scaledValue;\n        return delta < 0n ? -1 : delta === 0n ? 0 : 1;\n    }\n\n    /**\n     * Compares this instance with `that` FixedPointNumber instance.\n     * * **Returns `null` if either instance is NaN;**\n     * * Returns 0 if this is equal to `that` FixedPointNumber, including infinite with equal sign;\n     * * Returns -1, if this is -Infinite or less than `that` FixedPointNumber;,\n     * * Returns 1 if this is +Infinite or greater than `that` FixedPointNumber.\n     *\n     * @param {FixedPointNumber} that - The instance to compare with this instance.\n     * @return {null | number} A null if either instance is NaN;\n     * -1, 0, or 1 if this instance is less than, equal to, or greater\n     * than the specified instance, respectively.\n     *\n     * @remarks This method uses internally {@link compareTo} wrapping the {@link InvalidOperation} exception\n     * when comparing between {@link NaN} values to behave according the\n     * [[bignumber.js comparedTo](https://mikemcl.github.io/bignumber.js/#cmp)] rules.\n     */\n    public comparedTo(that: FixedPointNumber): null | number {\n        try {\n            return this.compareTo(that);\n        } catch {\n            return null;\n        }\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber divided by `that` FixedPointNumber.\n     *\n     * Limit cases\n     * * 0 / 0 = NaN\n     * * NaN / n = NaN\n     * * Infinity / Infinity = NaN\n     * * +n / NaN = NaN\n     * * +n / Infinity = 0\n     * * -n / 0 = -Infinity\n     * * +n / 0 = +Infinity\n     *\n     * @param {FixedPointNumber} that - The fixed-point number to divide by.\n     * @return {FixedPointNumber} The result of the division.\n     *\n     * @remarks The precision is the greater of the precision of the two operands.\n     *\n     * @see [bignumber.js dividedBy](https://mikemcl.github.io/bignumber.js/#div)\n     */\n    public div(that: FixedPointNumber): FixedPointNumber {\n        if (this.isNaN() || that.isNaN()) return FixedPointNumber.NaN;\n        if (this.isNegativeInfinite()) {\n            if (that.isInfinite()) return FixedPointNumber.NaN;\n            if (that.isPositive()) return FixedPointNumber.NEGATIVE_INFINITY;\n            return FixedPointNumber.POSITIVE_INFINITY;\n        }\n        if (this.isPositiveInfinite()) {\n            if (that.isInfinite()) return FixedPointNumber.NaN;\n            if (that.isPositive()) return FixedPointNumber.POSITIVE_INFINITY;\n            return FixedPointNumber.NEGATIVE_INFINITY;\n        }\n        if (that.isInfinite()) return FixedPointNumber.ZERO;\n        if (that.isZero()) {\n            if (this.isZero()) return FixedPointNumber.NaN;\n            if (this.isNegative()) return FixedPointNumber.NEGATIVE_INFINITY;\n            return FixedPointNumber.POSITIVE_INFINITY;\n        }\n        const fd = this.maxFractionalDigits(that, this.fractionalDigits); // Max common fractional decimals.\n        return new FixedPointNumber(\n            fd,\n            FixedPointNumber.div(\n                fd,\n                this.dp(fd).scaledValue,\n                that.dp(fd).scaledValue\n            )\n        ).dp(this.fractionalDigits); // Minimize fractional decimals without precision loss.\n    }\n\n    /**\n     * Divides the given dividend by the given divisor, adjusted by a factor based on fd.\n     *\n     * @param {bigint} fd - The factor determining the power of 10 to apply to the dividend.\n     * @param {bigint} dividend - The number to be divided.\n     * @param {bigint} divisor - The number by which to divide the dividend.\n     *\n     * @return {bigint} - The result of the division, adjusted by the given factor fd.\n     */\n    private static div(fd: bigint, dividend: bigint, divisor: bigint): bigint {\n        return (FixedPointNumber.BASE ** fd * dividend) / divisor;\n    }\n\n    /**\n     * Adjust the precision of the floating-point number by the specified\n     * number of decimal places.\n     *\n     * @param decimalPlaces The number of decimal places to adjust to,\n     *                      it must be a positive value.\n     * @return {FixedPointNumber} A new FixedPointNumber instance with the adjusted precision.\n     * @throws InvalidDataType if `decimalPlaces` is negative.\n     */\n    public dp(decimalPlaces: bigint | number): FixedPointNumber {\n        const dp = BigInt(decimalPlaces);\n        if (dp >= 0) {\n            let fd = this.fractionalDigits;\n            let sv = this.scaledValue;\n            if (dp > fd) {\n                // Scale up.\n                sv *= FixedPointNumber.BASE ** (dp - fd);\n                fd = dp;\n            } else {\n                // Scale down.\n                while (fd > dp && sv % FixedPointNumber.BASE === 0n) {\n                    fd--;\n                    sv /= FixedPointNumber.BASE;\n                }\n            }\n            return new FixedPointNumber(fd, sv, this.edgeFlag);\n        }\n        throw new InvalidDataType(\n            'FixedPointNumber.scale',\n            'negative `dp` arg',\n            { dp: `${dp}` }\n        );\n    }\n\n    /**\n     * Returns `true `if the value of thisFPN is equal to the value of `that` FixedPointNumber, otherwise returns `false`.\n     *\n     * As with JavaScript, `NaN` does not equal `NaN`.\n     *\n     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n     * @return {boolean} `true` if the FixedPointNumber numbers are equal, otherwise `false`.\n     *\n     * @remarks This method uses {@link comparedTo} internally.\n     *\n     * @see [bigbumber.js isEqualTo](https://mikemcl.github.io/bignumber.js/#eq)\n     */\n    public eq(that: FixedPointNumber): boolean {\n        return this.comparedTo(that) === 0;\n    }\n\n    /**\n     * Returns `true` if the value of this FixedPointNumber is greater than `that` FixedPointNumber`, otherwise returns `false`.\n     *\n     * @param {FixedPointNumber} that The FixedPointNumber to compare against.\n     * @return {boolean} `true` if this FixedPointNumber is greater than `that` FixedPointNumber, otherwise `false`.\n     *\n     * @remarks This method uses {@link comparedTo} internally.\n     *\n     * @see [bignummber.js isGreaterThan](https://mikemcl.github.io/bignumber.js/#gt)\n     */\n    public gt(that: FixedPointNumber): boolean {\n        const cmp = this.comparedTo(that);\n        return cmp !== null && cmp > 0;\n    }\n\n    /**\n     * Returns `true` if the value of this FixedPointNumber is greater or equal than `that` FixedPointNumber`, otherwise returns `false`.\n     *\n     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n     * @return {boolean} `true` if this FixedPointNumber is greater or equal than `that` FixedPointNumber, otherwise `false`.\n     *\n     * @remarks This method uses {@link comparedTo} internally.\n     *\n     * @see [bignumber.js isGreaterThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#gte)\n     */\n    public gte(that: FixedPointNumber): boolean {\n        const cmp = this.comparedTo(that);\n        return cmp !== null && cmp >= 0;\n    }\n\n    /**\n     * Returns a fixed-point number whose value is the integer part of dividing the value of this fixed-point number\n     * by `that` fixed point number.\n     *\n     * Limit cases\n     * * 0 / 0 = NaN\n     * * NaN / n = NaN\n     * * Infinity / Infinity = NaN\n     * * +n / NaN = NaN\n     * * +n / Infinite = 0\n     * * -n / 0 = -Infinite\n     * * +n / 0 = +Infinite\n     *\n     * @param {FixedPointNumber} that - The fixed-point number to divide by.\n     * @return {FixedPointNumber} The result of the division.\n     *\n     * @remarks The precision is the greater of the precision of the two operands.\n     *\n     * @see [bignumber.js dividedToIntegerBy](https://mikemcl.github.io/bignumber.js/#divInt)\n     */\n    public idiv(that: FixedPointNumber): FixedPointNumber {\n        if (this.isNaN() || that.isNaN()) return FixedPointNumber.NaN;\n        if (this.isNegativeInfinite()) {\n            if (that.isInfinite()) return FixedPointNumber.NaN;\n            if (that.isPositive()) return FixedPointNumber.NEGATIVE_INFINITY;\n            return FixedPointNumber.POSITIVE_INFINITY;\n        }\n        if (this.isPositiveInfinite()) {\n            if (that.isInfinite()) return FixedPointNumber.NaN;\n            if (that.isPositive()) return FixedPointNumber.POSITIVE_INFINITY;\n            return FixedPointNumber.NEGATIVE_INFINITY;\n        }\n        if (that.isInfinite()) return FixedPointNumber.ZERO;\n        if (that.isZero()) {\n            if (this.isZero()) return FixedPointNumber.NaN;\n            if (this.isNegative()) return FixedPointNumber.NEGATIVE_INFINITY;\n            return FixedPointNumber.POSITIVE_INFINITY;\n        }\n        const fd = this.maxFractionalDigits(that, this.fractionalDigits); // Max common fractional decimals.\n        return new FixedPointNumber(\n            fd,\n            FixedPointNumber.idiv(\n                fd,\n                this.dp(fd).scaledValue,\n                that.dp(fd).scaledValue\n            )\n        ).dp(this.fractionalDigits); // Minimize fractional decimals without precision loss.\n    }\n\n    /**\n     * Performs integer division on two big integers and scales the result by a factor of 10 raised to the power of fd.\n     *\n     * @param {bigint} fd - The power to which 10 is raised to scale the result.\n     * @param {bigint} dividend - The number to be divided.\n     * @param {bigint} divisor - The number by which dividend is divided.\n     * @return {bigint} - The scaled result of the integer division.\n     */\n    private static idiv(fd: bigint, dividend: bigint, divisor: bigint): bigint {\n        return (dividend / divisor) * FixedPointNumber.BASE ** fd;\n    }\n\n    /**\n     * Returns `true `if the value of thisFPN is equal to the value of `that` FixedPointNumber, otherwise returns `false`.\n     *\n     * As with JavaScript, `NaN` does not equal `NaN`.\n     *\n     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n     * @return {boolean} `true` if the FixedPointNumber numbers are equal, otherwise `false`.\n     *\n     * @remarks This method uses {@link eq} internally.\n     */\n    public isEqual(that: FixedPointNumber): boolean {\n        return this.eq(that);\n    }\n\n    /**\n     * Returns `true` if the value of this FixedPointNumber is a finite number, otherwise returns `false`.\n     *\n     * The only possible non-finite values of a FixedPointNumber are {@link NaN}, {@link NEGATIVE_INFINITY} and {@link POSITIVE_INFINITY}.\n     *\n     * @return `true` if the value of this FixedPointNumber is a finite number, otherwise returns `false`.\n     *\n     * @see [bignumber.js isFinite](https://mikemcl.github.io/bignumber.js/#isF)\n     */\n    public isFinite(): boolean {\n        return this.edgeFlag === 0;\n    }\n\n    /**\n     * Return `true` if the value of this FixedPointNumber is {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY},\n     * otherwise returns false.\n     *\n     * @return true` if the value of this FixedPointNumber is {@link NEGATIVE_INFINITY} or {@link POSITIVE_INFINITY},\n     */\n    public isInfinite(): boolean {\n        return this.isNegativeInfinite() || this.isPositiveInfinite();\n    }\n\n    /**\n     * Returns `true` if the value of this FixedPointNumber is an integer,\n     * otherwise returns `false`.\n     *\n     * @return `true` if the value of this FixedPointNumber is an integer.\n     *\n     * @see [bignumber.js isInteger](https://mikemcl.github.io/bignumber.js/#isInt)\n     */\n    public isInteger(): boolean {\n        if (this.isFinite()) {\n            return (\n                this.scaledValue %\n                    FixedPointNumber.BASE ** this.fractionalDigits ===\n                0n\n            );\n        }\n        return false;\n    }\n\n    /**\n     * Checks if a given string expression is an integer in base 10 notation,\n     * considering `-` for negative and `+` optional for positive values.\n     *\n     * @param {string} exp - The string expression to be tested.\n     *\n     * @return {boolean} `true` if the expression is an integer,\n     * `false` otherwise.\n     */\n    public static isIntegerExpression(exp: string): boolean {\n        return this.REGEX_INTEGER.test(exp);\n    }\n\n    /**\n     *  Returns `true` if the value of this FixedPointNumber is `NaN`, otherwise returns `false`.\n     *\n     *  @return `true` if the value of this FixedPointNumber is `NaN`, otherwise returns `false`.\n     *\n     *  @see [bignumber.js isNaN](https://mikemcl.github.io/bignumber.js/#isNaN)\n     */\n    public isNaN(): boolean {\n        return Number.isNaN(this.edgeFlag);\n    }\n\n    /**\n     * Checks if a given string expression is a natural (unsigned positive integer)\n     * number in base 10 notation.\n     *\n     * @param {string} exp - The string expression to be tested.\n     *\n     * @return {boolean} `true` if the expression is a natural number,\n     * `false` otherwise.\n     */\n    public static isNaturalExpression(exp: string): boolean {\n        return this.REGEX_NATURAL.test(exp);\n    }\n\n    /**\n     * Returns `true` if the sign of this FixedPointNumber is negative, otherwise returns `false`.\n     *\n     * @return `true` if the sign of this FixedPointNumber is negative, otherwise returns `false`.\n     *\n     * @see [bignumber.js isNegative](https://mikemcl.github.io/bignumber.js/#isNeg)\n     */\n    public isNegative(): boolean {\n        return (\n            (this.isFinite() && this.scaledValue < 0n) ||\n            this.isNegativeInfinite()\n        );\n    }\n\n    /**\n     * Returns `true` if this FixedPointNumber value is {@link NEGATIVE_INFINITY}, otherwise returns `false`.\n     */\n    public isNegativeInfinite(): boolean {\n        return this.edgeFlag === Number.NEGATIVE_INFINITY;\n    }\n\n    /**\n     * Checks if a given string expression is a number in base 10 notation,\n     * considering `-` for negative and `+` optional for positive values.\n     *\n     * The method returns `true` for the following cases.\n     * - Whole numbers:\n     *   - Positive whole numbers, optionally signed: 1, +2, 3, ...\n     *   - Negative whole numbers: -1, -2, -3, ...\n     * - Decimal numbers:\n     *   - Positive decimal numbers, optionally signed: 1.0, +2.5, 3.14, ...\n     *   - Negative decimal numbers: -1.0, -2.5, -3.14, ...\n     *   - Decimal numbers without whole part:\n     *     - Positive decimal numbers, optionally signed: .1, +.5, .75, ...\n     *     - Negative decimal numbers: -.1, -.5, -.75, ...\n     *\n     * @param exp - The string expression to be checked.\n     *\n     * @return `true` is `exp` represents a number, otherwise `false`.\n     */\n    public static isNumberExpression(exp: string): boolean {\n        return FixedPointNumber.REGEX_NUMBER.test(exp);\n    }\n\n    /**\n     * Returns `true` if the sign of this FixedPointNumber is positive, otherwise returns `false`.\n     *\n     * @return `true` if the sign of this FixedPointNumber is positive, otherwise returns `false`.\n     *\n     * @see [bignumber.js isPositive](https://mikemcl.github.io/bignumber.js/#isPos)\n     */\n    public isPositive(): boolean {\n        return (\n            (this.isFinite() && this.scaledValue >= 0n) ||\n            this.isPositiveInfinite()\n        );\n    }\n\n    /**\n     * Returns `true` if this FixedPointNumber value is {@link POSITIVE_INFINITY}, otherwise returns `false`.\n     *\n     * @return `true` if this FixedPointNumber value is {@link POSITIVE_INFINITY}, otherwise returns `false`.\n     */\n    public isPositiveInfinite(): boolean {\n        return this.edgeFlag === Number.POSITIVE_INFINITY;\n    }\n\n    /**\n     * Returns `true` if the value of this FixedPointNumber is zero or minus zero, otherwise returns `false`.\n     *\n     * @return `true` if the value of this FixedPointNumber is zero or minus zero, otherwise returns `false`.\n     *\n     * [see bignumber.js isZero](https://mikemcl.github.io/bignumber.js/#isZ)\n     */\n    public isZero(): boolean {\n        return this.isFinite() && this.scaledValue === 0n;\n    }\n\n    /**\n     * Returns `true` if the value of this FixedPointNumber is less than the value of `that` FixedPointNumber, otherwise returns `false`.\n     *\n     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n     *\n     * @return {boolean} `true` if the value of this FixedPointNumber is less than the value of `that` FixedPointNumber, otherwise returns `false`.\n     *\n     * @remarks This method uses {@link comparedTo} internally.\n     *\n     * @see [bignumber.js isLessThan](https://mikemcl.github.io/bignumber.js/#lt)\n     */\n    public lt(that: FixedPointNumber): boolean {\n        const cmp = this.comparedTo(that);\n        return cmp !== null && cmp < 0;\n    }\n\n    /**\n     * Returns `true` if the value of this FixedPointNumber is less than or equal to the value of `that` FixedPointNumber,\n     * otherwise returns `false`.\n     *\n     * @param {FixedPointNumber} that - The FixedPointNumber to compare against.\n     * @return {boolean} `true` if the value of this FixedPointNumber is less than or equal to the value of `that` FixedPointNumber,\n     * otherwise returns `false`.\n     *\n     * @remarks This method uses {@link comparedTo} internally.\n     *\n     * @see [bignumber.js isLessThanOrEqualTo](https://mikemcl.github.io/bignumber.js/#lte)\n     */\n    public lte(that: FixedPointNumber): boolean {\n        const cmp = this.comparedTo(that);\n        return cmp !== null && cmp <= 0;\n    }\n\n    /**\n     * Return the maximum between the fixed decimal value of this object and `that` one.\n     * If the maximum fixed digits value is less than `minFixedDigits`, return `minFixedDigits`.\n     *\n     * @param {FixedPointNumber} that to evaluate if `that` has the maximum fixed digits value.\n     * @param {bigint} minFixedDigits Min value of returned value.\n     *\n     * @return the greater fixed digits value among `this`, `that` and `minFixedDigits`.\n     */\n    private maxFractionalDigits(\n        that: FixedPointNumber,\n        minFixedDigits: bigint\n    ): bigint {\n        const fd =\n            this.fractionalDigits < that.fractionalDigits\n                ? that.fractionalDigits\n                : this.fractionalDigits;\n        return fd > minFixedDigits ? fd : minFixedDigits;\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber minus `that` FixedPointNumber.\n     *\n     * Limit cases\n     * * NaN - n = NaN\n     * * n - NaN = NaN\n     * * -Infinity - -Infinity = NaN\n     * * -Infinity - +n = -Infinity\n     * * +Infinity - +Infinity = NaN\n     * * +Infinity - +n = +Infinity\n     *\n     * @param {FixedPointNumber} that - The fixed-point number to subtract.\n     * @return {FixedPointNumber} The result of the subtraction. The return value is always exact and unrounded.\n     *\n     * @remarks The precision is the greater of the precision of the two operands.\n     *\n     * @see [bignumber.js minus](https://mikemcl.github.io/bignumber.js/#minus)\n     */\n    public minus(that: FixedPointNumber): FixedPointNumber {\n        if (this.isNaN() || that.isNaN()) return FixedPointNumber.NaN;\n        if (this.isNegativeInfinite())\n            return that.isNegativeInfinite()\n                ? FixedPointNumber.NaN\n                : FixedPointNumber.NEGATIVE_INFINITY;\n        if (this.isPositiveInfinite())\n            return that.isPositiveInfinite()\n                ? FixedPointNumber.NaN\n                : FixedPointNumber.POSITIVE_INFINITY;\n        const fd = this.maxFractionalDigits(that, this.fractionalDigits); // Max common fractional decimals.\n        return new FixedPointNumber(\n            fd,\n            this.dp(fd).scaledValue - that.dp(fd).scaledValue\n        ).dp(this.fractionalDigits); // Minimize fractional decimals without precision loss.\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber modulo `that` FixedPointNumber,\n     * i.e. the integer remainder of dividing this FixedPointNumber by `that`.\n     *\n     * Limit cases\n     * * NaN % n = NaN\n     * * n % NaN = NaN\n     * * Infinity % n = NaN\n     * * n % Infinity = NaN\n     *\n     * @param that {FixedPointNumber} - The fixed-point number to divide by.\n     * @return {FixedPointNumber} the integer remainder of dividing this FixedPointNumber by `that`.\n     *\n     * @remarks The precision is the greater of the precision of the two operands.\n     *\n     * @see [bignumber.js modulo](https://mikemcl.github.io/bignumber.js/#mod)\n     */\n    public modulo(that: FixedPointNumber): FixedPointNumber {\n        if (this.isNaN() || that.isNaN()) return FixedPointNumber.NaN;\n        if (this.isInfinite() || that.isInfinite()) return FixedPointNumber.NaN;\n        if (that.isZero()) return FixedPointNumber.NaN;\n        const fd = this.maxFractionalDigits(that, this.fractionalDigits); // Max common fractional decimals.\n        let modulo = this.abs().dp(fd).scaledValue;\n        const divisor = that.abs().dp(fd).scaledValue;\n        while (modulo >= divisor) {\n            modulo -= divisor;\n        }\n        return new FixedPointNumber(fd, modulo).dp(this.fractionalDigits); // Minimize fractional decimals without precision loss.\n    }\n\n    /**\n     * Multiplies two big integer values and divides by a factor of ten raised to a specified power.\n     *\n     * @param {bigint} multiplicand - The first number to be multiplied.\n     * @param {bigint} multiplicator - The second number to be multiplied.\n     * @param {bigint} fd - The power of ten by which the product is to be divided.\n     *\n     * @return {bigint} The result of the multiplication divided by ten raised to the specified power.\n     */\n    private static mul(\n        multiplicand: bigint,\n        multiplicator: bigint,\n        fd: bigint\n    ): bigint {\n        return (multiplicand * multiplicator) / FixedPointNumber.BASE ** fd;\n    }\n\n    /**\n     * Returns a new instance of FixedPointNumber whose value is the value of this FixedPointNumber value\n     * negated, i.e. multiplied by -1.\n     *\n     * @see [bignumber.js negated](https://mikemcl.github.io/bignumber.js/#neg)\n     */\n    public negated(): FixedPointNumber {\n        if (this.isNegativeInfinite())\n            return FixedPointNumber.POSITIVE_INFINITY;\n        if (this.isPositiveInfinite())\n            return FixedPointNumber.NEGATIVE_INFINITY;\n        return new FixedPointNumber(\n            this.fractionalDigits,\n            -this.scaledValue,\n            this.edgeFlag\n        );\n    }\n\n    /**\n     * Constructs a new instance of FixedPointNumber (Fixed Point Number) parsing the\n     * `exp` numeric expression in base 10 and representing the value with the\n     * precision of `decimalPlaces` fractional decimal digits.\n     *\n     * @param {bigint|number|string} exp - The value to represent.\n     * It can be a bigint, number, or string representation of the number.\n     * @param {bigint} [decimalPlaces=this.DEFAULT_FRACTIONAL_DECIMALS] - The\n     * number of fractional decimal digits to be used to represent the value.\n     *\n     * @return {FixedPointNumber} A new instance of FixedPointNumber with the given parameters.\n     *\n     * @throws {InvalidDataType} If `exp` is not a numeric expression.\n     */\n    public static of(\n        exp: bigint | number | string | FixedPointNumber,\n        decimalPlaces: bigint = this.DEFAULT_FRACTIONAL_DECIMALS\n    ): FixedPointNumber {\n        try {\n            if (exp instanceof FixedPointNumber) {\n                return new FixedPointNumber(\n                    exp.fractionalDigits,\n                    exp.scaledValue,\n                    exp.edgeFlag\n                );\n            }\n            if (Number.isNaN(exp))\n                return new FixedPointNumber(decimalPlaces, 0n, Number.NaN);\n            if (exp === Number.NEGATIVE_INFINITY)\n                return new FixedPointNumber(\n                    decimalPlaces,\n                    -1n,\n                    Number.NEGATIVE_INFINITY\n                );\n            if (exp === Number.POSITIVE_INFINITY)\n                return new FixedPointNumber(\n                    decimalPlaces,\n                    1n,\n                    Number.POSITIVE_INFINITY\n                );\n            return new FixedPointNumber(\n                decimalPlaces,\n                this.txtToSV(exp.toString(), decimalPlaces)\n            );\n        } catch (e) {\n            throw new InvalidDataType(\n                'FixedPointNumber.of',\n                'not a number',\n                { exp },\n                e\n            );\n        }\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber plus `that` FixedPointNumber.\n     *\n     * Limit cases\n     * * NaN + n = NaN\n     * * n + NaN = NaN\n     * * -Infinity + -Infinity = -Infinity\n     * * -Infinity + +Infinity = NaN\n     * * +Infinity + -Infinity = NaN\n     * * +Infinity + +Infinity = +Infinity\n     *\n     * @param {FixedPointNumber} that - The fixed-point number to add to the current number.\n     * @return {FixedPointNumber} The result of the addition. The return value is always exact and unrounded.\n     *\n     * @remarks The precision is the greater of the precision of the two operands.\n     *\n     * @see [bignumber.js plus](https://mikemcl.github.io/bignumber.js/#plus)\n     */\n    public plus(that: FixedPointNumber): FixedPointNumber {\n        if (this.isNaN() || that.isNaN()) return FixedPointNumber.NaN;\n        if (this.isNegativeInfinite())\n            return that.isPositiveInfinite()\n                ? FixedPointNumber.NaN\n                : FixedPointNumber.NEGATIVE_INFINITY;\n        if (this.isPositiveInfinite())\n            return that.isNegativeInfinite()\n                ? FixedPointNumber.NaN\n                : FixedPointNumber.POSITIVE_INFINITY;\n        const fd = this.maxFractionalDigits(that, this.fractionalDigits); // Max common fractional decimals.\n        return new FixedPointNumber(\n            fd,\n            this.dp(fd).scaledValue + that.dp(fd).scaledValue\n        ).dp(this.fractionalDigits); // Minimize fractional decimals without precision loss.\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber raised to the power of `that` FixedPointNumber.\n     *\n     * This method implements the\n     * [Exponentiation by Squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)\n     * algorithm.\n     *\n     * Limit cases\n     * * NaN ^ e = NaN\n     * * b ^ NaN = NaN\n     * * b ^ -Infinite = 0\n     * * b ^ 0 = 1\n     * * b ^ +Infinite = +Infinite\n     * * Infinite ^ -e = 0\n     * * Infinite ^ +e = +Infinite\n     *\n     * @param {FixedPointNumber} that - The exponent as a fixed-point number.\n     * truncated to its integer component because **Exponentiation by Squaring** is not valid for rational exponents.\n     * @return {FixedPointNumber} - The result of raising this fixed-point number to the power of the given exponent.\n     *\n     * @see [bignumber.js exponentiatedBy](https://mikemcl.github.io/bignumber.js/#pow)\n     */\n    public pow(that: FixedPointNumber): FixedPointNumber {\n        // Limit cases\n        if (this.isNaN() || that.isNaN()) return FixedPointNumber.NaN;\n        if (this.isInfinite())\n            return that.isZero()\n                ? FixedPointNumber.ONE\n                : that.isNegative()\n                  ? FixedPointNumber.ZERO\n                  : FixedPointNumber.POSITIVE_INFINITY;\n        if (that.isNegativeInfinite()) return FixedPointNumber.ZERO;\n        if (that.isPositiveInfinite()) {\n            return FixedPointNumber.POSITIVE_INFINITY;\n        }\n        if (that.isZero()) return FixedPointNumber.ONE;\n        // Exponentiation by squaring works for natural exponent value.\n        let exponent = that.abs().bi;\n        let base = FixedPointNumber.of(this);\n        let result = FixedPointNumber.ONE;\n        while (exponent > 0n) {\n            // If the exponent is odd, multiply the result by the current base.\n            if (exponent % 2n === 1n) {\n                result = result.times(base);\n            }\n            // Square the base and halve the exponent.\n            base = base.times(base);\n            exponent = exponent / 2n;\n        }\n        // If exponent is negative, convert the problem to positive exponent.\n        return that.isNegative() ? FixedPointNumber.ONE.div(result) : result;\n    }\n\n    /**\n     * Computes the square root of a given positive bigint value using a fixed-point iteration method.\n     *\n     * @param {bigint} value - The positive bigint value for which the square root is to be calculated.\n     * @param {bigint} fd - The iteration factor determinant.\n     * @return {bigint} The calculated square root of the input bigint value.\n     *\n     * @throws {RangeError} If the input value is negative.\n     */\n    private static sqr(value: bigint, fd: bigint): bigint {\n        if (value < 0n) {\n            throw new RangeError(`Value must be positive`);\n        }\n        const sf = fd * FixedPointNumber.BASE; // Scale Factor.\n        let iteration = 0;\n        let actualResult = value;\n        let storedResult = 0n;\n        while (actualResult !== storedResult && iteration < sf) {\n            storedResult = actualResult;\n            actualResult =\n                (actualResult + FixedPointNumber.div(fd, value, actualResult)) /\n                2n;\n            iteration++;\n        }\n        return actualResult;\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the square root of the value of this FixedPointNumber\n     *\n     * Limit cases\n     * * NaN = NaN\n     * * +Infinite = +Infinite\n     * * -n = NaN\n     *\n     * @return {FixedPointNumber} The square root of the number.\n     *\n     * @see [bignumber.js sqrt](https://mikemcl.github.io/bignumber.js/#sqrt)\n     */\n    public sqrt(): FixedPointNumber {\n        if (this.isNaN()) return FixedPointNumber.NaN;\n        if (this.isNegativeInfinite()) return FixedPointNumber.NaN;\n        if (this.isPositiveInfinite())\n            return FixedPointNumber.POSITIVE_INFINITY;\n        try {\n            return new FixedPointNumber(\n                this.fractionalDigits,\n                FixedPointNumber.sqr(this.scaledValue, this.fractionalDigits)\n            );\n        } catch {\n            return FixedPointNumber.NaN;\n        }\n    }\n\n    /**\n     * Returns a FixedPointNumber whose value is the value of this FixedPointNumber multiplied by `that` FixedPointNumber.\n     *\n     * Limits cases\n     * * NaN * n = NaN\n     * * n * NaN = NaN\n     * * -Infinite * -n = +Infinite\n     * * -Infinite * +n = -Infinite\n     * * +Infinite * -n = -Infinite\n     * * +Infinite * +n = +Infinite\n     *\n     * @param {FixedPointNumber} that - The fixed-point number to multiply with this number.\n     * @return {FixedPointNumber} a FixedPointNumber whose value is the value of this FixedPointNumber multiplied by `that` FixedPointNumber.\n     *\n     * @remarks The precision is the greater of the precision of the two operands.\n     *\n     * @see [bignumber.js multipliedBy](https://mikemcl.github.io/bignumber.js/#times)\n     */\n    public times(that: FixedPointNumber): FixedPointNumber {\n        if (this.isNaN() || that.isNaN()) return FixedPointNumber.NaN;\n        if (this.isNegativeInfinite())\n            return that.isNegative()\n                ? FixedPointNumber.POSITIVE_INFINITY\n                : FixedPointNumber.NEGATIVE_INFINITY;\n        if (this.isPositiveInfinite())\n            return that.isNegative()\n                ? FixedPointNumber.NEGATIVE_INFINITY\n                : FixedPointNumber.POSITIVE_INFINITY;\n        const fd =\n            this.fractionalDigits > that.fractionalDigits\n                ? this.fractionalDigits\n                : that.fractionalDigits; // Max common fractional decimals.\n        return new FixedPointNumber(\n            fd,\n            FixedPointNumber.mul(\n                this.dp(fd).scaledValue,\n                that.dp(fd).scaledValue,\n                fd\n            )\n        ).dp(this.fractionalDigits); // Minimize fractional decimals without precision loss.\n    }\n\n    /**\n     * Converts the fixed-point number to its string representation.\n     *\n     * @param {string} [decimalSeparator='.'] - The character to use as the decimal separator in the string representation. Default is '.'.\n     * @return {string} A string representation of the fixed-point number.\n     */\n    public toString(decimalSeparator = '.'): string {\n        if (this.edgeFlag === 0) {\n            const sign = this.scaledValue < 0n ? '-' : '';\n            const digits =\n                this.scaledValue < 0n\n                    ? (-this.scaledValue).toString()\n                    : this.scaledValue.toString();\n            const padded = digits.padStart(Number(this.fractionalDigits), '0');\n            const decimals =\n                this.fractionalDigits > 0\n                    ? padded.slice(Number(-this.fractionalDigits))\n                    : '';\n            const integers = padded.slice(0, padded.length - decimals.length);\n            const integersShow = integers.length < 1 ? '0' : integers;\n            const decimalsShow = FixedPointNumber.trimEnd(decimals);\n            return (\n                sign +\n                integersShow +\n                (decimalsShow.length > 0 ? decimalSeparator + decimalsShow : '')\n            );\n        }\n        return this.edgeFlag.toString();\n    }\n\n    /**\n     * Trims the specified trailing substring from the end of the input string recursively.\n     *\n     * @param {string} str - The input string to be trimmed.\n     * @param {string} [sub='0'] - The substring to be removed from the end of the input string. Defaults to '0' if not provided.\n     * @return {string} The trimmed string with the specified trailing substring removed.\n     */\n    private static trimEnd(str: string, sub: string = '0'): string {\n        // Check if the input string ends with the trailing substring\n        if (str.endsWith(sub)) {\n            // Remove the trailing substring recursively.\n            return FixedPointNumber.trimEnd(\n                str.substring(0, str.length - sub.length),\n                sub\n            );\n        }\n        return str;\n    }\n\n    /**\n     * Converts a string expression of a number into a scaled value.\n     *\n     * @param {string} exp - The string expression of the number to be converted.\n     * @param {bigint} fd - The scale factor to be used for conversion.\n     * @param {string} [decimalSeparator='.'] - The character used as the decimal separator in the string expression.\n     * @return {bigint} - The converted scaled value as a bigint.\n     */\n    private static txtToSV(\n        exp: string,\n        fd: bigint,\n        decimalSeparator = '.'\n    ): bigint {\n        const fc = exp.charAt(0); // First Character.\n        let sign = 1n;\n        if (fc === '-') {\n            sign = -1n;\n            exp = exp.substring(1);\n        } else if (fc === '+') {\n            exp = exp.substring(1);\n        }\n        const sf = FixedPointNumber.BASE ** fd; // Scale Factor.\n        const di = exp.lastIndexOf(decimalSeparator); // Decimal Index.\n        if (di < 0) {\n            return sign * sf * BigInt(exp); // Signed Integer.\n        }\n        const ie = exp.substring(0, di); // Integer Expression.\n        const fe = exp.substring(di + 1); // Fractional Expression.\n        return (\n            sign * sf * BigInt(ie) + // Integer part\n            (sign * (sf * BigInt(fe))) / BigInt(10 ** fe.length) // Fractional part.\n        );\n    }\n}\n\nexport { FixedPointNumber };\n","import { Hex } from './Hex';\nimport { InvalidDataType } from '@vechain/sdk-errors';\n\n/**\n * Represents a hexadecimal signed integer value.\n *\n * @remarks This class makes equal instances created from the same value as number or as bigint.\n *\n * @extends {Hex}\n */\nclass HexInt extends Hex {\n    /**\n     * Retrieves the value of n cast from this instance interpreted as the hexadecimal expression of a bigint value.\n     *\n     * @return {number} The value of n.\n     *\n     * @throws {InvalidDataType} If n is not within the safe number range, if the number representation of this\n     * instance results approximated.\n     *\n     * @remarks This class makes equal instances created from the same value as number or as bigint.\n     */\n    public override get n(): number {\n        const bi = this.bi;\n        if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {\n            return Number(bi);\n        }\n        throw new InvalidDataType('HexInt.n', 'not in the safe number range', {\n            bi: `${bi}`,\n            hex: this.toString()\n        });\n    }\n\n    /**\n     * Create a HexInt instance from a bigint, number, string, Uint8Array, or {@link Hex}.\n     *\n     * @param {bigint | number | string | Uint8Array | Hex} exp - The expression to be interpreted as an integer:\n     * * bigint is always representable in hexadecimal base notation;\n     * * number is converted to a bigint then represented in hexadecimal base notation;\n     *   it throws {@link InvalidDataType} if not an integer value;\n     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;\n     * * Uint8Array is interpreted as the sequence of bytes expressing a bigint value;\n     * * {@link Hex} is interpreted as expressing a bigint value.\n     *\n     * @returns {HexInt} - The new HexInt object representing the given `exp`.\n     *\n     * @throws {InvalidDataType} - If the given `exp` is not a valid hexadecimal integer expression,\n     * if `exp` is a not integer number.\n     *\n     * @remarks This class makes equal instances created from the same value as number or as bigint.\n     */\n    public static of(exp: bigint | number | string | Uint8Array | Hex): HexInt {\n        try {\n            if (exp instanceof Hex) {\n                return new HexInt(exp.sign, exp.digits);\n            }\n            if (typeof exp === 'number') {\n                if (Number.isInteger(exp)) {\n                    const hex = Hex.of(BigInt(exp));\n                    return new HexInt(hex.sign, hex.digits);\n                }\n                // noinspection ExceptionCaughtLocallyJS\n                throw new InvalidDataType('HexInt.of', 'not an integer', {\n                    exp\n                });\n            }\n            const hex = Hex.of(exp);\n            return new HexInt(hex.sign, hex.digits);\n        } catch (e) {\n            throw new InvalidDataType(\n                'HexInt.of',\n                'not an hexadecimal integer expression',\n                { exp: `${exp}`, e } // Needed to serialize bigint values.\n            );\n        }\n    }\n}\n\nexport { HexInt };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { Hex } from './Hex';\nimport { HexInt } from './HexInt';\n\n/**\n * Represents a hexadecimal unsigned integer value.\n *\n * @extends HexInt\n */\nclass HexUInt extends HexInt {\n    /**\n     * Regular expression for matching hexadecimal strings.\n     * An empty input is represented as a empty digits.\n     *\n     * @type {RegExp}\n     */\n    private static readonly REGEX_HEXUINT: RegExp = /^(0x)?[0-9a-f]*$/i;\n\n    /**\n     * Regular expression pattern to match a prefix indicating hexadecimal number.\n     *\n     * @type {RegExp}\n     */\n    protected static readonly REGEX_HEXUINT_PREFIX: RegExp = /^0x/i;\n\n    /**\n     * Checks if the given string expression is a valid unsigned hexadecimal value.\n     *\n     * @param {string} exp - The string representation of a hexadecimal value.\n     *\n     * @return {boolean} - True if the expression is a valid unsigned hexadecimal value, case-insensitive,\n     * optionally prefixed with `0x`; false otherwise.\n     */\n    public static isValid(exp: string): boolean {\n        return HexUInt.REGEX_HEXUINT.test(exp);\n    }\n\n    /**\n     * Determines whether the given string is a valid unsigned hexadecimal number prefixed with '0x'.\n     *\n     * @param {string} exp - The string to be evaluated.\n     * @return {boolean} - True if the string is a valid unsigned hexadecimal number prefixed with '0x', otherwise false.\n     */\n    public static isValid0x(exp: string): boolean {\n        return HexUInt.REGEX_HEX_PREFIX.test(exp) && Hex.isValid(exp);\n    }\n\n    /**\n     * Create a HexUInt instance from a bigint, number, string, Uint8Array, or {@link HexInt}.\n     *\n     * @param {bigint | number | string | Uint8Array | HexInt} exp - The expression to be interpreted as an unsigned integer:\n     * * bigint is always representable in hexadecimal base notation,\n     *   it throws {@link InvalidDataType} if not positive;\n     * * number is converted to a bigint then represented in hexadecimal base notation,\n     *   it throws {@link InvalidDataType} if not a positive integer value;\n     * * string is parsed as the hexadecimal expression of a bigint value, optionally tagged with `0x`;\n     *   it throws {@link InvalidDataType} if not positive;\n     * * Uint8Array is interpreted as the sequence of bytes expressing a positive bigint value;\n     * * {@link HexInt} is interpreted as expressing a bigint value,\n     *   it throws {@link InvalidDataType} if not positive.\n     *\n     * @returns {HexUInt} he new HexInt object representing the given `exp`.\n     *\n     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.\n     */\n    public static of(\n        exp: bigint | number | string | Uint8Array | HexInt\n    ): HexUInt {\n        try {\n            const hint = HexInt.of(exp);\n            if (hint.sign >= Hex.POSITIVE) {\n                return new HexUInt(hint.sign, hint.digits);\n            }\n            throw new InvalidDataType(\n                'HexUInt.of',\n                'not positive',\n                { exp: `${exp}` } // Needed to serialize bigint values.\n            );\n        } catch (e) {\n            throw new InvalidDataType(\n                'HexUInt.of',\n                'not a hexadecimal positive integer expression',\n                { exp: `${exp}`, e }, // Needed to serialize bigint values.\n                e\n            );\n        }\n    }\n}\n\nexport { HexUInt };\n","import * as nh_sha256 from '@noble/hashes/sha256';\nimport { InvalidOperation } from '@vechain/sdk-errors';\nimport { Hex } from '../Hex';\nimport { HexUInt } from '../HexUInt';\n\n/**\n * Represents the result of an [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash operation.\n *\n * @extends HexUInt\n * @implements Hash\n */\nclass Sha256 extends HexUInt {\n    /**\n     * Generates the [SHA 256](https://en.wikipedia.org/wiki/SHA-2) hash of the given input.\n     *\n     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.\n     *\n     * @returns {Sha256} - The [SHA256](https://en.wikipedia.org/wiki/SHA-2) hash of the input value.\n     *\n     * @throws {InvalidOperation} - If a hash error occurs.\n     *\n     * @remarks Security auditable method, depends on\n     * * [`nh_sha256.sha256`](https://github.com/paulmillr/noble-hashes#sha2-sha256-sha384-sha512-and-others).\n     */\n    public static of(exp: bigint | number | string | Uint8Array): Sha256 {\n        try {\n            const hash = nh_sha256.sha256(HexUInt.of(exp).bytes);\n            return new Sha256(Hex.POSITIVE, HexUInt.of(hash).digits);\n        } catch (e) {\n            throw new InvalidOperation('Sha256.of', 'hash error', {\n                exp: `${exp}`, // Needed to serialize bigint values.\n                e\n            });\n        }\n    }\n}\n\nexport { Sha256 };\n","import * as nc_utils from '@noble/curves/abstract/utils';\nimport { HexUInt } from '../vcdm/HexUInt';\nimport { randomBytes as nh_randomBytes } from '@noble/hashes/utils';\nimport { secp256k1 as nc_secp256k1 } from '@noble/curves/secp256k1';\nimport {\n    InvalidSecp256k1MessageHash,\n    InvalidSecp256k1PrivateKey,\n    InvalidSecp256k1Signature\n} from '@vechain/sdk-errors';\n\n/**\n * The Secp256k1 class provides cryptographic utilities for the\n * [SECP256K1](https://en.bitcoin.it/wiki/Secp256k1)\n * [elliptic curve](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm),\n * including compressing and inflating public keys,\n * generating private keys, and validating message hashes and private keys.\n */\n\nclass Secp256k1 {\n    /**\n     * This value is used to identify compressed public key.\n     */\n    private static readonly COMPRESSED_PREFIX = 2;\n\n    /**\n     * Represents the fixed length of the cryptographic signature.\n     * The value is set to 65, which is the size in bytes\n     * required for a 520-bit signature.\n     *\n     * @constant {number} SIGNATURE_LENGTH\n     */\n    public static readonly SIGNATURE_LENGTH = 65;\n\n    /**\n     * This value is used to identify uncompressed public key.\n     */\n    private static readonly UNCOMPRESS_PREFIX = 4;\n\n    /**\n     * Defines the required length for a valid hash.\n     */\n    private static readonly VALID_HASH_LENGTH = 32;\n\n    /**\n     * Compresses an uncompressed public key.\n     *\n     * @param {Uint8Array} publicKey - The uncompressed public key to be compressed.\n     * @return {Uint8Array} - The compressed public key.\n     *\n     * @see Secp256k1.inflatePublicKey\n     */\n    public static compressPublicKey(publicKey: Uint8Array): Uint8Array {\n        const prefix = publicKey.at(0);\n        if (prefix === Secp256k1.UNCOMPRESS_PREFIX) {\n            // To compress.\n            const x = publicKey.slice(1, 33);\n            const y = publicKey.slice(33, 65);\n            const isYOdd = y[y.length - 1] & 1;\n            // Prefix with 0x02 if Y coordinate is even, 0x03 if odd.\n            return nc_utils.concatBytes(\n                Uint8Array.of(Secp256k1.COMPRESSED_PREFIX + isYOdd),\n                x\n            );\n        } else {\n            // Compressed.\n            return publicKey;\n        }\n    }\n\n    /**\n     * Derives the public key from a given private key.\n     *\n     * @param {Uint8Array} privateKey - The private key in Uint8Array format. Must be a valid 32-byte secp256k1 private key.\n     * @param {boolean} [isCompressed=true] - Indicates whether the derived public key should be in compressed format.\n     * @return {Uint8Array} The derived public key in Uint8Array format.\n     * @throws {InvalidSecp256k1PrivateKey} Throws an error if the provided private key is not valid.\n     *\n     * @remarks Security auditable method, depends on\n     * * [nc_secp256k1.getPublicKey](https://github.com/paulmillr/noble-secp256k1).\n     */\n    public static derivePublicKey(\n        privateKey: Uint8Array,\n        isCompressed: boolean = true\n    ): Uint8Array {\n        // Check if the private key is valid.\n        if (Secp256k1.isValidPrivateKey(privateKey)) {\n            return nc_secp256k1.getPublicKey(privateKey, isCompressed);\n        }\n        throw new InvalidSecp256k1PrivateKey(\n            'Secp256k1.derivePublicKey',\n            'Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.',\n            undefined\n        );\n    }\n\n    /**\n     * Generates a new Secp256k1 private key using a secure random number generator.\n     *\n     * @return {Promise<Uint8Array>} A promise that resolves to a Uint8Array representing the generated private key.\n     *                               This encoded private key is suitable for cryptographic operations.\n     * @throws {InvalidSecp256k1PrivateKey} Throws an error if private key generation fails if a secure random number\n     *                                      generator is not provided by the hosting operating system.\n     *\n     * @remarks Security auditable method, depends on\n     * * [nc_secp256k1.utils.randomPrivateKey](https://github.com/paulmillr/noble-secp256k1).\n     */\n    public static async generatePrivateKey(): Promise<Uint8Array> {\n        return await new Promise<Uint8Array>((resolve, reject) => {\n            try {\n                const privateKey = nc_secp256k1.utils.randomPrivateKey();\n                resolve(privateKey); // Resolve the promise with the generated private key\n            } catch (e) {\n                reject(\n                    new InvalidSecp256k1PrivateKey(\n                        'Secp256k1.generatePrivateKey',\n                        'Private key generation failed: ensure you have a secure random number generator available at runtime.',\n                        undefined,\n                        e\n                    )\n                );\n            }\n        });\n    }\n\n    /**\n     * Inflate a compressed public key to its uncompressed form.\n     *\n     * @param {Uint8Array} publicKey - The compressed public key to be inflated.\n     * @return {Uint8Array} - The uncompressed public key.\n     *\n     * @remarks Security auditable method, depends on\n     * * [nc_secp256k1.ProjectivePoint.fromAffine](https://github.com/paulmillr/noble-secp256k1);\n     * * [nc_secp256k1.ProjectivePoint.fromHex](https://github.com/paulmillr/noble-secp256k1);\n     * * [nc_secp256k1.ProjectivePoint.toAffine](https://github.com/paulmillr/noble-secp256k1).\n     *\n     * @see Secp256K1.compressPublicKey\n     */\n    public static inflatePublicKey(publicKey: Uint8Array): Uint8Array {\n        const prefix = publicKey.at(0);\n        if (prefix !== Secp256k1.UNCOMPRESS_PREFIX) {\n            // To inflate.\n            const x = publicKey.slice(0, 33);\n            const p = nc_secp256k1.ProjectivePoint.fromAffine(\n                nc_secp256k1.ProjectivePoint.fromHex(\n                    HexUInt.of(x).digits\n                ).toAffine()\n            );\n            return p.toRawBytes(false);\n        } else {\n            // Inflated.\n            return publicKey;\n        }\n    }\n\n    /**\n     * Checks whether the provided hash is a valid message hash.\n     *\n     * @param {Uint8Array} hash - The hash to be validated.\n     * @return {boolean} `true` if the hash is 32 bytes long, otherwise `false`.\n     */\n    public static isValidMessageHash(hash: Uint8Array): boolean {\n        return hash.length === Secp256k1.VALID_HASH_LENGTH;\n    }\n\n    /**\n     * Checks if the provided private key is valid.\n     *\n     * @param {Uint8Array} privateKey - The private key to validate.\n     * @return {boolean} `true` if the private key is valid, `false` otherwise.\n     *\n     * @remarks Security auditable method, depends on\n     * * [nc_secp256k1.utils.isValidPrivateKey](https://github.com/paulmillr/noble-secp256k1).\n     */\n    public static isValidPrivateKey(privateKey: Uint8Array): boolean {\n        return nc_secp256k1.utils.isValidPrivateKey(privateKey);\n    }\n\n    /**\n     * Generates a random sequence of bytes.\n     * If an error occurs during generation using\n     * [nc_secp256k1](https://github.com/paulmillr/noble-secp256k1),\n     * {@link {@link global.crypto} is used as fall back togenerate\n     * the random sequence.\n     *\n     * @param {number} [bytesLength=32] - Optional. The number of random bytes to generate, 32 by default.\n     * @return {Uint8Array} - A Uint8Array containing the random bytes.\n     *\n     * @remarks Security auditable method, depends on\n     * * {@link global.crypto.getRandomValues};\n     * * [nh_randomBytes](https://github.com/paulmillr/noble-hashes).\n     */\n    public static randomBytes(bytesLength: number = 32): Uint8Array {\n        try {\n            return nh_randomBytes(bytesLength);\n        } catch {\n            return global.crypto.getRandomValues(new Uint8Array(bytesLength));\n        }\n    }\n\n    /**\n     * Recovers the public key associated with the message hash from the given signature.\n     *\n     * @param {Uint8Array} messageHash - The 32-byte message hash to be verified.\n     * @param {Uint8Array} sig - The 65-byte signature used for recovery, consisting of the compact signature and recovery byte.\n     * @return {Uint8Array} The recovered public key in its raw bytes form.\n     * @throws {InvalidSecp256k1MessageHash} If the provided message hash is invalid.\n     * @throws {InvalidSecp256k1Signature} If the provided signature is not 65 bytes or contains an invalid recovery value.\n     *\n     * @remarks Security auditable method, depends on\n     * * [nc_secp256k1.Signature](https://github.com/paulmillr/noble-secp256k1).\n     *\n     * @see Secp256k1.isValidMessageHash\n     */\n    public static recover(\n        messageHash: Uint8Array,\n        sig: Uint8Array\n    ): Uint8Array {\n        // Check if the message hash is valid.\n        if (!Secp256k1.isValidMessageHash(messageHash)) {\n            throw new InvalidSecp256k1MessageHash(\n                'Secp256k1.recover',\n                'Invalid message hash given as input. Ensure it is a valid 32-byte message hash.',\n                { messageHash }\n            );\n        }\n        if (sig.length !== Secp256k1.SIGNATURE_LENGTH)\n            throw new InvalidSecp256k1Signature(\n                'Secp256k1.recover',\n                'Invalid signature given as input. Length must be exactly 65 bytes.',\n                { signature: sig }\n            );\n        const recovery = sig[64];\n        if (recovery !== 0 && recovery !== 1)\n            throw new InvalidSecp256k1Signature(\n                'Secp256k1.recover',\n                'Invalid signature recovery value. Signature bytes at position 64 must be 0 or 1.',\n                { signature: sig, recovery }\n            );\n        return nc_secp256k1.Signature.fromCompact(sig.slice(0, 64))\n            .addRecoveryBit(recovery)\n            .recoverPublicKey(messageHash)\n            .toRawBytes(false);\n    }\n\n    /**\n     * Signs a given message hash using the provided private key.\n     *\n     * @param messageHash - A 32-byte message hash that needs to be signed.\n     * @param privateKey - A 32-byte private key used for signing the message hash.\n     * @return The signature of the message hash consisting of the r, s, and recovery values.\n     * @throws InvalidSecp256k1MessageHash if the message hash is not a valid 32-byte hash.\n     * @throws InvalidSecp256k1PrivateKey if the private key is not a valid 32-byte private key.\n     *\n     * @remarks Security auditable method, depends on\n     * * [nc_secp256k1.sign](https://github.com/paulmillr/noble-secp256k1).\n     *\n     * @see Secp256k1.isValidMessageHash\n     * @see Secp256k1.isValidPrivateKey\n     */\n    public static sign(\n        messageHash: Uint8Array,\n        privateKey: Uint8Array\n    ): Uint8Array {\n        // Check if the message hash is valid.\n        if (!Secp256k1.isValidMessageHash(messageHash)) {\n            throw new InvalidSecp256k1MessageHash(\n                'Secp256k1.sign',\n                'Invalid message hash given as input. Ensure it is a valid 32-byte message hash.',\n                { messageHash }\n            );\n        }\n        // Check if the private key is valid.\n        if (!Secp256k1.isValidPrivateKey(privateKey)) {\n            throw new InvalidSecp256k1PrivateKey(\n                'Secp256k1.sign',\n                'Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.',\n                undefined\n            );\n        }\n        const sig = nc_secp256k1.sign(messageHash, privateKey);\n        return nc_utils.concatBytes(\n            nc_utils.numberToBytesBE(sig.r, 32),\n            nc_utils.numberToBytesBE(sig.s, 32),\n            nc_utils.numberToVarBytesBE(sig.recovery)\n        );\n    }\n}\n\nexport { Secp256k1 };\n","import * as s_bip32 from '@scure/bip32';\nimport * as s_bip39 from '@scure/bip39';\nimport * as nc_utils from '@noble/curves/abstract/utils';\nimport { base58 } from '@scure/base';\nimport { FixedPointNumber } from '../vcdm/FixedPointNumber';\nimport { Sha256 } from '../vcdm/hash/Sha256';\nimport { HexUInt } from '../vcdm/HexUInt';\nimport { Secp256k1 } from '../secp256k1/Secp256k1';\nimport {\n    InvalidHDKey,\n    InvalidHDKeyMnemonic,\n    InvalidSecp256k1PrivateKey\n} from '@vechain/sdk-errors';\n\n/**\n * This class extends the\n * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n * [HDKey](https://github.com/paulmillr/scure-bip32) class\n * to provide interoperability with\n * [ethers.js 6 HDNodeWallet](https://docs.ethers.org/v6/api/wallet/#HDNodeWallet).\n *\n * @extends s_bip32.HDKey\n */\nclass HDKey extends s_bip32.HDKey {\n    /**\n     * Prefix for extended private key\n     */\n    public static readonly EXTENDED_PRIVATE_KEY_PREFIX = HexUInt.of(\n        '0488ade4000000000000000000'\n    ).bytes;\n\n    /**\n     * Prefix for extended public key\n     */\n    public static readonly EXTENDED_PUBLIC_KEY_PREFIX = HexUInt.of(\n        '0488b21e000000000000000000'\n    ).bytes;\n\n    /**\n     * Default VET derivation path.\n     *\n     * See\n     * [SLIP-0044 : Registered coin types for BIP-0044](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)\n     * for more info.\n     */\n    public static readonly VET_DERIVATION_PATH = \"m/44'/818'/0'/0\";\n\n    /**\n     * Creates a\n     * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n     * from\n     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n     * and the given derivation path.\n     *\n     * @param {string[]} words - An array of words representing the mnemonic.\n     * @param {string} path - The derivation path to derive the child node.\n     * Default value is {@link VET_DERIVATION_PATH}.\n     *\n     * @return The derived child hierarchical deterministic key.\n     *\n     * @throws {InvalidHDKey} If `path` is not valid to derive a node wallet.\n     * @throws {InvalidHDKeyMnemonic} If `words` is an invalid array mnemonic.\n     *\n     * @remarks Security auditable method, depends on\n     * * [s_bip32.HDKey.derive](https://github.com/paulmillr/scure-bip32);\n     * * [s_bip32.HDKey.fromMasterSeed](https://github.com/paulmillr/scure-bip32);\n     * * [s_bip39.mnemonicToSeedSync](https://github.com/paulmillr/scure-bip39).\n     */\n    public static fromMnemonic(\n        words: string[],\n        path: string = this.VET_DERIVATION_PATH\n    ): HDKey {\n        let master: s_bip32.HDKey;\n        try {\n            master = s_bip32.HDKey.fromMasterSeed(\n                s_bip39.mnemonicToSeedSync(words.join(' ').toLowerCase())\n            );\n        } catch (error) {\n            // The error masks any mnemonic words leak.\n            throw new InvalidHDKeyMnemonic(\n                'HDNode.fromMnemonic',\n                'Invalid mnemonic words given as input.',\n                undefined,\n                error\n            );\n        }\n        try {\n            return master.derive(path) as HDKey;\n        } catch (error) {\n            throw new InvalidHDKey(\n                'HDNode.fromMnemonic',\n                'Invalid derivation path given as input.',\n                { derivationPath: path },\n                error\n            );\n        }\n    }\n\n    /**\n     * Creates a\n     * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n     * from a private key and chain code.\n     *\n     * @param {Uint8Array} - privateKey The private key.\n     * @param {Uint8Array} - chainCode The chain code.\n     *\n     * @returns Returns the hierarchical deterministic key from `privateKey` and `chainCode`.\n     *\n     * @throws {InvalidSecp256k1PrivateKey} If the `privateKey` is invalid.\n     *\n     * @remarks **This method wipes `privateKey`** for security reasons.\n     * @remarks Security auditable method, depends on\n     * * [base58.encode](https://github.com/paulmillr/scure-base);\n     * * {@link Sha256};\n     * * [s_bip32.HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).\n     */\n    public static fromPrivateKey(\n        privateKey: Uint8Array,\n        chainCode: Uint8Array\n    ): HDKey {\n        if (privateKey.length === 32) {\n            const header = nc_utils.concatBytes(\n                this.EXTENDED_PRIVATE_KEY_PREFIX,\n                chainCode,\n                Uint8Array.of(0),\n                privateKey\n            );\n            privateKey.fill(0); // Clear the private key from memory.\n            const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(\n                0,\n                4\n            );\n            const expandedPrivateKey = nc_utils.concatBytes(header, checksum);\n            try {\n                return s_bip32.HDKey.fromExtendedKey(\n                    base58.encode(expandedPrivateKey)\n                ) as HDKey;\n            } catch {\n                throw new InvalidSecp256k1PrivateKey(\n                    'HDNode.fromPrivateKey',\n                    'Invalid private key path given as input.',\n                    undefined\n                );\n            }\n        }\n\n        // We reach this case if privateKey length is not exactly 32 bytes.\n        privateKey.fill(0); // Clear the private key from memory, albeit it is invalid.\n        throw new InvalidSecp256k1PrivateKey(\n            'HDNode.fromPrivateKey()',\n            'Invalid private key path given as input. Length must be exactly 32 bytes.',\n            undefined\n        );\n    }\n\n    /**\n     * Creates a\n     * [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)\n     * key from a public key and chain code.\n     *\n     * @param {Uint8Array} publicKey - The public key bytes.\n     * @param {Uint8Array} chainCode - The chain code bytes.\n     *\n     * @returns {HDKey} Returns the hierarchical deterministic key from `public` and `chainCode`.\n     *\n     * @throws {InvalidHDKey} if the `publicKey` is invalid.\n     *\n     * @remarks Security auditable method, depends on\n     * * [base58.encode](https://github.com/paulmillr/scure-base);\n     * * {@link Secp256k1.compressPublicKey};\n     * * {@link Sha256};\n     * * [HDKey.fromExtendedKey](https://github.com/paulmillr/scure-bip32).\n     */\n    public static fromPublicKey(\n        publicKey: Uint8Array,\n        chainCode: Uint8Array\n    ): HDKey {\n        if (chainCode.length === 32) {\n            const header = nc_utils.concatBytes(\n                this.EXTENDED_PUBLIC_KEY_PREFIX,\n                chainCode,\n                Secp256k1.compressPublicKey(publicKey)\n            );\n            const checksum = Sha256.of(Sha256.of(header).bytes).bytes.subarray(\n                0,\n                4\n            );\n            const expandedPublicKey = nc_utils.concatBytes(header, checksum);\n            try {\n                return s_bip32.HDKey.fromExtendedKey(\n                    base58.encode(expandedPublicKey)\n                ) as HDKey;\n            } catch (error) {\n                throw new InvalidHDKey(\n                    'HDNode.fromPublicKey()',\n                    'Invalid public key path given as input.',\n                    { publicKey },\n                    error\n                );\n            }\n        }\n\n        // We reach this case if chainCode length is not exactly 32 bytes.\n        throw new InvalidHDKey(\n            'HDNode.fromPublicKey()',\n            'Invalid chain code given as input. Length must be exactly 32 bytes.',\n            { chainCode }\n        );\n    }\n\n    /**\n     * Checks if derivation path single component is valid\n     *\n     * @param component - Derivation path single component to check\n     * @param index - Derivation path single component index\n     *\n     * @returns `true`` if derivation path single component is valid, otherwise `false`.\n     *\n     */\n    private static isDerivationPathComponentValid(\n        component: string,\n        index: number\n    ): boolean {\n        // Zero component can be \"m\" or \"number\" or \"number'\", other components can be only \"number\" or \"number'\"\n        return (\n            // m\n            (index === 0 ? component === 'm' : false) ||\n            // \"number\"\n            FixedPointNumber.isNaturalExpression(component) ||\n            // \"number'\"\n            (FixedPointNumber.isNaturalExpression(component.slice(0, -1)) &&\n                component.endsWith(\"'\"))\n        );\n    }\n\n    /**\n     * Checks if BIP32 derivation path is valid.\n     *\n     * @param derivationPath - Derivation path to check.\n     *\n     * @returns `true` if derivation path is valid, otherwise `false`.\n     */\n    public static isDerivationPathValid(derivationPath: string): boolean {\n        const bip32Regex = /^m(\\/\\d+'?){3}(\\/\\d+){1,2}$/;\n        return bip32Regex.test(derivationPath);\n    }\n}\n\nexport { HDKey };\n","import { keccak_256 as nh_keccak_256 } from '@noble/hashes/sha3';\nimport { InvalidOperation } from '@vechain/sdk-errors';\nimport { Hex } from '../Hex';\nimport { HexUInt } from '../HexUInt';\n\n/**\n * Represents the result of an [KECCAK 256](https://keccak.team/keccak.html) hash operation.\n *\n * @extends HexUInt\n */\nclass Keccak256 extends HexUInt {\n    /**\n     * Generates the [KECCAK 256](https://keccak.team/keccak.html) hash of the given input.\n     *\n     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.\n     *\n     * @returns {Sha256} - The [KECCAK 256](https://keccak.team/keccak.html) hash of the input value.\n     *\n     * @throws {InvalidOperation} - If a hash error occurs.\n     *\n     * @remarks Security auditable method, depends on\n     * * [`nh_keccak_256`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).\n     */\n    public static of(\n        exp: bigint | number | string | Uint8Array | Hex\n    ): Keccak256 {\n        try {\n            const hash = nh_keccak_256(HexUInt.of(exp).bytes);\n            return new Keccak256(Hex.POSITIVE, HexUInt.of(hash).digits);\n        } catch (e) {\n            throw new InvalidOperation('Keccak256.of', 'hash error', {\n                exp: `${exp}`, // Needed to serialize bigint values.\n                e\n            });\n        }\n    }\n}\n\nexport { Keccak256 };\n","import { HDKey } from '../hdkey/HDKey';\nimport { Hex } from './Hex';\nimport { HexUInt } from './HexUInt';\nimport { InvalidDataType, InvalidHDKey } from '@vechain/sdk-errors';\nimport { Keccak256 } from './hash/Keccak256';\nimport { Secp256k1 } from '../secp256k1/Secp256k1';\nimport { Txt } from './Txt';\n\n/**\n * Represents a VeChain Address as unsigned integer.\n *\n * @extends {HexUInt}\n */\nclass Address extends HexUInt {\n    /**\n     * The address is 20 bytes hence 40 digits long.\n     */\n    public static readonly DIGITS: number = 40;\n\n    /**\n     * It checksums a given hexadecimal address.\n     *\n     * @param {HexUInt} huint - The HexUInt object representing the hexadecimal value.\n     *\n     * @returns {string} The checksummed address.\n     */\n    public static checksum(huint: HexUInt): string {\n        const stringAddress: string = huint.digits;\n        const hash: string = Keccak256.of(Txt.of(stringAddress).bytes).digits;\n\n        let checksum = '';\n        for (let i = 0; i < stringAddress.length; i++) {\n            checksum +=\n                parseInt(hash[i], 16) > 7\n                    ? stringAddress[i].toUpperCase()\n                    : stringAddress[i];\n        }\n\n        return '0x' + checksum;\n    }\n\n    /**\n     * Validate the given expression to be a valid address.\n     *\n     *  @param {string} exp - Expression to validate\n     *\n     * @returns {boolean} true if the expression is a valid address, false otherwise\n     */\n    public static isValid(exp: string): boolean {\n        return Hex.isValid0x(exp) && exp.length === Address.DIGITS + 2;\n    }\n\n    /**\n     * Create an Address instance from the given expression interpreted as an unsigned integer.\n     *\n     * @param exp - The expression to convert.\n     * It can be of type bigint, number, string, Uint8Array, or HexUInt.\n     * Not meaningful `0` digits on the left of the expression can be omitted,\n     * the returned address is always 20 bytes, 40 digits expression.\n     *\n     * @returns {Address} The converted hexadecimal unsigned integer.\n     *\n     * @throws {InvalidDataType} If the expression is not a valid hexadecimal positive integer expression.\n     */\n    public static of(\n        exp: bigint | number | string | Uint8Array | HexUInt\n    ): Address {\n        try {\n            const huint = HexUInt.of(exp);\n            const pad = HexUInt.of(huint.digits.padStart(40, '0'));\n            const addressChecksummed: string = Address.checksum(pad);\n            return new Address(\n                Hex.POSITIVE,\n                '0x0', // When we normalize we return the checksummed address as digits\n                () => addressChecksummed.substring(2)\n            );\n        } catch (error) {\n            throw new InvalidDataType(\n                'Address.of',\n                'not a valid hexadecimal positive integer expression',\n                { exp: `${exp}` },\n                error\n            );\n        }\n    }\n\n    /**\n     * Generates an Address object from the given private key.\n     *\n     * @param {Uint8Array} privateKey - The private key used to derive the corresponding address.\n     * @return {Address} The derived Address object.\n     * @throws {InvalidDataType} If the provided private key is invalid or cannot derive an address.\n     */\n    public static ofPrivateKey(privateKey: Uint8Array): Address {\n        try {\n            return Address.ofPublicKey(\n                Secp256k1.derivePublicKey(privateKey, true)\n            );\n        } catch (error) {\n            throw new InvalidDataType(\n                'Address.ofPrivateKey',\n                'not a valid private key',\n                { privateKey: 'private key is obfuscated' },\n                error\n            );\n        }\n    }\n\n    /**\n     * Create an Address instance from the given public key.\n     *\n     * @param {Uint8Array} publicKey - The public key to convert.\n     *\n     * @returns {Address} The converted address.\n     *\n     * @remarks Security auditable method, depends on\n     * * {@link Secp256k1.inflatePublicKey}.\n     */\n    public static ofPublicKey(publicKey: Uint8Array): Address {\n        try {\n            const publicKeyInflated = Secp256k1.inflatePublicKey(publicKey);\n            const publicKeyHash = Keccak256.of(\n                publicKeyInflated.slice(1)\n            ).bytes;\n            return Address.of(publicKeyHash.slice(12));\n        } catch (error) {\n            throw new InvalidDataType(\n                'Address.ofPublicKey',\n                'not a valid public key',\n                { publicKey: `${publicKey}` },\n                error\n            );\n        }\n    }\n\n    /**\n     * Derives the address from a given list of words of\n     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n     * and a [BIP44 Derivation Path](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)\n     * as in the examples.\n     *\n     * Secure audit function.\n     * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)\n     * - {@link HDKey}\n     *\n     * @example `m/0` (default)\n     * @example `m/0/2`\n     * @example `m/0/2/4/6`\n     *\n     * @param {string[]} mnemonic - Mnemonic used to generate the HD node.\n     * @param {string} [path='m/0'] - The derivation path from the current node.\n     * @return {Address} - The derived address.\n     * @throws {InvalidHDKey}\n     *\n     */\n    public static ofMnemonic(\n        mnemonic: string[],\n        path: string = 'm/0'\n    ): Address {\n        const root = HDKey.fromMnemonic(mnemonic);\n        try {\n            // Public key is always available.\n            return Address.ofPublicKey(\n                root.derive(path).publicKey as Uint8Array\n            );\n        } catch (error) {\n            throw new InvalidHDKey(\n                'mnemonic.deriveAddress()',\n                'Invalid derivation path given as input.',\n                { derivationPath: path },\n                error\n            );\n        }\n    }\n}\n\nexport { Address };\n","import { Hex } from './Hex';\nimport { HexUInt } from './HexUInt';\nimport { InvalidDataType } from '@vechain/sdk-errors';\n\n/**\n * The BlockRef class represents a Thor block ID value, which is a hexadecimal positive integer having 64 digits.\n *\n * @extends HexInt\n */\nclass BlockRef extends HexUInt {\n    /**\n     * Number of digits to represent a block reference value.\n     *\n     * @remarks The `0x` prefix is excluded.\n     *\n     * @type {number}\n     */\n    private static readonly DIGITS = 16;\n\n    /**\n     * Constructs a BlockRef object with the provided hexadecimal value.\n     *\n     * @param {HexUInt} huint - The hexadecimal value representing the BlockId.\n     */\n    protected constructor(huint: HexUInt) {\n        super(Hex.POSITIVE, huint.fit(BlockRef.DIGITS).digits);\n    }\n\n    /**\n     * Check if the given expression is a valid BlockRef.\n     *\n     * @param {string} exp - The expression to be validated.\n     *\n     * @return {boolean} Returns true if the expression is a valid BlockRef, false otherwise.\n     */\n    public static isValid(exp: string): boolean {\n        return Hex.isValid(exp) && HexUInt.REGEX_HEXUINT_PREFIX.test(exp)\n            ? exp.length === BlockRef.DIGITS + 2\n            : exp.length === BlockRef.DIGITS;\n    }\n\n    /**\n     * Determines whether the given string is a valid hex number prefixed with '0x'.\n     *\n     * @param {string} exp - The hex number to be checked.\n     *\n     *  @returns {boolean} - True if the hex number is valid, false otherwise.\n     */\n    public static isValid0x(exp: string): boolean {\n        return HexUInt.REGEX_HEXUINT_PREFIX.test(exp) && BlockRef.isValid(exp);\n    }\n\n    /**\n     * Creates a new BlockRef object from the given expression.\n     *\n     * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the BlockRef from.\n     *     It can be one of the following types:\n     *     - bigint: A BigInteger value that represents the BlockRef.\n     *     - number: A number value that represents the BlockRef.\n     *     - string: A string value that represents the BlockRef.\n     *     - HexUInt: A HexUInt object that represents the BlockRef.\n     *     - Uint8Array: A Uint8Array object that represents the BlockRef.\n     *\n     * @returns {BlockRef} - A new BlockRef object created from the given expression.\n     *\n     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.\n     */\n    public static of(\n        exp: bigint | number | string | Uint8Array | HexUInt\n    ): BlockRef {\n        try {\n            if (exp instanceof HexUInt) {\n                return new BlockRef(exp);\n            }\n            return new BlockRef(HexUInt.of(exp));\n        } catch (e) {\n            throw new InvalidDataType(\n                'BlockRef.of',\n                'not a BlockRef expression',\n                { exp: `${exp}` }, // Needed to serialize bigint values.\n                e\n            );\n        }\n    }\n}\n\nexport { BlockRef };\n","import { blake2b as nh_blake2b } from '@noble/hashes/blake2b';\nimport { InvalidOperation } from '@vechain/sdk-errors';\nimport { Hex } from '../Hex';\nimport { HexUInt } from '../HexUInt';\n\n/**\n * Represents the result of an [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BlAKE2B 256](https://www.blake2.net/) hash operation.\n *\n * @extends HexUInt\n */\nclass Blake2b256 extends HexUInt {\n    /**\n     * Generates the [BLAKE](https://en.wikipedia.org/wiki/BLAKE_(hash_function)) [BLAKE2B 256](https://www.blake2.net/) hash of the given input.\n     *\n     * @param {bigint | number | string | Uint8Array | Hex} exp - The input value to hash.\n     *\n     * @returns {Sha256} - The [BLAKE2B 256](https://www.blake2.net/) hash of the input value.\n     *\n     * @throws {InvalidOperation} - If a hash error occurs.\n     *\n     * @remarks Security auditable method, depends on\n     * * [`nh_blake2b.create(...).update(...).digest(...)`](https://github.com/paulmillr/noble-hashes#sha3-fips-shake-keccak).\n     */\n    public static of(\n        exp: bigint | number | string | Uint8Array | Hex\n    ): Blake2b256 {\n        try {\n            const hash = nh_blake2b\n                .create({ dkLen: 32 })\n                .update(HexUInt.of(exp).bytes)\n                .digest();\n            return new Blake2b256(Hex.POSITIVE, HexUInt.of(hash).digits);\n        } catch (e) {\n            throw new InvalidOperation('Blake2b256.of', 'hash error', {\n                exp: `${exp}`, // Needed to serialize bigint values.\n                e\n            });\n        }\n    }\n}\n\nexport { Blake2b256 };\n","import * as nc_utils from '@noble/curves/abstract/utils';\nimport { Blake2b256 } from './hash/Blake2b256';\nimport { Hex } from './Hex';\nimport { InvalidDataType, InvalidOperation } from '@vechain/sdk-errors';\nimport { type VeChainDataModel } from './VeChainDataModel';\n\n/**\n * A [Bloom Filter](https://en.wikipedia.org/wiki/Bloom_filter)\n * is a space-efficient probabilistic data structure\n * that is used to test whether an element is a member of a set.\n *\n * @remarks False positive matches are possible, but false negatives are not.\n *\n * @implements {VeChainDataModel<Hex>}\n */\nclass BloomFilter implements VeChainDataModel<BloomFilter> {\n    /**\n     * Return the Bloom filter structure: an array of `m` bits per key encoding if a key is not part of the structure.\n     *\n     * @typedef {Uint8Array} bytes\n     */\n    public readonly bytes: Uint8Array;\n\n    /**\n     * Return the number of hash functions used to compute this Bloom filter.\n     *\n     * @type {number}\n     */\n    public readonly k: number;\n\n    /**\n     * Creates a new instance of this class.\n     *\n     * @param {Uint8Array} bytes - The Bloom filter structure of `m` bits per key encoding if the key\n     *                             likely belongs to the structure or surely doesn't.\n     * @param {number} k - The number of hash functions used to compute this Bloom filter.\n     *\n     */\n    constructor(bytes: Uint8Array, k: number) {\n        this.bytes = bytes;\n        this.k = k;\n    }\n\n    /**\n     * Return the Bloom filter data structure represented as a {@link bigint} value.\n     *\n     * @returns {bigint} - The Bloom filter data structure represented as a {@link bigint} value.\n     */\n    get bi(): bigint {\n        return nc_utils.bytesToNumberBE(this.bytes);\n    }\n\n    /**\n     * Return the Bloom filter data structure represented as a {@link number} value.\n     *\n     * @returns {bigint} - The Bloom filter data structure represented as a {@link number} value.\n     *\n     * @throws InvalidDataType if the data structure of the bloom filter can't be represented as a number\n     * because underflow or overflow number safe integer range according\n     * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format).\n     *\n     * @remarks Preferably use {@link bi} because the Bloom filter data structure can always be represented as a {@link bigint} value.\n     */\n    get n(): number {\n        const bi = this.bi;\n        if (Number.MIN_SAFE_INTEGER <= bi && bi <= Number.MAX_SAFE_INTEGER) {\n            return Number(bi);\n        }\n        throw new InvalidDataType(\n            'BloomFilter.n',\n            'not in the safe number range',\n            {\n                bytes: this.bytes,\n                k: this.k\n            }\n        );\n    }\n\n    /**\n     * Compare the current BloomFilter instance with another BloomFilter instance according their\n     * * {@link bytes} data structure first,\n     * * {@link k} if the data structures are equal.\n     *\n     * @param {BloomFilter} that - The BloomFilter instance to compare with.\n     *\n     * @return {number} - Returns a negative number if the current instance is less than the provided instance,\n     *                   returns zero if they are equal, and returns a positive number if the current instance is greater than the provided instance.\n     */\n    compareTo(that: BloomFilter): number {\n        if (this.bi < that.bi) {\n            return -1;\n        } else if (this.bi > that.bi) {\n            return 1;\n        } else {\n            return this.k - that.k;\n        }\n    }\n\n    /**\n     * Checks if the current BloomFilter instance is equal to another BloomFilter instance.\n     *\n     * @param {BloomFilter} that - The other BloomFilter instance to compare with.\n     *\n     * @return {boolean} - Returns true if the current BloomFilter instance is equal to the other BloomFilter instance, otherwise returns false.\n     */\n    isEqual(that: BloomFilter): boolean {\n        return this.bi === that.bi && this.k === that.k;\n    }\n\n    /**\n     * Checks if the specified key may be contained within this Bloom filter or surely isn't.\n     *\n     * @param {Hex|Uint8Array} key - The key to check. It can be either a Hex object or a Uint8Array.\n     *\n     * @return {boolean} Returns true if this Bloom filter may contain the key, otherwise returns false.\n     *\n     * @remarks False positive matches are possible, but false negatives are not.\n     * @remarks Security auditable method, depends on\n     * * {@link hash}.\n     */\n    public contains(key: Hex | Uint8Array): boolean {\n        return distribute(\n            hash(key instanceof Hex ? key.bytes : key),\n            this.k,\n            this.bytes.byteLength * 8,\n            (index, bit) => {\n                return (this.bytes[index] & bit) === bit;\n            }\n        );\n    }\n\n    /**\n     * Calculates the optimal number of bits per key (`m` in math literature) based\n     * on the number of hash functions (`k` in math literature) used to generate the Bloom Filter.\n     *\n     * Mathematically, `m` is approximated as `(k / ln(2))` which is simplified\n     * to the higher integer close to `(m / 0.69)` for computational efficiency.\n     * It also ensures that `k` is within a practical range [1, 30], hence the function\n     * - returns `2` for `k = 1`,\n     * - returns `44` for `k >= 30`.\n     *\n     * @param {number} k - The number of keys.\n     *\n     * @return {number} - The number of bits per key.\n     */\n    public static computeBestBitsPerKey(k: number): number {\n        if (k <= 1) return 2;\n        return k >= 30 ? 44 : Math.ceil(k / 0.69);\n    }\n\n    /**\n     * Calculates the optimal number of hash functions (`k` in math literature)\n     * based on bits per key (`m` in math literature).\n     *\n     * Mathematically, `k` is approximated as `(m * ln(2))` which is simplified\n     * to the lower integer close to `(m * 0.69)` for computational efficiency.\n     * It also ensures that `k` stays within a practical range [1, 30].\n     *\n     * @param m - The number of bits per key.\n     *\n     * @returns The calculated optimal `k` value.\n     */\n    public static computeBestHashFunctionsQuantity(m: number): number {\n        const k = Math.floor(m * 0.69); // m * ln(2),  0.69 =~ ln(2)\n        if (k < 1) return 1;\n        return k > 30 ? 30 : k;\n    }\n\n    /**\n     * Checks if the current BloomFilter instance is possible to join with another BloomFilter instance.\n     *\n     * @param {BloomFilter} other - The BloomFilter instance to check if it is possible to join with the current instance.\n     *\n     * @return {boolean} - Returns true if the BloomFilter instances have the same 'k' value and 'bytes' length, false otherwise.\n     */\n    public isJoinable(other: BloomFilter): boolean {\n        return this.k === other.k && this.bytes.length === other.bytes.length;\n    }\n\n    /**\n     * Joins the current BloomFilter with another BloomFilter by performing a bitwise OR operation on the\n     * data structures of the filters.\n     * Both filters must have been generated with the same number of hash functions, and they must have the same length.\n     *\n     * @param other - The BloomFilter to join with.\n     *\n     * @returns A new BloomFilter that represents the result of the join operation.\n     *          They keys made this and `other` filter may belong to the returned filter.\n     *          Any key not part of the joined filter surely doesn't belong to the returned filter.\n     *\n     * @throws {InvalidOperation} If the k values of the BloomFilters are different.\n     * @throws {InvalidOperation} If the length of the byte arrays are different.\n     */\n    public join(other: BloomFilter): BloomFilter {\n        if (this.k !== other.k) {\n            throw new InvalidOperation(\n                'BloomFilter.join',\n                'different k values',\n                {\n                    this: this,\n                    other\n                }\n            );\n        }\n\n        if (this.bytes.length !== other.bytes.length) {\n            throw new InvalidOperation(\n                'BloomFilter.join',\n                'different length values',\n                {\n                    this: this,\n                    other\n                }\n            );\n        }\n\n        const joinedBytes = new Uint8Array(this.bytes.length);\n        for (let index = 0; index < this.bytes.length; index++) {\n            joinedBytes[index] = this.bytes[index] | other.bytes[index];\n        }\n\n        return new BloomFilter(joinedBytes, this.k);\n    }\n\n    /**\n     * Creates a new instance of BloomFilterBuilder and adds the specified keys to it.\n     * * Call {@link BloomFilterBuilder.add} to add more keys.\n     * * Call {@link BloomFilterBuilder.build} to create a new Bloom filter once\n     *\n     * @param {...(Hex[] | Uint8Array[])} keys - The keys to be added to the BloomFilterBuilder.\n     *\n     * @returns {BloomFilterBuilder} - A new instance of BloomFilterBuilder with the specified keys added.\n     *\n     * @remarks Security auditable method, depends on\n     * * {@link BloomFilterBuilder.add}.\n     */\n    public static of(...keys: Hex[] | Uint8Array[]): BloomFilterBuilder {\n        const builder = new BloomFilterBuilder();\n        builder.add(...keys);\n        return builder;\n    }\n} // ~ BloomFilter\n\n/**\n * The `BloomFilterBuilder` class provides methods for constructing a Bloom filter,\n * This builder class allows you to add keys to the filter and specify its `m` (bits per key) and `k` (hash functions)\n * parameters before building it.\n *\n * @see {BloomFilter.of}\n *\n */\nclass BloomFilterBuilder {\n    /**\n     * The default value number of hash functions used to create {@link BloomFilter} instances.\n     */\n    private static readonly DEFAULT_K = 5;\n\n    /**\n     * Map each element of the keys as likely part of the data structure of the Bloom filter to build.\n     * Each key is mapped in `m` bits using `k` hash functions.\n     *\n     * @see {hash}\n     */\n    private readonly hashMap = new Map<number, boolean>();\n\n    /**\n     * Adds one or more keys to the Bloom filter to create.\n     *\n     * @param {Hex[] | Uint8Array[]} keys - The keys to be added to Bloom filter to create.\n     *\n     * @return {this} - Returns this {@link BloomFilterBuilder} instance, the {@link this.hashMap} is updated to\n     * map the keys presence in the filter data structure.\n     *\n     * @remarks Security auditable method, depends on\n     * * {@link hash}.\n     */\n    public add(...keys: Hex[] | Uint8Array[]): this {\n        for (const key of keys) {\n            this.hashMap.set(hash(key instanceof Hex ? key.bytes : key), true);\n        }\n        return this;\n    }\n\n    /**\n     * Builds a Bloom filter with the specified parameters and returns it.\n     *\n     * @param k - The number of hash functions to use in the Bloom filter.  to BloomFilterBuilder.DEFAULT_K.\n     * @param m - The number of bits per key in the Bloom filter. Defaults to the value computed by BloomFilter.computeBestBitsPerKey(k).\n     *\n     * @return The built Bloom filter.\n     */\n    public build(\n        k: number = BloomFilterBuilder.DEFAULT_K,\n        m: number = BloomFilter.computeBestBitsPerKey(k)\n    ): BloomFilter {\n        // Compute bloom filter size in bytes\n        let nBytes = Math.floor((this.hashMap.size * m + 7) / 8);\n        // Enforce a minimum bloom filter length to reduce very high false positive rate for small n\n        nBytes = nBytes < 8 ? 8 : nBytes;\n        const bits = new Uint8Array(nBytes);\n        // Filter bit length\n        const nBits = nBytes * 8;\n        for (const hash of this.hashMap.keys()) {\n            distribute(hash, k, nBits, (index, bit) => {\n                bits[index] |= bit;\n                return true;\n            });\n        }\n        return new BloomFilter(bits, k);\n    }\n} // ~ BloomFilterBuilder\n\n/**\n * Upper limit of an unsigned 32 bits value pre-computed for sake of efficiencyto be used\n * in the {@link addAndWrapAsUInt32} function.\n */\nconst UINT32_LIMIT = 2 ** 32;\n\n/**\n * Adds two numbers and wraps the result as a 32-bit unsigned integer.\n *\n * @param {number} a - The first number to add.\n * @param {number} b - The second number to add.\n *\n * @return {number} The sum of `a` and `b`, wrapped as a 32-bit unsigned integer.\n *\n * @remarks  JavaScript represents numbers using the\n * [IEEE 754 double precision 64 bits floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)\n * which does not automatically handle wrapping of integers.\n * This function ensures that the addition of two numbers returns a result that is wrapped to a 32-bit unsigned integer,\n * emulating the behavior of integer addition in languages with fixed-width integers.\n */\nfunction addAndWrapAsUInt32(a: number, b: number): number {\n    return (a + b) % UINT32_LIMIT;\n}\n\n/**\n * Distributes a given hash value across a set of bits.\n *\n * @param {number} hash - The hash value to distribute.\n * @param {number} k - The number of times to distribute the hash value.\n * @param {number} m - The total number of bits to distribute the hash value across.\n * @param {function} collision - The callback function to be called for each distributed bit.\n * It takes two arguments: index (the index of the byte containing the distributed bit)\n * and bit (the distributed bit itself).\n *\n * @returns {boolean} Returns true if all bits were successfully distributed, false otherwise.\n */\nfunction distribute(\n    hash: number,\n    k: number,\n    m: number,\n    collision: (index: number, bit: number) => boolean\n): boolean {\n    const delta = ((hash >>> 17) | (hash << 15)) >>> 0;\n    for (let i = 0; i < k; i++) {\n        const bitPos = hash % m;\n        if (!collision(Math.floor(bitPos / 8), 1 << bitPos % 8)) {\n            return false;\n        }\n        hash = addAndWrapAsUInt32(hash, delta);\n    }\n    return true;\n}\n\n/**\n * Computes the hash of the given key using the {@link Blake2b256} algorithm.\n *\n * @param {Uint8Array} key - The key to be hashed.\n *\n * @return {number} The computed hash value as a number.\n *\n * @remarks Security auditable method, depends on\n * * {@link Blake2b256.of}.\n */\nfunction hash(key: Uint8Array): number {\n    return Number(\n        nc_utils.bytesToNumberBE(Blake2b256.of(key).bytes.slice(0, 4))\n    );\n}\n\nexport { BloomFilter };\n","import { type Currency } from './Currency';\nimport { type FixedPointNumber } from '../FixedPointNumber';\nimport { Txt } from '../Txt';\nimport { InvalidDataType } from '@vechain/sdk-errors';\n\n/**\n * Abstract class representing a coin, implementing the Currency interface.\n */\nabstract class Coin implements Currency {\n    /**\n     * Represent coin {@link code} denomination.\n     */\n    private readonly _code: Txt;\n\n    /**\n     * Represent the coin {@link value}.\n     *\n     * @type {FixedPointNumber}\n     */\n    private readonly _value: FixedPointNumber;\n\n    /**\n     * Creates an instance of the class with the specified code and value.\n     *\n     * @param {Txt} code - The code associated with this instance.\n     * @param {FixedPointNumber} value - The value associated with this instance.\n     */\n    protected constructor(code: Txt, value: FixedPointNumber) {\n        this._code = code;\n        this._value = value;\n    }\n\n    /**\n     * Return the code as a Txt object.\n     *\n     * @return {Txt} The code object\n     *\n     * @remarks Since currency codes likely use Unicode composite symbols,\n     * {@link Txt} type enforce the representation of the code is normalized.\n     */\n    get code(): Txt {\n        return this._code;\n    }\n\n    /**\n     * Return the current value as an FixedPointNumber (Fixed-Point Number).\n     *\n     * @return {FixedPointNumber} The current value in Fixed-Point Number format.\n     */\n    get value(): FixedPointNumber {\n        return this._value;\n    }\n\n    /**\n     * Returns the integer part of the FixedPointNumber {@link value}.\n     *\n     * @return {bigint} the integer part of this FixedPointNumber {@link value}.\n     *\n     * @throws {InvalidOperation} If the {@link value} is not finite.\n     *\n     * @remarks Do not use for financial math: apply {@link FixedPointNumber} methods instead.\n     */\n    get bi(): bigint {\n        return this._value.bi;\n    }\n\n    /**\n     * Returns the array of bytes representing the *Normalization Form Canonical Composition*\n     * [Unicode Equivalence](https://en.wikipedia.org/wiki/Unicode_equivalence)\n     * of the textual expression '{@link value} {@link code}'.\n     */\n    get bytes(): Uint8Array {\n        return Txt.of(this.toString()).bytes;\n    }\n\n    /**\n     * Return this {@linl value} approximated as {@link number}.\n     *\n     * @remarks Do not use for financial math: apply {@link FixedPointNumber} methods instead.\n     */\n    get n(): number {\n        return this._value.n;\n    }\n\n    /**\n     * Compares this Currency object with another Currency object for order.\n     *\n     * @param {Currency} that - The Currency object to be compared.\n     * @return {number} A negative integer, zero, or a positive integer as this Currency\n     *     is less than, equal to, or greater than the specified Currency.\n     * @throws {InvalidDataType} If the currency codes do not match.\n     */\n    compareTo(that: Currency): number {\n        if (this.code.isEqual(that.code)) {\n            return this.value.compareTo(that.value);\n        }\n        throw new InvalidDataType('Coin.compareTo', 'not VET currency', {\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n            that: `${that}` // Needed to serialize bigint value.\n        });\n    }\n\n    /**\n     * Determines if this Currency object is equal to another Currency object.\n     *\n     * @param {Currency} that - The Currency object to compare with the current instance.\n     * @return {boolean} - `true` if the objects are considered equal, otherwise `false`.\n     */\n    isEqual(that: Currency): boolean {\n        try {\n            return this.compareTo(that) === 0;\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Returns the textual representation of this currency as\n     * '{@link value} {@link code}'.\n     *\n     * @return A string that contains the value and code properties of the object.\n     */\n    public toString(): string {\n        return `${this.value.toString()} ${this._code}`;\n    }\n}\n\nexport { Coin };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { FixedPointNumber } from '../FixedPointNumber';\n\n/**\n * Enumeration representing units (i.e. order of magnitude)\n * of cryptocurrency (e.g., ETH or VET).\n * Each unit is defined by its name and its corresponding decimal place shift.\n * The decimal place shift if the exponent of the power of 10 to multiply\n * a value expressed in the name unit to result in the equivalent value\n * expressed in `wei` unit.\n *\n * @remarks The unit `ether` refers to an order of magnitude, not to the\n * `ETH` cryptocurrency, albeit 1 ETH = 10E18 wei in\n * [scientific notation](https://en.wikipedia.org/wiki/Scientific_notation).\n *\n * @enum {number}\n */\nenum Units {\n    /**\n     * 1 ether = 1,000,000,000,000,000,000 wei. 0 fractional digits FixedPointNumber.\n     */\n    wei = 0,\n\n    /**\n     * 1 ether = 1,000,000,000,000,000 kwei. 3 fractional digits FixedPointNumber.\n     */\n    kwei = 3,\n\n    /**\n     * 1 ether = 1,000,000,000,000 mwei. 6 fractional digits FixedPointNumber.\n     */\n    mwei = 6,\n\n    /**\n     * 1 ether = 1,000,000,000 gwei. 9 fractional digits FixedPointNumber.\n     */\n    gwei = 9,\n\n    /**\n     * 1 ether = 1,000,000,000 szabo. 12 fractional digits FixedPointNumber.\n     */\n    szabo = 12,\n\n    /**\n     * 1 ether = 1,000,000 finney. 15 fractional digits FixedPointNumber.\n     */\n    finney = 15,\n\n    /**\n     * 18 fractional diguts FixedPointNumber.\n     */\n    ether = 18\n}\n\n/**\n * Namespace for unit conversion functions,\n * providing the same functionalities of\n * [ethers v6 Unit Conversion](https://docs.ethers.org/v6/api/utils/#about-units).\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nnamespace Units {\n    /**\n     * Convert a value expressed in {@link Units.wei} as a string\n     * representing the same value expressed in {@link Units.ether}.\n     *\n     * @param {FixedPointNumber} wei - The value in {@link Units.wei}.\n     * @return {string} The formatted string representing the value in\n     * {@link Units.ether}.\n     *\n     * @remarks The term `ether` refers to the order of magnitude 10E18,\n     * not to the `ETH` cryptocurrency.\n     *\n     * @see [ethers formatEther](https://docs.ethers.org/v6/api/utils/#formatEther)\n     */\n    export function formatEther(wei: FixedPointNumber): string {\n        return formatUnits(wei, Units.ether);\n    }\n\n    /**\n     * Convert a value expressed in {@link Units.wei} as a string\n     * representing the same value expressed in `unit`.\n     *\n     * @param {FixedPointNumber} wei - The value in {@link Units.wei}.\n     * @param {Units} unit The order of magnitude to express the `wei` value.\n     * @return {string} The formatted string representing the value\n     * in the named `unit`.\n     *\n     * @remarks The term `ether` refers to the order of magnitude 10E18,\n     * not to the `ETH` cryptocurrency.\n     *\n     * @see [ethers formatUnits](https://docs.ethers.org/v6/api/utils/#formatUnits)\n     */\n    export function formatUnits(\n        wei: FixedPointNumber,\n        unit: Units = Units.ether\n    ): string {\n        const fpn = wei.div(FixedPointNumber.of(10n ** BigInt(unit)));\n        return fpn.isInteger() ? `${fpn}.0` : `${fpn}`;\n    }\n\n    /**\n     * Parse the decimal string expressing a value in {@link Units.ether}\n     * to return a {@link FixedPointNumber} value expressed in {@link Units.wei}.\n\n     * @param ether = The representation of a numeric value expressed\n     * in {@link Units.ether}.\n     * @return The equivalent value in {@link Units.wei}.\n     *\n     * @throws {InvalidDataType} If `exp` is not a numeric expression.\n     *\n     * @remarks The term `ether` refers to the order of magnitude 10E18,\n     * not to the `ETH` cryptocurrency.\n     *\n     * @see [ethers parseEther](https://docs.ethers.org/v6/api/utils/#parseEther)\n     */\n    export function parseEther(ether: string): FixedPointNumber {\n        return parseUnits(ether, Units.ether);\n    }\n\n    /**\n     * Parse the decimal string expressing a value in the named `unit`\n     * ro return a {@link FixedPointNumber} value expressed in {@link Units.wei}.\n\n     * @param {string} exp - The representation of a numeric value expressed\n     * in {@link Units.ether}.\n     * @param {Units} unit - The order of magnitude to use to parse the `exp`\n     * representation.\n     *\n     * @throws {InvalidDataType} If `exp` is not a numeric expression.\n     *\n     * @remarks The term `ether` refers to the order of magnitude 10E18,\n     * not to the `ETH` cryptocurrency.\n     *\n     * @see [ethers parseUnits](https://docs.ethers.org/v6/api/utils/#parseUnits)\n     */\n    export function parseUnits(\n        exp: string,\n        unit: Units = Units.ether\n    ): FixedPointNumber {\n        return FixedPointNumber.of(exp).times(\n            FixedPointNumber.of(10n ** BigInt(unit))\n        );\n    }\n\n    /**\n     * Convert a value expressed in `fromUnits` to `toUnits`.\n     *\n     * @param value The value to convert.\n     * @param fromUnits The units of the value to convert.\n     * @param toUnits The units to convert the value to.\n     * @returns The value converted to `toUnits`.\n     */\n    export function convertUnits(\n        value: FixedPointNumber,\n        fromUnits: Units,\n        toUnits: Units\n    ): FixedPointNumber {\n        const diffUnits = BigInt(toUnits - fromUnits);\n        if (diffUnits >= 0n) {\n            return value.div(FixedPointNumber.of(10n ** diffUnits));\n        } else {\n            return value.times(FixedPointNumber.of(10n ** BigInt(-diffUnits)));\n        }\n    }\n\n    /**\n     * Format a value expressed in `fromUnits` to a decimal string\n     * expressed in `toUnits`.\n     *\n     * @param value The value to format.\n     * @param fromUnits The units of the value to format.\n     * @param toUnits The units to format the value to.\n     * @returns The formatted value as a decimal string.\n     */\n    export function formatFromUnits(\n        value: FixedPointNumber,\n        fromUnits: Units,\n        toUnits: Units,\n        displayDecimals?: number\n    ): string {\n        let targetValue = convertUnits(value, fromUnits, toUnits);\n        // round the target value to the displayDecimals\n        if (displayDecimals !== undefined) {\n            if (displayDecimals >= 0) {\n                targetValue =\n                    FixedPointNumber.of(targetValue).dp(displayDecimals);\n            } else {\n                throw new InvalidDataType(\n                    'Units.formatFromUnits',\n                    'displayDecimals must be greater than or equal to 0',\n                    {\n                        value,\n                        fromUnits,\n                        toUnits,\n                        displayDecimals\n                    }\n                );\n            }\n        }\n        const decimalValue = targetValue.toString();\n        // pad the decimal value with zeros to the displayDecimals\n        if (displayDecimals !== undefined) {\n            const decimalParts = decimalValue.split('.');\n            if (decimalParts.length > 1) {\n                if (displayDecimals > 0) {\n                    return (\n                        decimalParts[0] +\n                        '.' +\n                        decimalParts[1].slice(0, displayDecimals)\n                    );\n                } else {\n                    return decimalParts[0];\n                }\n            }\n            if (displayDecimals > 0) {\n                return decimalParts[0] + '.' + '0'.repeat(displayDecimals);\n            } else {\n                return decimalParts[0];\n            }\n        }\n        return decimalValue;\n    }\n}\n\nexport { Units };\n","import { Coin } from './Coin';\nimport { FixedPointNumber } from '../FixedPointNumber';\nimport { Txt } from '../Txt';\nimport { Units } from './Units';\n\n/**\n * Represents a\n * [VeChain VET](https://docs.vechain.org/introduction-to-vechain/dual-token-economic-model/vechain-vet)\n * monetary amount.\n *\n * @extends Coin\n */\nclass VET extends Coin {\n    /**\n     * The code for VET is the sequence of Unicode\n     * - U+1D64D - mathematical double strike capital letter 'V',\n     * - U+039F - Greek capital letter 'Xi',\n     * - U+0054 - Latin capital letter 'T'.\n     */\n    public static readonly CODE = Txt.of('T');\n\n    /**\n     * Wei fractional digits to express this value.\n     */\n    private static readonly WEI_FD = 18n;\n\n    /**\n     * Represents this monetary amount in terms of {@link Units.wei}.\n     *\n     * @type {bigint}\n     */\n    public readonly wei: bigint = this.value.dp(VET.WEI_FD).scaledValue;\n\n    /**\n     * Create a new instance with the given `value`.\n     *\n     * @param {FixedPointNumber} value The value to be used for initializing the instance.\n     */\n    protected constructor(value: FixedPointNumber) {\n        super(VET.CODE, value);\n    }\n\n    /**\n     * Return a new VET instance with the specified value and unit.\n     *\n     * @param {bigint | number | string | FixedPointNumber} value - The numerical value for the VET instance.\n     * @param {Units} unit - The unit for the value.\n     *                     Defaults to {@link Units.ether} if not provided.\n     * @return {VET} A new VET instance with the provided value and unit.\n     *\n     * @throws {InvalidDataType} If `value` is not a numeric expression.\n     */\n    public static of(\n        value: bigint | number | string | FixedPointNumber,\n        unit: Units = Units.ether\n    ): VET {\n        const fpn =\n            value instanceof FixedPointNumber\n                ? value\n                : FixedPointNumber.of(value);\n        return new VET(\n            fpn.div(FixedPointNumber.of(10n ** (VET.WEI_FD - BigInt(unit))))\n        );\n    }\n}\n\nexport { VET };\n","import { Coin } from './Coin';\nimport { FixedPointNumber } from '../FixedPointNumber';\nimport { Txt } from '../Txt';\nimport { Units } from './Units';\n\n/**\n * Represents a\n * [VeChain VeThor](https://docs.vechain.org/introduction-to-vechain/dual-token-economic-model/vethor-vtho)\n * monetary amount.\n *\n * @extends Coin\n */\nclass VTHO extends Coin {\n    /**\n     * The code for VET is the sequence of Unicode\n     * - U+1D64D - mathematical double strike capital letter 'V',\n     * - U+0054 - Latin capital letter 'T',\n     * - U+0048 - Latin capital letter 'H',\n     * - U+004F - Latin capital letter 'O'.\n     */\n    public static readonly CODE = Txt.of('THO');\n\n    /**\n     * Wei fractional digits to express this value.\n     */\n    private static readonly WEI_FD = 18n;\n\n    /**\n     * Represents this monetary amount in terms of {@link Units.wei}.\n     *\n     * @type {bigint}\n     */\n    public readonly wei: bigint = this.value.dp(VTHO.WEI_FD).scaledValue;\n\n    /**\n     * Create a new instance with the given `value`.\n     *\n     * @param {FixedPointNumber} value The value to be used for initializing the instance.\n     */\n    protected constructor(value: FixedPointNumber) {\n        super(VTHO.CODE, value);\n    }\n\n    /**\n     * Return a new VTHO instance with the specified value and unit.\n     *\n     * @param {bigint | number | string | FixedPointNumber} value - The numerical value for the VTHO instance.\n     * @param {Units} unit - The unit for the value.\n     *                       Defaults to {@link Units.ether} if not provided.\n     * @return {VTHO} A new VTHO instance with the provided value and unit.\n     *\n     * @throws {InvalidDataType} If `value` is not a numeric expression.\n     */\n    public static of(\n        value: bigint | number | string | FixedPointNumber,\n        unit: Units = Units.ether\n    ): VTHO {\n        const fpn =\n            value instanceof FixedPointNumber\n                ? value\n                : FixedPointNumber.of(value);\n        return new VTHO(\n            fpn.div(FixedPointNumber.of(10n ** (VTHO.WEI_FD - BigInt(unit))))\n        );\n    }\n}\n\nexport { VTHO };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { type Address } from '../Address';\nimport { FixedPointNumber } from '../FixedPointNumber';\nimport { Units } from './Units';\n\n/**\n * Represents a generic Token\n * A token has base units (e.g. wei) and display units\n * For example 1 VTHO (1 in display units) = 10^18 base units (wei)\n */\nabstract class Token {\n    /**\n     * Base units to represent the token\n     */\n    abstract readonly units: Units;\n\n    /**\n     * Token name\n     */\n    abstract readonly name: string;\n\n    /**\n     * Token contract address\n     */\n    abstract readonly tokenAddress: Address;\n\n    // Store the token's value in wei (smallest possible)\n    protected _valueWei: bigint;\n\n    /**\n     * Create a new instance\n     */\n    constructor() {\n        // covert value to wei units\n        this._valueWei = 0n;\n    }\n\n    /**\n     * Initilises the instance with a value\n     * @param value Token value\n     * @param valueUnits Units for the token value\n     */\n    protected initialize(value: bigint, valueUnits: Units = this.units): void {\n        const valueWei = Units.convertUnits(\n            FixedPointNumber.of(value),\n            valueUnits,\n            Units.wei\n        );\n        if (valueWei.isNegative()) {\n            throw new InvalidDataType('Token.initialize', 'Value is negative', {\n                value,\n                valueUnits\n            });\n        } else {\n            this._valueWei = valueWei.bi;\n        }\n    }\n\n    /**\n     * Converts provided value to the tokens base units value\n     * @returns The value converted to tokens base units\n     */\n    private convertWeiToTokenUnits(): bigint {\n        return Units.convertUnits(\n            FixedPointNumber.of(this._valueWei),\n            Units.wei,\n            this.units\n        ).bi;\n    }\n\n    /**\n     * Get the token's value in base units.\n     * @returns {bigint} Token value in base units\n     */\n    public get value(): bigint {\n        return this.convertWeiToTokenUnits();\n    }\n\n    /**\n     * Converts the base unit value to a human-readable string.\n     */\n    public format(\n        toUnits: Units = this.units,\n        displayDecimals?: number\n    ): string {\n        return Units.formatFromUnits(\n            FixedPointNumber.of(this._valueWei),\n            Units.wei,\n            toUnits,\n            displayDecimals\n        );\n    }\n}\n\nexport { Token };\n","import {\n    type BufferOutput,\n    type DataOutput,\n    type RLPInput,\n    type RLPValidObject\n} from '../types';\n\n/* ------- RLP Profile Types ------- */\n/**\n * `RLPProfile` Interface - Describes the profile of the RLP encoding.\n */\ninterface RLPProfile {\n    name: string;\n    kind: ScalarKind | ArrayKind | StructKind;\n}\n\n/**\n * `ArrayKind` Interface - Describes an array-kind in the RLP encoding profile.\n */\ninterface ArrayKind {\n    item: RLPProfile['kind'];\n}\n\n/**\n * `StructKind` Type - Describes a structured-kind in the RLP encoding profile using an array of `RLPProfile`.\n */\ntype StructKind = RLPProfile[];\n\n/**\n * `ScalarKind` Abstract Class - A base for scalar kinds providing contract for data and buffer manipulations.\n */\nabstract class ScalarKind {\n    /**\n     * Abstract method to handle data encoding.\n     * @param data - The data to encode.\n     * @param context - Contextual information for error messaging.\n     * @returns An object providing a mechanism to encode the data into a Uint8Array.\n     */\n    public abstract data(\n        data: RLPInput | RLPValidObject,\n        context: string\n    ): DataOutput;\n\n    /**\n     * Abstract method to handle buffer decoding.\n     * @param buffer - The buffer to decode.\n     * @param context - Contextual information for error messaging.\n     * @returns An object providing a mechanism to decode the buffer back into data.\n     */\n    public abstract buffer(buffer: Uint8Array, context: string): BufferOutput;\n}\n\nexport { ScalarKind, type RLPProfile };\n","import { RLP as EthereumjsRLP } from '@ethereumjs/rlp';\nimport { bytesToNumberBE } from '@noble/ciphers/utils';\nimport { InvalidDataType, InvalidRLP } from '@vechain/sdk-errors';\nimport { Hex } from '../../Hex';\nimport { type VeChainDataModel } from '../../VeChainDataModel';\nimport { ScalarKind, type RLPProfile } from './kind/ScalarKind';\nimport { type RLPInput, type RLPValidObject, type RLPValueType } from './types';\n\nclass RLP implements VeChainDataModel<RLP> {\n    public readonly encoded: Uint8Array;\n    public readonly decoded: RLPInput;\n\n    protected constructor(data: RLPInput);\n    protected constructor(data: Uint8Array);\n    protected constructor(data: RLPInput | Uint8Array) {\n        // ArrayBuffer.isView so we support https://github.com/vitest-dev/vitest/issues/5183\n        this.decoded = ArrayBuffer.isView(data)\n            ? EthereumjsRLP.decode(data)\n            : data;\n        this.encoded = ArrayBuffer.isView(data)\n            ? data\n            : EthereumjsRLP.encode(data);\n    }\n\n    /**\n     * Returns the bigint representation of the encoded data in the RLP instance.\n     * @returns {bigint} The bigint representation of the encoded data.\n     */\n    get bi(): bigint {\n        return bytesToNumberBE(this.bytes);\n    }\n\n    /**\n     * Returns the encoded data as a Uint8Array.\n     * @returns {Uint8Array} The encoded data.\n     */\n    get bytes(): Uint8Array {\n        return this.encoded;\n    }\n\n    /**\n     * Returns the number representation of the encoded data in the RLP instance.\n     * @returns {number} The number representation of the encoded data.\n     */\n    get n(): number {\n        const bi = this.bi;\n        if (bi <= Number.MAX_SAFE_INTEGER) {\n            return Number(bi);\n        }\n        throw new InvalidDataType('RLP.n', 'not in the safe number range', {\n            bytes: this.bytes\n        });\n    }\n\n    /**\n     * Compares the current RLP instance with another RLP instance.\n     * @param {RLP} that The RLP instance to compare.\n     * @returns 0 if the RLP instances are equal, -1/1 if they are not.\n     */\n    public compareTo(that: RLP): number {\n        if (this.encoded.length !== that.encoded.length) {\n            return -1;\n        }\n\n        for (let i = 0; i < this.encoded.length; i++) {\n            if (this.encoded[i] !== that.encoded[i]) {\n                return 1;\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * Relies on compareTo to check if the RLP instances are equal.\n     * @param {RLP} that The RLP instance to compare.\n     * @returns true if the RLP instances are equal, false otherwise.\n     */\n    public isEqual(that: RLP): boolean {\n        return this.compareTo(that) === 0;\n    }\n\n    /**\n     * Creates {@link Hex} instance from the RLP encoded value.\n     * @returns {Hex} The Hex instance.\n     */\n    public toHex(): Hex {\n        return Hex.of(this.bytes);\n    }\n\n    /**\n     * Returns an RLP instance from a plain value.\n     * @param data - The plain data\n     * @returns {RLP} The RLP instance.\n     */\n    public static of(data: RLPInput): RLP {\n        try {\n            return new RLP(data);\n        } catch (error) {\n            throw new InvalidRLP(\n                'RLP.of()',\n                `Error when creating an RLP instance for data ${data}`,\n                {\n                    context:\n                        'This method creates an RLP instance from a plain value.',\n                    data: {\n                        data\n                    }\n                },\n                error\n            );\n        }\n    }\n\n    /**\n     * Returns an RLP instancen from an encoded value.\n     * @param {Uint8Array} encodedData - The RLP-encoded data.\n     * @returns The decoded data or null if decoding fails.\n     */\n    public static ofEncoded(encodedData: Uint8Array): RLP {\n        try {\n            return new RLP(encodedData);\n        } catch (error) {\n            throw new InvalidRLP(\n                'RLP.ofEncoded()',\n                `Error when creating an RLP instance for encoded data.`,\n                {\n                    context:\n                        'This method creates an RLP instance from an encoded value.',\n                    data: {\n                        encodedData\n                    }\n                },\n                error\n            );\n        }\n    }\n\n    /**\n     * Handles the RLP packing of data.\n     * Recursively processes through object properties or array elements to prepare data for RLP encoding.\n     *\n     * @param obj - The object data to be packed.\n     * @param profile - Profile for encoding structures.\n     * @param context - Encoding context for error tracing.\n     * @returns Packed data as RLPInput.\n     * @throws {InvalidRLP}\n     *\n     */\n    protected static packData(\n        obj: RLPValidObject,\n        profile: RLPProfile,\n        context: string\n    ): RLPInput {\n        context = context !== '' ? context + '.' + profile.name : profile.name;\n        const kind = profile.kind;\n\n        // ScalarKind: direct encoding using the provided method.\n        if (kind instanceof ScalarKind) {\n            return kind.data(obj, context).encode();\n        }\n\n        // StructKind: recursively pack each struct member based on its profile.\n        if (Array.isArray(kind)) {\n            return kind.map((k) =>\n                this.packData(obj[k.name] as RLPValidObject, k, context)\n            );\n        }\n\n        // Valid RLP array\n        if (!Array.isArray(obj)) {\n            throw new InvalidRLP(\n                'RLP.packData()',\n                `Validation error: Expected an array in ${context}.`,\n                {\n                    context,\n                    data: {\n                        obj,\n                        profile\n                    }\n                }\n            );\n        }\n\n        // ArrayKind: recursively pack each array item based on the shared item profile.\n        if ('item' in kind && Array.isArray(obj)) {\n            const item = kind.item;\n            return obj.map((part, i) =>\n                this.packData(\n                    part as RLPValidObject,\n                    { name: '#' + i, kind: item },\n                    context\n                )\n            );\n        }\n    }\n\n    /**\n     * Handles the RLP unpacking of data.\n     * Recursively processes through packed properties or elements to prepare data post RLP decoding.\n     *\n     * @param packed - The packed data to be unpacked.\n     * @param profile - Profile for decoding structures.\n     * @param context - Decoding context for error tracing.\n     * @returns Unpacked data as RLPValueType.\n     * @throws {InvalidRLP}\n     *\n     */\n    protected static unpackData(\n        packed: RLPInput,\n        profile: RLPProfile,\n        context: string\n    ): RLPValueType {\n        context = context !== '' ? context + '.' + profile.name : profile.name;\n\n        const kind = profile.kind;\n\n        // ScalarKind: Direct decoding using the provided method.\n        if (kind instanceof ScalarKind) {\n            // ArrayBuffer.isView so we support https://github.com/vitest-dev/vitest/issues/5183\n            if (!ArrayBuffer.isView(packed)) {\n                throw new InvalidRLP(\n                    'RLP.unpackData()',\n                    `Unpacking error: Expected data type is Uint8Array.`,\n                    {\n                        context,\n                        data: {\n                            packed,\n                            profile\n                        }\n                    }\n                );\n            }\n\n            return kind.buffer(packed, context).decode();\n        }\n\n        // StructKind: Recursively unpack each struct member based on its profile.\n        if (Array.isArray(kind) && Array.isArray(packed)) {\n            const parts = packed;\n\n            if (kind.length !== parts.length) {\n                throw new InvalidRLP(\n                    'RLP.unpackData()',\n                    `Unpacking error: Expected ${kind.length} items, but got ${parts.length}.`,\n                    {\n                        context,\n                        data: {\n                            packed,\n                            profile\n                        }\n                    }\n                );\n            }\n\n            return kind.reduce(\n                (obj: RLPValidObject, profile: RLPProfile, index: number) => {\n                    obj[profile.name] = this.unpackData(\n                        parts[index],\n                        profile,\n                        context\n                    );\n\n                    return obj;\n                },\n                {}\n            );\n        }\n\n        // Valid RLP array\n        if (!Array.isArray(packed)) {\n            throw new InvalidRLP(\n                'RLP.unpackData()',\n                `Validation error: Expected an array in ${context}.`,\n                {\n                    context,\n                    data: {\n                        packed,\n                        profile\n                    }\n                }\n            );\n        }\n\n        // ArrayKind: Recursively unpack each array item based on the shared item profile.\n        if ('item' in kind && Array.isArray(packed)) {\n            const item = kind.item;\n\n            return packed.map((part, index) =>\n                this.unpackData(\n                    part,\n                    { name: '#' + index, kind: item },\n                    context\n                )\n            ) as RLPValueType;\n        }\n    }\n}\n\nexport { RLP };\n","import { type RLPProfile } from './kind/ScalarKind';\nimport { RLP } from './RLP';\nimport { type RLPInput, type RLPValidObject, type RLPValueType } from './types';\n\n/**\n * Class handling the profiling of RLP encoded/decoded objects.\n * Provides methods to encode and decode objects based on a provided RLP profile.\n */\nclass RLPProfiler extends RLP {\n    /**\n     * Creates a new Profiler instance.\n     * @param profile - Profile for encoding/decoding structures.\n     */\n    private constructor(\n        data: RLPInput,\n        readonly profile: RLPProfile\n    ) {\n        super(data);\n    }\n\n    /**\n     * Creates an RLPProfiler instance from a valid object.\n     * @param {RLPValidObject} validObject Object to be encoded.\n     * @returns {RLPProfiler} RLPProfiler instance.\n     */\n    public static ofObject(\n        validObject: RLPValidObject,\n        profile: RLPProfile\n    ): RLPProfiler {\n        const packedData = this.packData(validObject, profile, '');\n        return new RLPProfiler(packedData, profile);\n    }\n\n    /**\n     * Decodes an object following the provided profile.\n     * @param encodedData Data to be decoded.\n     * @param profile Profile for encoding/decoding structures.\n     * @returns - Decoded data as RLPValueType.\n     */\n    public static ofObjectEncoded(\n        encodedData: Uint8Array,\n        profile: RLPProfile\n    ): RLPProfiler {\n        const packedData = RLP.ofEncoded(encodedData).decoded;\n        return new RLPProfiler(packedData, profile);\n    }\n\n    /**\n     * Returns the decoded unpacked object.\n     * @returns {RLPValueType} Decoded unpacked object.\n     */\n    get object(): RLPValueType {\n        return RLPProfiler.unpackData(this.decoded, this.profile, '');\n    }\n}\n\nexport { RLPProfiler };\n","import { InvalidRLP } from '@vechain/sdk-errors';\nimport { FixedPointNumber } from '../../../FixedPointNumber';\nimport { Hex } from '../../../Hex';\nimport { HexUInt } from '../../../HexUInt';\nimport { type RLPInput } from '../types';\n\n/**\n * Validates and converts the input data to a BigInt.\n *\n * @param data - Either a number or a string representing a non-negative integer.\n * @param context - A string representing the context in which this function is used,\n *                 to create meaningful error messages.\n * @returns The input data converted to a BigInt.\n * @throws {InvalidRLP}\n */\nconst validateNumericKindData = (data: RLPInput, context: string): bigint => {\n    // Input data must be either a number or a string.\n    if (typeof data !== 'number' && typeof data !== 'string') {\n        throw new InvalidRLP(\n            'validateNumericKindData()',\n            `Validation error: Input in ${context} must be a string or number.`,\n            {\n                context,\n                data: {\n                    data\n                }\n            }\n        );\n    }\n\n    if (typeof data === 'number') {\n        _validateNumericKindNumber(data, context);\n    } else if (typeof data === 'string') {\n        _validateNumericKindString(data, context);\n    }\n\n    return BigInt(data);\n};\n\n/**\n * Ensures that a numeric input is a safe and non-negative integer.\n *\n * @remarks\n * A \"safe integer\" in JavaScript is an integer that can be precisely represented\n * without rounding in the double-precision floating point format used by the language,\n * i.e., between 0 and 2^53 - 1, since we're ensuring non-negativity.\n *\n * @param num - The number to be validated.\n * @param context - A string indicating the context, used for error messaging.\n * @throws {InvalidRLP}\n */\nconst _validateNumericKindNumber = (num: number, context: string): void => {\n    if (!Number.isSafeInteger(num) || num < 0) {\n        throw new InvalidRLP(\n            '_validateNumericKindNumber()',\n            `Validation error: Number in ${context} must be a safe and non-negative integer.`,\n            {\n                context,\n                data: {\n                    num\n                }\n            }\n        );\n    }\n};\n\n/**\n * Validates a string to ensure it represents a valid non-negative integer.\n *\n * @remarks\n * The input string can represent an unsigned integer in either decimal or hexadecimal format.\n *\n * @param str - A string expected to represent a non-negative integer.\n * @param context - A string indicating the context, for creating meaningful error messages.\n * @throws {InvalidRLP}\n *\n * @private\n */\nconst _validateNumericKindString = (str: string, context: string): void => {\n    const isHexUInt = HexUInt.isValid0x(str);\n    const isDecimal = FixedPointNumber.isNaturalExpression(str);\n    // Ensure the string is either a hex or decimal number.\n    if (!isHexUInt && !isDecimal) {\n        throw new InvalidRLP(\n            '_validateNumericKindString()',\n            `Validation error: String in ${context} must represent a non-negative integer in hex or decimal format.`,\n            {\n                context,\n                data: {\n                    str\n                }\n            }\n        );\n    }\n\n    // Ensure hex numbers are of a valid length.\n    if (isHexUInt && str.length <= 2) {\n        throw new InvalidRLP(\n            '_validateNumericKindString()',\n            `Validation error: Hex string number in ${context} must be of valid length.`,\n            {\n                context,\n                data: {\n                    str\n                }\n            }\n        );\n    }\n};\n\n/**\n * Validates a buffer to ensure it adheres to constraints and does not contain\n * leading zero bytes which are not canonical representation in integers.\n *\n * @param {Uint8Array} buf - The buffer to validate.\n * @param {string} context - A string providing context for error messages.\n * @param {number} maxBytes - [Optional] An integer representing the maximum allowed length\n *                   of the buffer. If provided, an error will be thrown if buf is longer.\n * @throws {InvalidRLP}\n *\n * @private\n */\nconst assertValidNumericKindBuffer = (\n    buf: Uint8Array,\n    context: string,\n    maxBytes?: number\n): void => {\n    // If maxBytes is defined, ensure buffer length is within bounds.\n    if (maxBytes !== undefined && buf.length > maxBytes) {\n        throw new InvalidRLP(\n            'assertValidNumericKindBuffer()',\n            `Validation error: Buffer in ${context} must be less than ${maxBytes} bytes.`,\n            {\n                context,\n                data: {\n                    buf,\n                    maxBytes\n                }\n            }\n        );\n    }\n\n    // Ensure the buffer does not have leading zeros, as it's not canonical in integer representation.\n    if (buf[0] === 0) {\n        throw new InvalidRLP(\n            'assertValidNumericKindBuffer()',\n            `Validation error: Buffer in ${context} must represent a canonical integer (no leading zeros).`,\n            {\n                context,\n                data: {\n                    buf,\n                    maxBytes\n                }\n            }\n        );\n    }\n};\n\n/**\n * Encode a BigInt instance into a Buffer, ensuring it adheres to specific constraints.\n *\n * @param {bigint} bi - BigInt instance to encode.\n * @param {number | undefined} maxBytes - Maximum byte length allowed for the encoding. If undefined, no byte size limit is imposed.\n * @param {string} context - Contextual information for error messages.\n * @returns {Uint8Array} Encoded data.\n * @throws {InvalidRLP}\n */\nconst encodeBigIntToBuffer = (\n    bi: bigint,\n    maxBytes: number | undefined,\n    context: string\n): Uint8Array => {\n    if (bi === 0n) return Uint8Array.from([]);\n    const hex = Hex.of(bi).digits;\n\n    if (maxBytes !== undefined && hex.length > maxBytes * 2) {\n        throw new InvalidRLP(\n            'encodeBigIntToBuffer()',\n            `Validation error: Encoded number in ${context} must fit within ${maxBytes} bytes.`,\n            {\n                context,\n                data: {\n                    hex,\n                    maxBytes\n                }\n            }\n        );\n    }\n\n    return Hex.of(hex).bytes;\n};\n\n/**\n * Decode a Uint8Array into a number or hexadecimal string.\n * @param {Uint8Array} buffer - Instance to decode.\n * @returns A number if the decoded BigInt is a safe integer, otherwise returns a hexadecimal string.\n */\nconst decodeBufferToNumberOrHex = (buffer: Uint8Array): number | string => {\n    if (buffer.length === 0) return 0;\n\n    const bi = Hex.of(buffer).bi;\n    const num = Number(bi);\n\n    // Return number or hex based on integer safety\n    return Number.isSafeInteger(num) ? num : '0x' + bi.toString(16);\n};\n\nexport {\n    assertValidNumericKindBuffer,\n    decodeBufferToNumberOrHex,\n    encodeBigIntToBuffer,\n    validateNumericKindData\n};\n","import { InvalidRLP } from '@vechain/sdk-errors';\nimport { Hex } from '../../../Hex';\nimport { type RLPInput } from '../types';\n\n/**\n * Validates if the input is a proper hex string for HexBlobKind.\n *\n * @param data - The input data to validate.\n * @param context - Additional context for error handling.\n * @throws {InvalidRLP}\n */\nconst assertValidHexBlobKindData = (data: RLPInput, context: string): void => {\n    if (typeof data !== 'string') {\n        throw new InvalidRLP(\n            'assertValidHexBlobKindData()',\n            `Validation error: Input must be a string.`,\n            {\n                context,\n                data: {\n                    data\n                }\n            }\n        );\n    }\n\n    // Check if data is a valid hex string with '0x' prefix.\n    if (!Hex.isValid(data)) {\n        throw new InvalidRLP(\n            'assertValidHexBlobKindData()',\n            `Validation error: Input must be a valid hex string with a '0x' prefix.`,\n            {\n                context,\n                data: {\n                    data\n                }\n            }\n        );\n    }\n\n    // Ensure the hex string length is even.\n    if (data.length % 2 !== 0) {\n        throw new InvalidRLP(\n            'assertValidHexBlobKindData()',\n            `Validation error: Hex string must have an even length.`,\n            {\n                context,\n                data: {\n                    data\n                }\n            }\n        );\n    }\n};\n\nexport { assertValidHexBlobKindData };\n","import { InvalidRLP } from '@vechain/sdk-errors';\n\n/**\n * Asserts that the data is a hex string of the correct length.\n *\n * @param data - The data to validate.\n * @param context - Descriptive context for error messages.\n * @param bytes - The expected number of bytes that the data can contain.\n * @throws {InvalidRLP}\n */\nconst assertFixedHexBlobKindData = (\n    data: string,\n    context: string,\n    bytes: number\n): void => {\n    if (data.length !== bytes * 2 + 2) {\n        throw new InvalidRLP(\n            'assertFixedHexBlobKindData()',\n            `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,\n            {\n                context,\n                data: {\n                    data,\n                    bytes\n                }\n            }\n        );\n    }\n};\n\n/**\n * Asserts that the buffer is of a specific length.\n *\n * @param {Uint8Array} buffer The buffer to validate.\n * @param {string} context Descriptive context for error messages.\n * @param {number} bytes The expected number of bytes that the buffer can contain.\n * @throws {InvalidRLP}\n */\nconst assertFixedHexBlobKindBuffer = (\n    buffer: Uint8Array,\n    context: string,\n    bytes: number\n): void => {\n    if (buffer.length !== bytes) {\n        throw new InvalidRLP(\n            'assertFixedHexBlobKindData()',\n            `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,\n            {\n                context,\n                data: {\n                    buffer,\n                    bytes\n                }\n            }\n        );\n    }\n};\n\nexport { assertFixedHexBlobKindData, assertFixedHexBlobKindBuffer };\n","import { InvalidRLP } from '@vechain/sdk-errors';\nimport { Hex } from '../../../Hex';\n\n/**\n * Asserts that the provided buffer is of a specific length and does not contain leading zeros.\n *\n * @param {Uint8Array} buffer - The buffer to validate.\n * @param {string} context - Descriptive context for error messages, usually representing the caller's identity.\n * @param {number} bytes - The expected maximum number of bytes that the buffer can contain.\n * @throws {InvalidRLP}\n */\nconst assertCompactFixedHexBlobBuffer = (\n    buffer: Uint8Array,\n    context: string,\n    bytes: number\n): void => {\n    if (buffer.length > bytes) {\n        throw new InvalidRLP(\n            'assertCompactFixedHexBlobBuffer()',\n            `Validation error: Buffer in ${context} must be at most ${bytes} bytes.`,\n            {\n                context,\n                data: {\n                    buffer,\n                    bytes\n                }\n            }\n        );\n    }\n\n    if (buffer.length !== 0 && buffer[0] === 0) {\n        throw new InvalidRLP(\n            'assertCompactFixedHexBlobBuffer()',\n            `Validation error: Buffer in ${context} should not have leading zero bytes.`,\n            {\n                context,\n                data: {\n                    buffer,\n                    bytes\n                }\n            }\n        );\n    }\n};\n\n/**\n * Encodes a buffer by trimming leading zero bytes.\n * Finds the first non-zero byte and returns a new buffer starting from that byte. Returns an empty buffer if all bytes are zero.\n *\n * @param {Uint8Array} buffer - The buffer to be compacted.\n * @returns {Uint8Array} A Uint8Array instance compacted of leading zero bytes, or an empty Uint8Array if all bytes are zero.\n */\nconst encodeCompactFixedHexBlob = (buffer: Uint8Array): Uint8Array => {\n    const zeroIndex: number = buffer.findIndex((byte: number) => byte !== 0);\n\n    return zeroIndex !== -1 ? buffer.subarray(zeroIndex) : Uint8Array.from([]);\n};\n\n/**\n * Decodes a buffer into a hexadecimal string, ensuring a specific total byte length by prepending zeros if necessary.\n * Calculates the number of missing bytes compared to the expected total and prepends the corresponding number of '0' characters to the hexadecimal string representation of the buffer.\n *\n * @param {Uint8Array} buffer The buffer to decode.\n * @param {number} bytes The expected total number of bytes in the final hexadecimal string (including leading zeros).\n * @returns A hexadecimal string with the necessary leading '0' characters to ensure the specified total byte length.\n */\nconst decodeBufferToHexWithLeadingZeros = (\n    buffer: Uint8Array,\n    bytes: number\n): string => {\n    return Hex.of(buffer)\n        .fit(bytes * 2)\n        .toString();\n};\n\nexport {\n    assertCompactFixedHexBlobBuffer,\n    decodeBufferToHexWithLeadingZeros,\n    encodeCompactFixedHexBlob\n};\n","import { ScalarKind } from './ScalarKind';\nimport { type BufferOutput, type DataOutput, type RLPInput } from '../types';\nimport { InvalidRLP } from '@vechain/sdk-errors';\n\n/**\n * Represents a scalar kind with Buffer functionality.\n * This class extends the {@link ScalarKind} class.\n */\nclass BufferKind extends ScalarKind {\n    /**\n     * Encodes the input data into buffer format.\n     *\n     * @param {RLPInput} data The data to encode, expected to be of Uint8Array type.\n     * @param {string} context Descriptive context for error messages\n     * @returns {DataOutput} Object with an encode function.\n     * @throws {InvalidRLP}\n     */\n    public data(data: RLPInput, context: string): DataOutput {\n        // Ensure that the data is indeed a Buffer before encoding.\n        // ArrayBuffer.isView so we support https://github.com/vitest-dev/vitest/issues/5183\n        if (!ArrayBuffer.isView(data)) {\n            throw new InvalidRLP(\n                'BufferKind.data()',\n                `Validation error: Expected a Uint8Array type in ${context}.`,\n                {\n                    context,\n                    data: {\n                        data\n                    }\n                }\n            );\n        }\n\n        return {\n            encode: () => data // Data is already a Buffer, so return as-is.\n        };\n    }\n\n    /**\n     * Decodes the input buffer.\n     *\n     * @param {Uint8Array} buffer - The buffer to decode, expected to be of buffer type.\n     * @returns BufferOutput object with a decode function.\n     * @throws {InvalidRLP}\n     */\n    public buffer(buffer: Uint8Array): BufferOutput {\n        return {\n            decode: () => buffer // Buffer is already in the correct format, so return as-is.\n        };\n    }\n}\n\nexport { BufferKind };\n","import { ScalarKind } from './ScalarKind';\nimport {\n    assertValidNumericKindBuffer,\n    decodeBufferToNumberOrHex,\n    encodeBigIntToBuffer,\n    validateNumericKindData\n} from '../helpers';\nimport { type BufferOutput, type DataOutput, type RLPInput } from '../types';\n\n/**\n * Represents a scalar kind with numeric functionality.\n * This class extends the {@link ScalarKind} class.\n */\nclass NumericKind extends ScalarKind {\n    /**\n     * Constructs a new instance of NumericKind.\n     *\n     * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.\n     */\n    constructor(readonly maxBytes?: number) {\n        super();\n    }\n\n    /**\n     * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.\n     *\n     * @param data - The data to encode, expected to be numeric.\n     * @param context - Descriptive context for error messages\n     * @returns DataOutput object with an encode function.\n     * @throws Will throw an error if data validation fails or encoding issues occur.\n     */\n    public data(data: RLPInput, context: string): DataOutput {\n        // Validate and convert the numeric data to a BigInt instance.\n        const dataBI = validateNumericKindData(data, context);\n\n        return {\n            encode: () => encodeBigIntToBuffer(dataBI, this.maxBytes, context) // Encodes BigInt to Buffer, respecting maxBytes.\n        };\n    }\n\n    /**\n     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.\n     *\n     * @param {Uint8Array} buffer - The buffer to decode, containing numeric data.\n     * @param context - Descriptive context for error messages.\n     * @returns BufferOutput object with a decode function.\n     * @throws Will throw an error if buffer validation fails.\n     */\n    public buffer(buffer: Uint8Array, context: string): BufferOutput {\n        // Ensure the buffer adheres to constraints related to numeric data.\n        assertValidNumericKindBuffer(buffer, context, this.maxBytes);\n\n        return {\n            decode: () => decodeBufferToNumberOrHex(buffer) // Decodes buffer to either a number or a hexadecimal string.\n        };\n    }\n}\n\nexport { NumericKind };\n","import { Hex } from '../../../../Hex';\nimport { HexUInt } from '../../../../HexUInt';\nimport { assertValidHexBlobKindData } from '../../helpers';\nimport { type BufferOutput, type DataOutput, type RLPInput } from '../../types';\nimport { ScalarKind } from '../ScalarKind';\n\n/**\n * Represents a scalar kind with hex blob functionality.\n * This class extends the {@link ScalarKind} class.\n *\n * @remarks\n * A hex blob is a hex string that is prefixed with '0x' and has even length.\n */\nclass HexBlobKind extends ScalarKind {\n    /**\n     * Encodes the input data into a Uint8Array.\n     *\n     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.\n     * @param context - Context string for error handling.\n     * @returns An object containing an encode function which returns the encoded Uint8Array.\n     */\n    public data(data: RLPInput, context: string): DataOutput {\n        assertValidHexBlobKindData(data, context);\n\n        return {\n            encode: () => HexUInt.of((data as string).slice(2)).bytes\n        };\n    }\n\n    /**\n     * Decodes the input buffer into a hex string.\n     *\n     * @param buffer - The buffer to decode.\n     * @param context - Context string for error handling.\n     * @returns An object containing a decode function which returns the decoded hex string.\n     */\n    public buffer(buffer: Uint8Array, _context: string): BufferOutput {\n        return {\n            decode: () => Hex.of(buffer).toString()\n        };\n    }\n}\n\nexport { HexBlobKind };\n","import {\n    assertFixedHexBlobKindBuffer,\n    assertFixedHexBlobKindData\n} from '../../helpers';\nimport { type BufferOutput, type DataOutput, type RLPInput } from '../../types';\nimport { HexBlobKind } from './HexBlobKind';\n\n/**\n * Represents a hex blob kind with fixed bytes size functionality.\n * This class extends the {@link HexBlobKind} class.\n */\nclass FixedHexBlobKind extends HexBlobKind {\n    /**\n     * Creates a new instance of the {@link FixedHexBlobKind} class.\n     * @param bytes - The number of bytes the blob must have.\n     */\n    constructor(readonly bytes: number) {\n        super();\n    }\n\n    /**\n     * Encodes the input data into a Uint8Array with validation against fixed size.\n     *\n     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.\n     * @param context - Context string for error handling.\n     * @returns An object containing an encode function which returns the encoded Uint8Array.\n     */\n    public data(data: RLPInput, context: string): DataOutput {\n        const encoder = super.data(data, context);\n\n        // Validate the data length against the fixed size. `typeof data === 'string'` is checked in super.data\n        assertFixedHexBlobKindData(data as string, context, this.bytes);\n\n        return encoder;\n    }\n\n    /**\n     * Decodes the input buffer into a hex string with validation against fixed size.\n     *\n     * @param buffer - The buffer to decode.\n     * @param context - Context string for error handling.\n     * @returns An object containing a decode function which returns the decoded hex string.\n     */\n    public buffer(buffer: Uint8Array, context: string): BufferOutput {\n        const decoder = super.buffer(buffer, context);\n\n        // Validate the buffer length against the fixed size.\n        assertFixedHexBlobKindBuffer(buffer, context, this.bytes);\n\n        return decoder;\n    }\n}\n\nexport { FixedHexBlobKind };\n","import { type BufferOutput, type DataOutput, type RLPInput } from '../../types';\nimport { FixedHexBlobKind } from './FixedHexBlobKind';\n\n/**\n * Represents a fixed hex blob kind with optional data functionality.\n * This class extends the {@link FixedHexBlobKind} class.\n */\nclass OptionalFixedHexBlobKind extends FixedHexBlobKind {\n    /**\n     * Encodes the input data (which can be null or undefined) into a Uint8Array.\n     *\n     * @param data - The data to encode, can be null or undefined.\n     * @param context - Context string for error handling.\n     * @returns An object containing an encode function which returns the encoded Uint8Array.\n     */\n    public data(data: RLPInput, context: string): DataOutput {\n        // If data is null or undefined, return an empty Uint8Array.\n        return data == null\n            ? {\n                  encode: () => Uint8Array.from([])\n              }\n            : super.data(data, context);\n    }\n\n    /**\n     * Decodes the input buffer into a hex string or null if the buffer is empty.\n     *\n     * @param buffer - The buffer to decode, can be empty.\n     * @param context - Context string for error handling.\n     * @returns An object containing a decode function which returns the decoded hex string or null.\n     */\n    public buffer(buffer: Uint8Array, context: string): BufferOutput {\n        return buffer.length === 0\n            ? {\n                  decode: () => null\n              }\n            : super.buffer(buffer, context);\n    }\n}\n\nexport { OptionalFixedHexBlobKind };\n","import { Hex } from '../../../../Hex';\nimport {\n    assertCompactFixedHexBlobBuffer,\n    encodeCompactFixedHexBlob\n} from '../../helpers';\nimport { type BufferOutput, type DataOutput, type RLPInput } from '../../types';\nimport { FixedHexBlobKind } from './FixedHexBlobKind';\n\n/**\n * Represents a fixed hex blob kind with zero trimming and padding functionality.\n * This class extends the {@link FixedHexBlobKind} class.\n */\nclass CompactFixedHexBlobKind extends FixedHexBlobKind {\n    /**\n     * Encodes the input data into a Uint8Array, trimming leading zeros.\n     *\n     * @param data - The data to encode, expected to be a '0x' prefixed hex string.\n     * @param context - Context string for error handling.\n     * @returns An object containing an encode function which returns the encoded Uint8Array.\n     */\n    public data(data: RLPInput, context: string): DataOutput {\n        const buffer: Uint8Array = super.data(data, context).encode();\n\n        return {\n            encode: () => encodeCompactFixedHexBlob(buffer) // Encode the buffer, trimming leading zeros.\n        };\n    }\n\n    /**\n     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.\n     *\n     * @param buffer - The buffer to decode, containing numeric data.\n     * @param context - Descriptive context for error messages, usually representing the caller's identity.\n     * @returns BufferOutput object with a decode function.\n     * @throws Will throw an error if buffer validation fails.\n     */\n    public buffer(buffer: Uint8Array, context: string): BufferOutput {\n        assertCompactFixedHexBlobBuffer(buffer, context, this.bytes);\n\n        return {\n            decode: () =>\n                // Decode the buffer, returning a hex string with leading zeros.\n                Hex.of(buffer)\n                    .fit(this.bytes * 2)\n                    .toString()\n        };\n    }\n}\n\nexport { CompactFixedHexBlobKind };\n","import * as s_bip32 from '@scure/bip32';\nimport * as s_bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nimport {\n    InvalidDataType,\n    InvalidHDKey,\n    InvalidHDKeyMnemonic,\n    InvalidOperation\n} from '@vechain/sdk-errors';\nimport { type VeChainDataModel } from './VeChainDataModel';\nimport { HDKey } from '../hdkey';\n\n/**\n * Type of the wordlist size.\n * Every 4 bytes produce 3 words.\n */\ntype WordlistSizeType = 12 | 15 | 18 | 21 | 24;\n\n/**\n * Size of the mnemonic words in bytes.\n */\ntype WordListRandomGeneratorSizeInBytes = 16 | 20 | 24 | 28 | 32;\n\n/**\n * The Mnemonic class provides functionality related to mnemonic phrases, including encoding to bytes,\n * generating, validating, and deriving keys from mnemonic words based on the BIP39 standard.\n * It implements the VeChainDataModel interface.\n *\n * @implements VeChainDataModel\n */\nclass Mnemonic implements VeChainDataModel<Mnemonic> {\n    /**\n     * A TextEncoder instance used for encoding text to bytes.\n     *\n     * @type {TextEncoder}\n     */\n    private static readonly ENCODER = new TextEncoder();\n\n    /**\n     * Throws an exception because the mnemonic cannot be represented as a big integer.\n     * @returns {bigint} The BigInt representation of the mnemonic.\n     * @throws {InvalidOperation} The mnemonic cannot be represented as a bigint.\n     * @override {@link VeChainDataModel#bi}\n     * @remark The conversion to BigInt is not supported for a mnemonic.\n     */\n    public get bi(): bigint {\n        throw new InvalidOperation(\n            'Mnemonic.bi',\n            'There is no big integer representation for a mnemonic.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * Generates a mnemonic as encoded bytes.\n     *\n     * @returns {Uint8Array} The bytes representation of the words with spaces.\n     */\n    get bytes(): Uint8Array {\n        return Mnemonic.ENCODER.encode(Mnemonic.of().join(' '));\n    }\n\n    /**\n     * Throws an exception because the mnemonic cannot be represented as a number.\n     * @returns {bigint} The number representation of the mnemonic.\n     * @throws {InvalidOperation} The mnemonic cannot be represented as a number.\n     * @override {@link VeChainDataModel#n}\n     * @remark The conversion to number is not supported for a mnemonic.\n     */\n    public get n(): number {\n        throw new InvalidOperation(\n            'Mnemonic.n',\n            'There is no number representation for a mnemonic.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * There is no comparison for a mnemonic.\n     *\n     * @throws {InvalidOperation} The mnemonic cannot be compared.\n     */\n    public compareTo(_that: Mnemonic): number {\n        throw new InvalidOperation(\n            'Mnemonic.compareTo',\n            'There is no comparison for a mnemonic since it is not stored in memory.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * There is no comparison for a mnemonic.\n     *\n     * @throws {InvalidOperation} The mnemonic cannot be compared.\n     */\n    public isEqual(_that: Mnemonic): boolean {\n        throw new InvalidOperation(\n            'Mnemonic.isEqual',\n            'There is no comparison for a mnemonic since it is not stored in memory.',\n            { data: '' }\n        );\n    }\n\n    /**\n     * Convert the number of words to the corresponding strength.\n     *\n     * @param numberOfWords - The number of words.\n     *\n     * @returns {number} The corresponding strength.\n     *\n     * @throws {InvalidDataType} If the number of words is not valid.\n     */\n    private static wordsNoToStrength(numberOfWords: number): number {\n        switch (numberOfWords) {\n            case 12:\n                return 128;\n            case 15:\n                return 160;\n            case 18:\n                return 192;\n            case 21:\n                return 224;\n            case 24:\n                return 256;\n            default:\n                throw new InvalidDataType(\n                    'Mnemonic.wordsNoToStrength',\n                    'not a valid number of words',\n                    { numberOfWords }\n                );\n        }\n    }\n\n    // Legacy method, probably should be part of a Private Key class (ofMnemonic) #1122\n    /**\n     * Derives a private key for the given mnemonic words and derivation path.\n     *\n     * @param {string[]} words - An array of mnemonic words used to generate the private key.\n     * @param {string} [path=HDKey.VET_DERIVATION_PATH+'/0'] - The BIP32 derivation path to derive the private key.\n     * @return {Uint8Array} The derived private key as a Uint8Array.\n     * @throws {InvalidHDKey} If the provided derivation path is invalid.\n     *\n     * @remarks Security auditable method, depends on {@link HDKey}.\n     */\n    public static toPrivateKey(\n        words: string[],\n        path: string = HDKey.VET_DERIVATION_PATH + '/0'\n    ): Uint8Array {\n        const master = s_bip32.HDKey.fromMasterSeed(\n            s_bip39.mnemonicToSeedSync(words.join(' ').toLowerCase())\n        );\n        // Any exception involving mnemonic words is thrown before this point: words are not leaked next.\n        try {\n            // Derived from root, a private key is always available.\n            return master.derive(path).privateKey as Uint8Array;\n        } catch (error) {\n            throw new InvalidHDKey(\n                'mnemonic.derivePrivateKey()',\n                'Invalid derivation path given as input.',\n                { derivationPath: path },\n                error\n            );\n        }\n    }\n\n    /**\n     * Generates a\n     * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)\n     * phrase using the specified wordlist size and random generator.\n     *\n     * @param {WordlistSizeType} wordlistSize - The number of words to generate the mnemonic.\n     * @param {function} [randomGenerator] - The random generator function used to generate the entropy.\n     *\n     * @returns {Mnemonic} The generated mnemonic.\n     *\n     * @throws {InvalidDataType} If the number of words is not valid.\n     *\n     * @remarks Security auditable method, depends on\n     * * [entropyToMnemonic](https://github.com/paulmillr/scure-bip39);\n     * * [generateMnemonic](https://github.com/paulmillr/scure-bip39);\n     * * `randomGenerator` - **Must provide a cryptographic secure source of entropy\n     *    else any secure audit certification related with this software is invalid.**\n     */\n    public static of(\n        wordlistSize: WordlistSizeType = 12,\n        randomGenerator?: (\n            numberOfBytes: WordListRandomGeneratorSizeInBytes\n        ) => Uint8Array\n    ): string[] {\n        try {\n            const strength: number = Mnemonic.wordsNoToStrength(wordlistSize);\n            if (randomGenerator != null) {\n                const numberOfBytes = (strength /\n                    8) as WordListRandomGeneratorSizeInBytes;\n                return s_bip39\n                    .entropyToMnemonic(randomGenerator(numberOfBytes), wordlist)\n                    .split(' ');\n            }\n            return s_bip39.generateMnemonic(wordlist, strength).split(' ');\n        } catch (error) {\n            throw new InvalidHDKeyMnemonic(\n                'Mnemonic.of',\n                'error while generating mnemonic',\n                { wordlistSize },\n                error\n            );\n        }\n    }\n\n    /**\n     * Check if the given mnemonic words are valid.\n     *\n     * @param {string | string[]} words - The mnemonic words to check.\n     *\n     * @returns {boolean} true if the words are valid, false otherwise.\n     *\n     * @remarks Security auditable method, depends on\n     * * [validateMnemonic](https://github.com/paulmillr/scure-bip39).\n     */\n    public static isValid(words: string | string[]): boolean {\n        const wordsToValidate = Array.isArray(words) ? words.join(' ') : words;\n        return s_bip39.validateMnemonic(wordsToValidate, wordlist);\n    }\n}\n\nexport { Mnemonic };\nexport type { WordListRandomGeneratorSizeInBytes, WordlistSizeType };\n","import { HexUInt } from './HexUInt';\nimport { InvalidDataType } from '@vechain/sdk-errors';\n\n/**\n * Represents a hexadecimal numeric value compatible with the result of\n * [ethers](https://docs.ethers.org/v6/)\n * [utils.toQuantity](https://docs.ethers.org/v6/api/utils/#toQuantity) function.\n * This is most commonly used for JSON-RPC numeric values.\n *\n * @remarks A quantity instance:\n * * has not empty content,\n * * the hexadecimal representation removes any not meaningful zero on the left side of the expression,\n * * represents only positive integers.\n *\n * @extends HexUInt\n */\nclass Quantity extends HexUInt {\n    /**\n     * Creates a Quantity instance from a bigint or number given expression\n     *\n     * @param {bigint | number} exp - The value to be expressed as Quantity object:\n     * * bigint must be positive;\n     * * number must be positive, it is converted to bigint to create the Quantity.\n     *\n     * @returns {Quantity} - The new Quantity object.\n     *\n     * @throws {InvalidDataType} - If the provided expression is not a positive integer value.\n     */\n    public static of(exp: bigint | number): Quantity {\n        try {\n            const huint = HexUInt.of(exp);\n            let cue = 0;\n            while (cue < huint.digits.length && huint.digits.at(cue) === '0') {\n                cue++;\n            }\n            return new Quantity(\n                huint.sign,\n                cue === huint.digits.length ? '0' : huint.digits.slice(cue)\n            );\n        } catch (e) {\n            throw new InvalidDataType(\n                'Quantity.of',\n                'not a Quantity expression',\n                { exp: `${exp}` }, // Needed to serialize bigint values.\n                e\n            );\n        }\n    }\n}\n\nexport { Quantity };\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { Hex } from './Hex';\nimport { Txt } from './Txt';\n\n/**\n * Represents a revision for a Thor transaction or block\n * Revision strings can be one of the following:\n * - \"best\": indicating the best revision\n * - \"finalized\": indicating a finalized revision\n * - \"next\": indicating the next revision\n * - \"justified\": indicating the justified revision\n * - A hex string prefixed with \"0x\" indicating a specific block id\n * - A positive number indicating a specific block number\n *\n * @extends Txt\n */\nclass Revision extends Txt {\n    /**\n     * Regular expression pattern for revision strings.\n     *\n     * @type {RegExp}\n     */\n    private static readonly VALID_REVISION_REGEX =\n        /^(best|finalized|next|justified|0x[a-fA-F0-9]+|\\d+)$/;\n\n    /**\n     * Determines if the given value is a valid revision.\n     * @param {bigint| number | string | Hex} value - The value to be validated.\n     * @returns {boolean} - Returns `true` if the value is valid, `false` otherwise.\n     */\n    public static isValid(value: bigint | number | string | Hex): boolean {\n        if (typeof value === 'number') {\n            return Number.isInteger(value) && value >= 0;\n        }\n        if (typeof value === 'bigint') {\n            return value >= BigInt(0);\n        }\n        if (value instanceof Hex) {\n            return Revision.isValid(value.bi);\n        }\n        return Revision.VALID_REVISION_REGEX.test(value);\n    }\n\n    /**\n     * Creates a new Revision object from the given value.\n     *\n     * @param {bigint | number | string | Uint8Array | Hex } value - The value to create the Revision from:\n     * * {@link Hex} must be positive;\n     * * {@link Uint8Array} is decoded as a string: see {@link Txt.of}.\n     *\n     * @returns {Revision} - The created Revision object.\n     *\n     *  @throws {InvalidDataType} if the given value is not a valid revision: see {@link isValid}.\n     *\n     * @remarks The string representation of the revision is always expressed as a number in base 10.\n     * @remarks The {@link Uint8Array} value is decoded as a string content: see {@link Txt.of}.\n     */\n    public static of(value: bigint | number | string | Uint8Array | Hex): Txt {\n        try {\n            // handle Uint8Array which is needed to extend Txt.of\n            if (ArrayBuffer.isView(value)) {\n                const txtValue = Txt.of(value).toString();\n                if (Revision.isValid(txtValue)) {\n                    return new Revision(txtValue);\n                } else {\n                    throw new InvalidDataType('Revision.of', 'not a revision', {\n                        value: `${value}`\n                    });\n                }\n            }\n            // handle other types\n            if (Revision.isValid(value)) {\n                return new Revision(`${value}`);\n            } else {\n                throw new InvalidDataType('Revision.of', 'not a revision', {\n                    value: `${value}`\n                });\n            }\n        } catch (e) {\n            throw new InvalidDataType('Revision.of', 'not a revision', {\n                value: `${value}`,\n                e\n            });\n        }\n    }\n\n    /**\n     * Return the `best` revision instance.\n     */\n    public static readonly BEST: Revision = Revision.of('best');\n\n    /**\n     * Return the `finalized` revision instance.\n     */\n    public static readonly FINALIZED: Revision = Revision.of('finalized');\n\n    /**\n     * Return the `next` revision instance.\n     */\n    public static readonly NEXT: Revision = Revision.of('next');\n\n    /**\n     * Return the `justified` revision instance.\n     */\n    public static readonly JUSTIFIED: Revision = Revision.of('justified');\n}\n\nexport { Revision };\n","import { Hex } from './Hex';\nimport { HexUInt } from './HexUInt';\nimport { InvalidDataType } from '@vechain/sdk-errors';\n\n/**\n * The BlockId class represents a Thor block ID value, which is a hexadecimal positive integer having 64 digits.\n *\n * @extends HexInt\n */\nclass BlockId extends HexUInt {\n    /**\n     * Number of digits to represent a Thor block ID value.\n     *\n     * @remarks The `0x` prefix is excluded.\n     *\n     * @type {number}\n     */\n    private static readonly DIGITS = 64;\n\n    /**\n     * Constructs a BlockId object with the provided hexadecimal value.\n     *\n     * @param {HexUInt} huint - The hexadecimal value representing the BlockId.\n     */\n    protected constructor(huint: HexUInt) {\n        super(Hex.POSITIVE, huint.fit(BlockId.DIGITS).digits);\n    }\n\n    /**\n     * Check if the given expression is a valid BlockId.\n     *\n     * @param {string} exp - The expression to be validated.\n     *\n     * @return {boolean} Returns true if the expression is a valid BlockId, false otherwise.\n     */\n    public static isValid(exp: string): boolean {\n        return Hex.isValid(exp) && HexUInt.REGEX_HEXUINT_PREFIX.test(exp)\n            ? exp.length === BlockId.DIGITS + 2\n            : exp.length === BlockId.DIGITS;\n    }\n\n    /**\n     * Determines whether the given string is a valid hex number prefixed with '0x'.\n     *\n     * @param {string} exp - The hex number to be checked.\n     *\n     *  @returns {boolean} - True if the hex number is valid, false otherwise.\n     */\n    public static isValid0x(exp: string): boolean {\n        return HexUInt.REGEX_HEXUINT_PREFIX.test(exp) && BlockId.isValid(exp);\n    }\n\n    /**\n     * Creates a new BlockId object from the given expression.\n     *\n     * @param {bigint | number | string | Hex | Uint8Array} exp - The expression to create the BlockId from.\n     *     It can be one of the following types:\n     *     - bigint: A BigInteger value that represents the BlockId.\n     *     - number: A number value that represents the BlockId.\n     *     - string: A string value that represents the BlockId.\n     *     - HexUInt: A HexUInt object that represents the BlockId.\n     *     - Uint8Array: A Uint8Array object that represents the BlockId.\n     *\n     * @returns {BlockId} - A new BlockId object created from the given expression.\n     *\n     * @throws {InvalidDataType} If the given expression is not a valid hexadecimal positive integer expression.\n     */\n    public static of(\n        exp: bigint | number | string | Uint8Array | HexUInt\n    ): BlockId {\n        try {\n            if (exp instanceof HexUInt) {\n                return new BlockId(exp);\n            }\n            return new BlockId(HexUInt.of(exp));\n        } catch (e) {\n            throw new InvalidDataType(\n                'BlockId.of',\n                'not a BlockId expression',\n                { exp: `${exp}` }, // Needed to serialize bigint values.\n                e\n            );\n        }\n    }\n}\n\n/**\n * This class is an alias of {@link BlockId} for back compatibility.\n */\nclass ThorId extends BlockId {\n    /**\n     * Constructs an instance of the class with the specified block ID.\n     *\n     * @param {BlockId} blockId - The unique identifier for the block.\n     */\n    protected constructor(blockId: BlockId) {\n        super(blockId);\n    }\n\n    /**\n     * See {@link BlockId.of}.\n     */\n    public static of(\n        exp: bigint | number | string | Uint8Array | HexUInt\n    ): ThorId {\n        return new ThorId(BlockId.of(exp));\n    }\n}\n\nexport { BlockId, ThorId };\n","import fastJsonStableStringify from 'fast-json-stable-stringify';\nimport { Address, Blake2b256, HexUInt, Txt } from '../vcdm';\nimport { Secp256k1 } from '../secp256k1';\nimport {\n    CertificateSignatureMismatch,\n    InvalidDataType\n} from '@vechain/sdk-errors';\nimport { type CertificateData } from './CertificateData';\n\n/**\n * The Certificate class provides functionality to create, sign, and verify certificates.\n * It implements the CertificateData interface.\n *\n * @remarks\n * The properties of those class are immutable, except {@link signature},\n * because properties are part of the {@link signature} computation.\n * The signature is used of extract and match the {@link signer}.\n * The fact the properties are immutable assure is not possible to create\n * an object tampering properties and carry on the legitimate signature and\n * signer address of the object before tampering to make tampered content\n * to result in a validated certificate.\n *\n * @remarks\n * Classes extending {@link Certificate} should expose immutable properties.\n *\n * @remarks\n * This class implementation supports {@link signer}\n * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).\n *\n * @implements CertificateData\n */\nclass Certificate implements CertificateData {\n    /**\n     * Return the intended use or context of the certificate.\n     */\n    readonly purpose: string;\n\n    /**\n     * Returns the content of the certificate.\n     */\n    readonly payload: {\n        /**\n         * Return the description of the type of content.\n         */\n        readonly type: string;\n        /**\n         * Return the content serialized as a string.\n         */\n        readonly content: string;\n    };\n\n    /**\n     * Return the description of the context of validity of this certificate.\n     */\n    readonly domain: string;\n\n    /**\n     * The value expressed as of milliseconds elapsed since the\n     * [epoch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#the_epoch_timestamps_and_invalid_date),\n     * when the certificate was issued.\n     *\n     * @remarks\n     * The value is a natural number in the safe integer range of JS `number` type.\n     */\n    readonly timestamp: number;\n\n    /**\n     * Return the address of the entity signed the certificate, as\n     * a lowercase hexadecimal expression prefixed by `0x`.\n     *\n     * @remarks\n     * Normalized lowercase prefixed expression is needed because\n     * the content of this property is part of the {@signature} computation:\n     * certificates made from checksum case address of the signer should\n     * result valid as the certificate made from the same signer address\n     * not checksum case.\n     */\n    readonly signer: string;\n\n    /**\n     * Return the signature computed evaluating the properties of this object\n     * and the private key of the signer.\n     *\n     * @remarks\n     * The signature is a lowercase hexadecimal expression prefixed with `0x`.\n     */\n    signature?: string;\n\n    /**\n     * Returns a new instance of this class assuring the formal validity of the\n     * arguments used to build the object.\n     *\n     * @param {string} purpose - The purpose of the certificate.\n     * @param {Object} payload - The payload containing type and content.\n     * @param {string} payload.type - The type of the payload.\n     * @param {string} payload.content - The content of the payload.\n     * @param {string} domain - The domain associated with the certificate.\n     * @param {number} timestamp - The time at which the certificate is created;\n     * must be a positive safe integer.\n     * @param {string} signer - The signer of the certificate;\n     * must be a valid address.\n     * @param {string|undefined} [signature] - The signature of the certificate;\n     * optional parameter.\n     *\n     * @throws {InvalidDataType} If timestamp is not a positive safe integer.\n     * @throws {InvalidDataType} If signer is not a valid address.\n     * @throws {InvalidDataType} If signature is invalid.\n     *\n     * @remarks\n     * The `signer` address is represented lowercase and `0x` prefixed.\n     */\n    protected constructor(\n        purpose: string,\n        payload: { type: string; content: string },\n        domain: string,\n        timestamp: number,\n        signer: string,\n        signature?: string\n    ) {\n        if (Number.isSafeInteger(timestamp) && timestamp >= 0) {\n            if (Address.isValid(signer)) {\n                this.purpose = purpose;\n                this.payload = payload;\n                this.domain = domain;\n                this.timestamp = timestamp;\n                this.signer = signer.toString().toLowerCase();\n                try {\n                    this.signature =\n                        typeof signature === 'string'\n                            ? HexUInt.of(signature).alignToBytes().toString()\n                            : signature;\n                } catch (e) {\n                    throw new InvalidDataType(\n                        'Certificate.constructor',\n                        'invalid signature',\n                        { signature },\n                        e\n                    );\n                }\n            } else\n                throw new InvalidDataType(\n                    'Certificate.constructor',\n                    'signer is not an address',\n                    { signer }\n                );\n        } else\n            throw new InvalidDataType(\n                'Certificate.constructor',\n                'not positive safe integer timestamp',\n                { timestamp }\n            );\n    }\n\n    /**\n     * Encodes a given object into a Uint8Array representation\n     * applying the following operation to normalize the content:\n     * - the properties are sorted in ascending alphabetic order;\n     * - the key/value properties are delimited with `\"` when serialized as JSON\n     *   before to be encoded as bytes;\n     * - any not meaningful blank characters are ignored;\n     * - the JSON representation of this object is byte encoded using the UTF-8\n     *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).\n     *\n     * @param {unknown} object - The input object to be encoded.\n     * @return {Uint8Array} The encoded Uint8Array representation of the input object.\n     */\n    protected static encode(object: unknown): Uint8Array {\n        return Txt.of(fastJsonStableStringify(object)).bytes;\n    }\n\n    /**\n     * Encodes the current certificate instance into a Uint8Array representation.\n     *\n     * @remarks\n     * This method normalizes the content by:\n     * - Sorting the properties in ascending alphabetic order.\n     * - Delimiting key/value properties with `\"` when serialized as JSON before encoding as bytes.\n     * - Ignoring any not meaningful blank characters.\n     * - Using the UTF-8 normalization form for canonical composition for byte encoding.\n     *\n     * @return {Uint8Array} The encoded Uint8Array representation of the current certificate instance.\n     */\n    public encode(): Uint8Array {\n        return Certificate.encode({ ...this, signature: undefined });\n    }\n\n    /**\n     * Return `true` if the current instance has a signature.\n     *\n     * @return {boolean} `true` if the signature is a valid hexadecimal string,\n     * otherwise `false`.\n     */\n    public isSigned(): boolean {\n        return (\n            typeof this.signature === 'string' &&\n            HexUInt.isValid(this.signature)\n        );\n    }\n\n    /**\n     * Creates a new Certificate instance from the provided CertificateData.\n     *\n     * @param {CertificateData} data - The data required to create the Certificate.\n     * @return {Certificate} A new Certificate instance.\n     * @throws {InvalidDataType} If the provided data is invalid:\n     * - if timestamp is not a positive safe integer;\n     * - if signer is not a valid address;\n     * - if signature is an invalid hexadecimal expression.\n     *\n     * @remarks\n     * This method supports {@link signer}\n     * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).\n     *\n     * @see constructor\n     */\n    public static of(data: CertificateData): Certificate {\n        try {\n            return new Certificate(\n                data.purpose,\n                data.payload,\n                data.domain,\n                data.timestamp,\n                data.signer,\n                data.signature\n            );\n        } catch (e) {\n            throw new InvalidDataType(\n                'Certificate.of',\n                'invalid certificate data',\n                { certifiable: data },\n                e\n            );\n        }\n    }\n\n    /**\n     * Signs the current object using a given private key.\n     *\n     * The {@link signature} is computed encoding this object according\n     * the following normalization rules:\n     * - the {@link signature} property is ignored, because its value\n     *   is the result of this method.\n     * - the properties are sorted in ascending alphabetic order;\n     * - the key/value properties are delimited with `\"` when serialized as JSON\n     *   before to be encoded as bytes;\n     * - any not meaningful blank characters are ignored;\n     * - the JSON representation of this object is byte encoded using the UTF-8\n     *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).\n     *\n     * @param {Uint8Array} privateKey - The private key used for signing.\n     * @return {this} The current instance after signing.\n     *\n     * @throws {InvalidOperation} - If a hash error occurs.\n     * @throws {InvalidSecp256k1PrivateKey} - If the private key is not a valid 32-byte private key.\n     *\n     * @remarks Security auditable method, depends on\n     * * {@link Blake2b256.of};\n     * * {@link Secp256k1.sign}.\n     *\n     * @see encode\n     * @see verify\n     */\n    public sign(privateKey: Uint8Array): this {\n        this.signature = undefined;\n        this.signature = HexUInt.of(\n            Secp256k1.sign(\n                Blake2b256.of(Certificate.encode(this)).bytes,\n                privateKey\n            )\n        ).toString();\n        return this;\n    }\n\n    /**\n     * Verifies the certificate by checking its signature.\n     *\n     * @throws {CertificateSignatureMismatch} if the certificate\n     * - is not signed, or\n     * - the signature does not match the signer's public key.\n     *\n     * @remarks\n     * This method supports {@link signer}\n     * [mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).\n     *\n     * @remarks Security auditable method, depends on\n     * * {@link Blake2b256.of};\n     * * {@link Secp256k1.recover}.\n     */\n    public verify(): void {\n        if (!this.isSigned())\n            throw new CertificateSignatureMismatch(\n                'Certificate.verify',\n                'signature missing',\n                { certificate: this }\n            );\n        const signer = Address.ofPublicKey(\n            Secp256k1.recover(\n                Blake2b256.of(\n                    Certificate.encode({ ...this, signature: undefined })\n                ).bytes,\n                HexUInt.of(this.signature as string).bytes\n            )\n        );\n        if (signer.toString().toLowerCase() !== this.signer)\n            throw new CertificateSignatureMismatch(\n                'Certificate.verify',\n                \"signature doesn't match with signer's public key\",\n                { certificate: this }\n            );\n    }\n}\n\nexport { Certificate };\n","/**\n * The [Scrypt](https://en.wikipedia.org/wiki/Scrypt) parameters\n * used in the keystore encryption.\n *\n * @property {number} N - The CPU/memory cost parameter = 2^17 = 131072.\n * @property {number} r - The block size parameter = 8.\n * @property {number} p - The parallelization parameter = 1.\n */\nconst SCRYPT_PARAMS = {\n    N: 131072,\n    r: 8,\n    p: 1\n};\n\nexport { SCRYPT_PARAMS };\n","/**\n * Implements the JSON Keystore v3 Wallet encryption, decryption, and validation functionality.\n */\nimport {\n    InvalidKeystore,\n    InvalidKeystoreParams,\n    stringifyData\n} from '@vechain/sdk-errors';\nimport { ethers } from 'ethers';\nimport { Secp256k1 } from '../../../secp256k1';\nimport { Address, HexUInt } from '../../../vcdm';\nimport { type Keystore, type KeystoreAccount } from '../../types';\nimport { SCRYPT_PARAMS } from './const';\n\n/**\n * Encrypts a given private key into a keystore format using the specified password.\n *\n * @param privateKey - The private key to be encrypted.\n * @param password - The password used for the encryption.\n * @returns A Promise that resolves to the encrypted keystore.\n */\nasync function encrypt(\n    privateKey: Uint8Array,\n    password: string\n): Promise<Keystore> {\n    // Public and Address are derived from a private key\n    const derivePublicKey = Secp256k1.derivePublicKey(privateKey);\n    const deriveAddress = Address.ofPublicKey(derivePublicKey).toString();\n\n    // Create keystore account compatible with ethers\n    const keystoreAccount: ethers.KeystoreAccount = {\n        address: deriveAddress,\n        privateKey: HexUInt.of(privateKey).toString()\n    };\n\n    // Scrypt options\n    const encryptOptions: ethers.EncryptOptions = {\n        scrypt: {\n            N: SCRYPT_PARAMS.N,\n            r: SCRYPT_PARAMS.r,\n            p: SCRYPT_PARAMS.p\n        }\n    };\n\n    // String version of keystore\n    const keystoreJsonString = await ethers.encryptKeystoreJson(\n        keystoreAccount,\n        password,\n        encryptOptions\n    );\n\n    return JSON.parse(keystoreJsonString) as Keystore;\n}\n\n/**\n * Decrypts a keystore to obtain the private key using the given password.\n *\n * @param keystore - The keystore containing the encrypted private key.\n * @param password - The password used to decrypt the keystore.\n * @returns A Promise that resolves to the decrypted KeystoreAccount or rejects if the keystore or password is invalid.\n * @throws {InvalidKeystore, InvalidKeystoreParams}\n */\nasync function decrypt(\n    keystore: Keystore,\n    password: string\n): Promise<KeystoreAccount> {\n    // Invalid keystore\n    if (!isValid(keystore)) {\n        throw new InvalidKeystore(\n            'keystore.decrypt()',\n            'Invalid keystore. Ensure the keystore is properly formatted and contains the necessary data.',\n            { keystore }\n        );\n    }\n\n    try {\n        return (await ethers.decryptKeystoreJson(\n            stringifyData(keystore),\n            password\n        )) as KeystoreAccount;\n    } catch {\n        throw new InvalidKeystoreParams(\n            'keystore.decrypt()',\n            'Decryption failed: Invalid Password for the given keystore.',\n            // @NOTE: We are not exposing the password in the error data for security reasons.\n            {\n                keystore\n            }\n        );\n    }\n}\n\n/**\n * Validates if the provided keystore adheres to the expected format and structure.\n *\n * @param keystore - The keystore to be validated.\n * @returns A boolean indicating whether the keystore is valid or not.\n */\nfunction isValid(keystore: Keystore): boolean {\n    return ethers.isKeystoreJson(stringifyData(keystore));\n}\n\n/**\n * Exports the keystore functions for encryption, decryption, and validation.\n */\nconst keystore = { encrypt, decrypt, isValid };\nexport { keystore };\n","/**\n * Implements the\n * [JSON Keystore v3 Wallet](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage)\n * encryption, decryption, and validation functionality.\n */\nimport * as n_utils from '@noble/curves/abstract/utils';\nimport { Address, Hex, Keccak256 } from '../../../vcdm';\nimport { InvalidKeystoreParams, stringifyData } from '@vechain/sdk-errors';\nimport { Secp256k1 } from '../../../secp256k1';\nimport { ctr } from '@noble/ciphers/aes';\nimport { scrypt } from '@noble/hashes/scrypt';\nimport { type Keystore, type KeystoreAccount } from '../../types';\n\n/**\n * The cryptographic algorithm used to store the private key in the\n * keystore is the\n * [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * [128 bits Counter Mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)\n * as defined by\n * [NIST AES Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\n *\n * @constant {string}\n */\nconst KEYSTORE_CRYPTO_CIPHER = 'aes-128-ctr';\n\n/**\n * The length of the key returned by the\n * [Scrypt](https://en.wikipedia.org/wiki/Scrypt)\n * [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * used in the keystore.\n */\nconst KEYSTORE_CRYPTO_PARAMS_DKLEN = 32;\n\n/**\n * The [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * of the keystore is [Scrypt](https://en.wikipedia.org/wiki/Scrypt).\n */\nconst KEYSTORE_CRYPTO_KDF = 'scrypt';\n\n/**\n * The version number of the\n * [Web3 Secret Storage Definition](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage)\n * specifications used in keystore.\n */\nconst KEYSTORE_VERSION = 3;\n\n/**\n * The [Scrypt](https://en.wikipedia.org/wiki/Scrypt) parameters\n * used in the keystore encryption.\n *\n * @property {number} N - The CPU/memory cost parameter = 2^17 = 131072.\n * @property {number} r - The block size parameter = 8.\n * @property {number} p - The parallelization parameter = 1.\n */\nconst SCRYPT_PARAMS = {\n    N: 131072,\n    r: 8,\n    p: 1\n};\n\n/**\n * EncryptOptions interface defines the options of the\n * [Scrypt](https://en.wikipedia.org/wiki/Scrypt) algorithm for the\n * [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * used in keystore encryption.\n *\n * @property {Uint8Array} iv - Initialization Vector.\n * @property {Uint8Array} salt - Random bytes to protect against [Rainbow table](https://en.wikipedia.org/wiki/Rainbow_table).\n * @property {number} scrypt.N - CPU/memory cost parameter.\n * @property {number} scrypt.p - Parallelization parameter.\n * @property {number} scrypt.r - Block size parameter.\n *\n * @see {encodeScryptParams}\n */\ninterface EncryptOptions {\n    iv?: Uint8Array;\n    salt?: Uint8Array;\n    uuid?: Uint8Array;\n    scrypt?: {\n        N?: number;\n        p?: number;\n        r?: number;\n    };\n}\n\n/**\n * ScryptParams interfaces defines the parameters of the\n * [Scrypt](https://en.wikipedia.org/wiki/Scrypt) algorithm for the\n * [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * used in keystore encryption.\n *\n * Compatible with\n * [ethers ScryptParams](https://github.com/ethers-io/ethers.js/blob/main/src.ts/wallet/json-keystore.ts).\n *\n * @property {number} N - CPU/memory cost parameter.\n * @property {number} dkLen - Derived key length in bytes.\n * @property {string} name - constant \"scrypt\".\n * @property {number} p - Parallelization parameter.\n * @property {number} r - Block size parameter.\n * @property {Uint8Array} salt - Random bytes to protect against [Rainbow table](https://en.wikipedia.org/wiki/Rainbow_table).\n */\ninterface ScryptParams {\n    N: number;\n    dkLen: number;\n    name: string;\n    p: number;\n    r: number;\n    salt: Uint8Array;\n}\n\n/**\n * Retrieves the\n * [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * parameters from the given keystore.\n *\n * Only [Scrypt](https://en.wikipedia.org/wiki/Scrypt) is supported as key-derivation function.\n * [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) superseded by Scrypt, hence\n * not implemented.\n *\n * @param {Keystore} keystore - The key store object.\n * @returns {ScryptParams} - The decryption key-derivation function parameters.\n * @throws {InvalidKeystoreParams}\n *\n * @see {decryptKeystore}\n * @see {encodeScryptParams}\n */\nfunction decodeScryptParams(keystore: Keystore): ScryptParams {\n    const salt = n_utils.hexToBytes(keystore.crypto.kdfparams.salt);\n    const N = keystore.crypto.kdfparams.n;\n    const r = keystore.crypto.kdfparams.r;\n    const p: number = keystore.crypto.kdfparams.p;\n    // Make sure N is a power of 2\n    if (N <= 0 || (N & (N - 1)) !== 0)\n        throw new InvalidKeystoreParams(\n            '(EXPERIMENTAL) keystore.decodeScryptParams()',\n            'Decryption failed: invalid  keystore.crypto.kdfparams.n parameter.',\n            {\n                keystore,\n                N\n            }\n        );\n\n    // Make sure r and p are positive\n    if (r <= 0 || p <= 0)\n        throw new InvalidKeystoreParams(\n            '(EXPERIMENTAL) keystore.decodeScryptParams()',\n            'Decryption failed: both keystore.crypto.kdfparams.r or keystore.crypto.kdfparams.p parameter must be > 0.',\n            {\n                keystore,\n                r,\n                p\n            }\n        );\n    const dkLen = keystore.crypto.kdfparams.dklen;\n\n    if (dkLen !== KEYSTORE_CRYPTO_PARAMS_DKLEN)\n        throw new InvalidKeystoreParams(\n            '(EXPERIMENTAL) keystore.decodeScryptParams()',\n            `Decryption failed: keystore.crypto.kdfparams.dklen parameter must be ${KEYSTORE_CRYPTO_PARAMS_DKLEN}`,\n            {\n                keystore,\n                dkLen\n            }\n        );\n\n    return {\n        N,\n        dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,\n        name: KEYSTORE_CRYPTO_KDF,\n        p,\n        r,\n        salt\n    } satisfies ScryptParams;\n}\n\n/**\n * Encodes the parameters of the\n * [Scrypt](https://en.wikipedia.org/wiki/Scrypt) algorithm of the\n * [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * used in the keystore encryption.\n *\n * @param {EncryptOptions} options - The encryption options used to override\n * the default Scrypt parameters:\n * - N: CPU/memory cost,\n * - p: Parallelization parameter,\n * - r: Block size parameter.\n * @returns {ScryptParams} - The encoded scrypt parameters.\n * @throws {InvalidKeystoreParams}\n *\n * @see {decodeScryptParams}\n * @see {encryptKeystore}\n */\nfunction encodeScryptParams(options: EncryptOptions): ScryptParams {\n    // Use or generate the salt.\n    const salt =\n        options.salt ?? Secp256k1.randomBytes(KEYSTORE_CRYPTO_PARAMS_DKLEN);\n    // Override the scrypt password-based key derivation function parameters,\n    let N = SCRYPT_PARAMS.N;\n    let r = SCRYPT_PARAMS.r;\n    let p = SCRYPT_PARAMS.p;\n    if (options.scrypt != null) {\n        if (options.scrypt.N != null) {\n            N = options.scrypt.N;\n        }\n        if (options.scrypt.r != null) {\n            r = options.scrypt.r;\n        }\n        if (options.scrypt.p != null) {\n            p = options.scrypt.p;\n        }\n    }\n\n    if (N <= 0 || (BigInt(N) & BigInt(N - 1)) !== BigInt(0))\n        throw new InvalidKeystoreParams(\n            '(EXPERIMENTAL) keystore.encodeScryptParams()',\n            'Encryption failed: invalid options.scrypt.N parameter.',\n            {\n                options,\n                N\n            }\n        );\n\n    if (r <= 0 || !Number.isSafeInteger(r))\n        throw new InvalidKeystoreParams(\n            '(EXPERIMENTAL) keystore.encodeScryptParams()',\n            'Encryption failed: invalid options.scrypt.r parameter.',\n            {\n                options,\n                r\n            }\n        );\n\n    if (p <= 0 || !Number.isSafeInteger(p))\n        throw new InvalidKeystoreParams(\n            '(EXPERIMENTAL) keystore.encodeScryptParams()',\n            'Encryption failed: invalid options.scrypt.p parameter.',\n            {\n                options,\n                p\n            }\n        );\n\n    return {\n        name: KEYSTORE_CRYPTO_KDF,\n        dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,\n        N,\n        p,\n        r,\n        salt\n    } satisfies ScryptParams;\n}\n\n/**\n * Encrypts a private key with a password to returns a keystore object\n * compliant with [Web3 Secret Storage Definition](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * version 3.\n *\n * The private key is encoded using the\n * [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * [128 bits Counter Mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)\n * as defined by\n * [NIST AES Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\n *\n * The [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * algorithm is [Scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * Secure audit function.\n * - {@link encryptKeystore}.\n * - `password` wiped after use.\n * - `privateKey` wiped after use.\n *\n * @param {Uint8Array} privateKey - The private key to encrypt, the memory location is wiped after use.\n * @param {Uint8Array} password - The password to use for encryption, the memory location is wiped after use.\n * @returns {Keystore} - The encrypted keystore object.\n * @throws {InvalidKeystoreParams}\n *\n * @see {encryptKeystore}\n *\n * @remarks **The private key must not be represented as string to avoid the\n * [Memory Dumping](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#memory-dumping)\n * attack**.\n */\nfunction encrypt(privateKey: Uint8Array, password: Uint8Array): Keystore {\n    return encryptKeystore(privateKey, password, {\n        scrypt: {\n            N: SCRYPT_PARAMS.N,\n            r: SCRYPT_PARAMS.r,\n            p: SCRYPT_PARAMS.p\n        }\n    });\n}\n\n/**\n * Encrypts a private key with a password to returns a keystore object compliant with\n * [Web3 Secret Storage Definition](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * version {@link KEYSTORE_VERSION}.\n *\n * The private key is encoded using the\n * [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * [128 bits Counter Mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)\n * as defined by\n * [NIST AES Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf).\n *\n * The [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * algorithm is [Scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * Secure audit function.\n * - [ctr](https://github.com/paulmillr/noble-ciphers?tab=readme-ov-file#aes).\n * - {@link Keccak256.of}\n * - `password` wiped after use.\n * - `privateKey` wiped after use.\n * - {@link Secp256k1.derivePublicKey}.\n * - {@link Secp256k1.randomBytes}.\n * - [scrypt](https://github.com/paulmillr/noble-hashes/?tab=readme-ov-file#scrypt).\n *\n * @param privateKey - The private key to encrypt, the memory location is wiped after use.\n * @param password - The password to use for encryption, the memory location is wiped after use.\n * @param options - Parameters used to configure the **AES** encryption of the private key and the **Scrypt** derivation key function.\n * @returns {Keystore} - The encrypted keystore object.\n * @throws {InvalidKeystoreParams}\n *\n * @remarks **The private key must not be represented as string to avoid the\n * [Memory Dumping](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#memory-dumping)\n * attack**.\n *\n * @see {encrypt}\n * @see {uuidV4}\n */\nfunction encryptKeystore(\n    privateKey: Uint8Array,\n    password: Uint8Array,\n    options: EncryptOptions\n): Keystore {\n    try {\n        const kdf = encodeScryptParams(options);\n        const key = scrypt(password, kdf.salt, {\n            N: kdf.N,\n            r: kdf.r,\n            p: kdf.p,\n            dkLen: kdf.dkLen\n        });\n        // Override initialization vector.\n        const iv = options.iv ?? Secp256k1.randomBytes(16);\n        if (iv.length !== 16)\n            throw new InvalidKeystoreParams(\n                '(EXPERIMENTAL) keystore.encryptKeystore()',\n                'Encryption failed: invalid options.iv length.',\n                { iv }\n            );\n\n        // Override the uuid.\n        const uuidRandom = options.uuid ?? Secp256k1.randomBytes(16);\n\n        if (uuidRandom.length !== 16)\n            throw new InvalidKeystoreParams(\n                '(EXPERIMENTAL) keystore.encryptKeystore()',\n                'Encryption failed: invalid options.uuid length.',\n                { uuidRandom }\n            );\n\n        // Message Authentication Code prefix.\n        const macPrefix = key.slice(16, 32);\n        // Encrypt the private key: 32 bytes for the Web3 Secret Storage (derivedKey, macPrefix)\n        const ciphertext = ctr(key.slice(0, 16), iv).encrypt(privateKey);\n        return {\n            address: Address.ofPrivateKey(privateKey).toString(),\n            crypto: {\n                cipher: KEYSTORE_CRYPTO_CIPHER,\n                cipherparams: {\n                    iv: Hex.of(iv).digits\n                },\n                ciphertext: Hex.of(ciphertext).digits,\n                kdf: 'scrypt',\n                kdfparams: {\n                    dklen: KEYSTORE_CRYPTO_PARAMS_DKLEN,\n                    n: kdf.N,\n                    p: kdf.p,\n                    r: kdf.r,\n                    salt: Hex.of(kdf.salt).digits\n                },\n                // Compute the message authentication code, used to check the password.\n                mac: Keccak256.of(n_utils.concatBytes(macPrefix, ciphertext))\n                    .digits\n            },\n            id: uuidV4(uuidRandom),\n            version: KEYSTORE_VERSION\n        } satisfies Keystore;\n    } finally {\n        privateKey.fill(0); // Clear the private key from memory.\n        password.fill(0); // Clear the password from memory.\n    }\n}\n\n/**\n * Decrypts a keystore compliant with\n * [Web3 Secret Storage Definition](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * version 3, using the given password to obtain the private key and wallet address.\n *\n * **WARNING:** call\n * ```javascript\n * privateKey.fill(0)\n * ```\n * after use to avoid to invalidate any security audit and certification granted to this code.\n *\n * The private key should be encoded using the\n * [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * [128 bits Counter Mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)\n * as defined by\n * [NIST AES Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf),\n * any different encryption not supported.\n *\n * The [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * algorithm should be [Scrypt](https://en.wikipedia.org/wiki/Scrypt),\n * any different KDF function not supported.\n *\n * Secure audit function.\n * - {@link decryptKeystore}\n *\n * @param {Keystore} keystore - The keystore object to decrypt.\n * @param {Uint8Array} password - The password used for decryption, wiped after use.\n * @return {KeystoreAccount} - The decrypted keystore account object.\n *\n * @see {decryptKeystore}\n * @see {isValid}\n */\nfunction decrypt(keystore: Keystore, password: Uint8Array): KeystoreAccount {\n    return decryptKeystore(keystore, password);\n}\n\n/**\n * Decrypts a keystore compliant with\n * [Web3 Secret Storage Definition](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * using the given password to obtain the private key and wallet address.\n *\n * **WARNING:** call\n * ```javascript\n * privateKey.fill(0)\n * ```\n * after use to avoid to invalidate any security audit and certification granted to this code.\n *\n * The private key should be encoded using the\n * [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * [128 bits Counter Mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)\n * as defined by\n * [NIST AES Recommendation for Block Cipher Modes of Operation](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf),\n * any different encryption not supported.\n *\n * The [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function)\n * algorithm should be [Scrypt](https://en.wikipedia.org/wiki/Scrypt),\n * any different KDF function not supported.\n *\n * Secure audit function.\n * - {@link Address.ofPrivateKey}\n * - [ctr](https://github.com/paulmillr/noble-ciphers?tab=readme-ov-file#aes).\n * - `password` wiped after use.\n * - [scrypt](https://github.com/paulmillr/noble-hashes/?tab=readme-ov-file#scrypt).\n *\n * @param {Keystore} keystore - The keystore object to decrypt.\n * @param {Uint8Array} password - The password used for decryption, wiped after use.\n * @return {KeystoreAccount} - The decrypted keystore account object.\n * @throws {InvalidKeystoreParams}\n *\n * @see {decodeScryptParams}\n * @see {decrypt}\n */\nfunction decryptKeystore(\n    keystore: Keystore,\n    password: Uint8Array\n): KeystoreAccount {\n    try {\n        if (keystore.crypto.cipher.toLowerCase() !== KEYSTORE_CRYPTO_CIPHER)\n            throw new InvalidKeystoreParams(\n                '(EXPERIMENTAL) keystore.decryptKeystore()',\n                'Decryption failed: unsupported crypto cipher algorithm.',\n                { cipher: keystore.crypto.cipher.toLowerCase() }\n            );\n\n        if (keystore.crypto.kdf.toLowerCase() !== KEYSTORE_CRYPTO_KDF)\n            throw new InvalidKeystoreParams(\n                '(EXPERIMENTAL) keystore.decryptKeystore()',\n                'Decryption failed: unsupported crypto key derivation function.',\n                { keyDerivationFunction: keystore.crypto.kdf.toLowerCase() }\n            );\n\n        if (keystore.version !== KEYSTORE_VERSION)\n            throw new InvalidKeystoreParams(\n                '(EXPERIMENTAL) keystore.decryptKeystore()',\n                'Decryption failed: unsupported keystore version.',\n                { version: keystore.version }\n            );\n\n        const kdf = decodeScryptParams(keystore);\n        const key = scrypt(password, kdf.salt, {\n            N: kdf.N,\n            r: kdf.r,\n            p: kdf.p,\n            dkLen: kdf.dkLen\n        });\n        const ciphertext = n_utils.hexToBytes(keystore.crypto.ciphertext);\n        if (\n            keystore.crypto.mac !==\n            Keccak256.of(n_utils.concatBytes(key.slice(16, 32), ciphertext))\n                .digits\n        ) {\n            throw new InvalidKeystoreParams(\n                '(EXPERIMENTAL) keystore.decryptKeystore()',\n                'Decryption failed: Invalid Password for the given keystore.',\n                // @NOTE: We are not exposing the password in the error data for security reasons.\n                {\n                    keystore\n                }\n            );\n        }\n        const privateKey = ctr(\n            key.slice(0, 16),\n            n_utils.hexToBytes(keystore.crypto.cipherparams.iv)\n        ).decrypt(ciphertext);\n        const address = Address.ofPrivateKey(privateKey).toString();\n        if (\n            keystore.address !== '' &&\n            address !== Address.checksum(Hex.of(keystore.address))\n        ) {\n            throw new InvalidKeystoreParams(\n                '(EXPERIMENTAL) keystore.decryptKeystore()',\n                'Decryption failed: address/password mismatch.',\n                { keystoreAddress: keystore.address }\n            );\n        }\n        return {\n            address,\n            // @note: Convert the private key to a string to be compatible with ethers\n            privateKey: Hex.of(privateKey).toString()\n        } satisfies KeystoreAccount;\n    } finally {\n        password.fill(0); // Clear the password from memory.\n    }\n}\n\n/**\n * Checks if a given keystore object is valid parsing its JSON representation\n * to catch any parsing errors, only valid\n * [Web3 Secret Storage Definition](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * version 3 keystore are accepted, using\n * [Advanced Encryption Standard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * [128 bits Counter Mode](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation)\n * to encrypt the private key and using\n * [Scrypt](https://en.wikipedia.org/wiki/Scrypt) as\n * [Key Derivation Function](https://en.wikipedia.org/wiki/Key_derivation_function).\n *\n * @param {Keystore} keystore - The keystore object to validate.\n * @return {boolean} Returns true if the keystore is valid, false otherwise.\n */\nfunction isValid(keystore: Keystore): boolean {\n    try {\n        const copy = JSON.parse(stringifyData(keystore)) as Keystore;\n        if (\n            copy.crypto.cipher.toLowerCase() === KEYSTORE_CRYPTO_CIPHER &&\n            copy.crypto.kdf.toLowerCase() === KEYSTORE_CRYPTO_KDF &&\n            copy.version === KEYSTORE_VERSION\n        ) {\n            return true;\n        }\n    } catch {\n        // intentionally left empty to return false if parsing fails\n    } // Return false if parsing fails.\n    return false;\n}\n\n/**\n * Generates a version 4\n * [UUID (Universally Unique Identifier)](https://en.wikipedia.org/wiki/Universally_unique_identifier)\n * based on the given bytes.\n *\n * @param {Uint8Array} bytes - The byte array used to generate the UUID.\n * @returns {string} The generated UUID.\n */\nfunction uuidV4(bytes: Uint8Array): string {\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    const value = Hex.of(bytes).digits;\n    return [\n        value.substring(0, 8),\n        value.substring(8, 12),\n        value.substring(12, 16),\n        value.substring(16, 20),\n        value.substring(20, 32)\n    ].join('-');\n}\n\n/**\n * Exports the keystore functions for encryption, decryption, and validation.\n */\nexport const keystore = { decrypt, encrypt, isValid };\n","import { VeChainSDKLogger } from '@vechain/sdk-logging';\nimport { Txt } from '../vcdm';\nimport { keystoreEthers, keystoreExperimental } from './cryptography';\nimport { type Keystore, type KeystoreAccount } from './types';\n\n/**\n * A boolean indicating whether the keystore cryptography is experimental or not.\n */\nlet EXPERIMENTAL_CRYPTOGRAPHY: boolean = false;\n\n/**\n * Sets the keystore cryptography to experimental mode.\n *\n * @param experimentalCryptography - A boolean indicating whether the keystore cryptography is experimental or not.\n */\nfunction useExperimentalCryptography(experimentalCryptography: boolean): void {\n    EXPERIMENTAL_CRYPTOGRAPHY = experimentalCryptography;\n}\n\n/**\n * Encrypts a given private key into a keystore format using the specified password.\n *\n * @param privateKey - The private key to be encrypted.\n * @param password - The password used for the encryption.\n * @returns A Promise that resolves to the encrypted keystore.\n */\nasync function encrypt(\n    privateKey: Uint8Array,\n    password: string\n): Promise<Keystore> {\n    if (EXPERIMENTAL_CRYPTOGRAPHY)\n        VeChainSDKLogger('warning').log({\n            title: `Experimental cryptography`,\n            messages: [\n                `Remember, you are using an experimental cryptography library.`,\n                'functions: keystore.encrypt'\n            ]\n        });\n\n    return EXPERIMENTAL_CRYPTOGRAPHY\n        ? keystoreExperimental.encrypt(privateKey, Txt.of(password).bytes)\n        : await keystoreEthers.encrypt(privateKey, password);\n}\n\n/**\n * Decrypts a keystore to obtain the private key using the given password.\n *\n * @throws {InvalidKeystoreError, InvalidKeystorePasswordError}\n * @param keystore - The keystore containing the encrypted private key.\n * @param password - The password used to decrypt the keystore.\n * @returns A Promise that resolves to the decrypted KeystoreAccount or rejects if the keystore or password is invalid.\n */\nasync function decrypt(\n    keystore: Keystore,\n    password: string\n): Promise<KeystoreAccount> {\n    if (EXPERIMENTAL_CRYPTOGRAPHY)\n        VeChainSDKLogger('warning').log({\n            title: `Experimental cryptography`,\n            messages: [\n                `Remember, you are using an experimental cryptography library.`,\n                'functions: keystore.decrypt'\n            ]\n        });\n\n    return EXPERIMENTAL_CRYPTOGRAPHY\n        ? keystoreExperimental.decrypt(keystore, Txt.of(password).bytes)\n        : await keystoreEthers.decrypt(keystore, password);\n}\n\n/**\n * Validates if the provided keystore adheres to the expected format and structure.\n *\n * @param keystore - The keystore to be validated.\n * @returns A boolean indicating whether the keystore is valid or not.\n */\nfunction isValid(keystore: Keystore): boolean {\n    if (EXPERIMENTAL_CRYPTOGRAPHY)\n        VeChainSDKLogger('warning').log({\n            title: `Experimental cryptography`,\n            messages: [\n                `Remember, you are using an experimental cryptography library.`,\n                'functions: keystore.isValid'\n            ]\n        });\n\n    return EXPERIMENTAL_CRYPTOGRAPHY\n        ? keystoreExperimental.isValid(keystore)\n        : keystoreEthers.isValid(keystore);\n}\n\n/**\n * Exports the keystore functions for encryption, decryption, and validation.\n */\nconst keystore = { encrypt, decrypt, isValid, useExperimentalCryptography };\nexport { keystore };\n","/**\n * ABI of the ERC20 token standard.\n *\n * @see [EIP 20](https://eips.ethereum.org/EIPS/eip-20)\n */\nconst ERC20_ABI = [\n    { inputs: [], stateMutability: 'nonpayable', type: 'constructor' },\n    {\n        inputs: [\n            { internalType: 'address', name: 'spender', type: 'address' },\n            { internalType: 'uint256', name: 'allowance', type: 'uint256' },\n            { internalType: 'uint256', name: 'needed', type: 'uint256' }\n        ],\n        name: 'ERC20InsufficientAllowance',\n        type: 'error'\n    },\n    {\n        inputs: [\n            { internalType: 'address', name: 'sender', type: 'address' },\n            { internalType: 'uint256', name: 'balance', type: 'uint256' },\n            { internalType: 'uint256', name: 'needed', type: 'uint256' }\n        ],\n        name: 'ERC20InsufficientBalance',\n        type: 'error'\n    },\n    {\n        inputs: [\n            { internalType: 'address', name: 'approver', type: 'address' }\n        ],\n        name: 'ERC20InvalidApprover',\n        type: 'error'\n    },\n    {\n        inputs: [\n            { internalType: 'address', name: 'receiver', type: 'address' }\n        ],\n        name: 'ERC20InvalidReceiver',\n        type: 'error'\n    },\n    {\n        inputs: [{ internalType: 'address', name: 'sender', type: 'address' }],\n        name: 'ERC20InvalidSender',\n        type: 'error'\n    },\n    {\n        inputs: [{ internalType: 'address', name: 'spender', type: 'address' }],\n        name: 'ERC20InvalidSpender',\n        type: 'error'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'owner',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'spender',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'value',\n                type: 'uint256'\n            }\n        ],\n        name: 'Approval',\n        type: 'event'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'value',\n                type: 'uint256'\n            }\n        ],\n        name: 'Transfer',\n        type: 'event'\n    },\n    {\n        inputs: [\n            { internalType: 'address', name: 'owner', type: 'address' },\n            { internalType: 'address', name: 'spender', type: 'address' }\n        ],\n        name: 'allowance',\n        outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            { internalType: 'address', name: 'spender', type: 'address' },\n            { internalType: 'uint256', name: 'value', type: 'uint256' }\n        ],\n        name: 'approve',\n        outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [{ internalType: 'address', name: 'account', type: 'address' }],\n        name: 'balanceOf',\n        outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [],\n        name: 'decimals',\n        outputs: [{ internalType: 'uint8', name: '', type: 'uint8' }],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [],\n        name: 'name',\n        outputs: [{ internalType: 'string', name: '', type: 'string' }],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [],\n        name: 'symbol',\n        outputs: [{ internalType: 'string', name: '', type: 'string' }],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [],\n        name: 'totalSupply',\n        outputs: [{ internalType: 'uint256', name: '', type: 'uint256' }],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            { internalType: 'address', name: 'to', type: 'address' },\n            { internalType: 'uint256', name: 'value', type: 'uint256' }\n        ],\n        name: 'transfer',\n        outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            { internalType: 'address', name: 'from', type: 'address' },\n            { internalType: 'address', name: 'to', type: 'address' },\n            { internalType: 'uint256', name: 'value', type: 'uint256' }\n        ],\n        name: 'transferFrom',\n        outputs: [{ internalType: 'bool', name: '', type: 'bool' }],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    }\n] as const;\n\n/**\n * ABI of the ERC721 token standard.\n *\n * @see [EIP 721](https://eips.ethereum.org/EIPS/eip-721)\n */\nconst ERC721_ABI = [\n    {\n        inputs: [],\n        stateMutability: 'nonpayable',\n        type: 'constructor'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'sender',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            },\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address'\n            }\n        ],\n        name: 'ERC721IncorrectOwner',\n        type: 'error'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'ERC721InsufficientApproval',\n        type: 'error'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'approver',\n                type: 'address'\n            }\n        ],\n        name: 'ERC721InvalidApprover',\n        type: 'error'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            }\n        ],\n        name: 'ERC721InvalidOperator',\n        type: 'error'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address'\n            }\n        ],\n        name: 'ERC721InvalidOwner',\n        type: 'error'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'receiver',\n                type: 'address'\n            }\n        ],\n        name: 'ERC721InvalidReceiver',\n        type: 'error'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'sender',\n                type: 'address'\n            }\n        ],\n        name: 'ERC721InvalidSender',\n        type: 'error'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'ERC721NonexistentToken',\n        type: 'error'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'owner',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'approved',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'Approval',\n        type: 'event'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'owner',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                internalType: 'bool',\n                name: 'approved',\n                type: 'bool'\n            }\n        ],\n        name: 'ApprovalForAll',\n        type: 'event'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'Transfer',\n        type: 'event'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'approve',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address'\n            }\n        ],\n        name: 'balanceOf',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'getApproved',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'owner',\n                type: 'address'\n            },\n            {\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            }\n        ],\n        name: 'isApprovedForAll',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'receiver',\n                type: 'address'\n            }\n        ],\n        name: 'mintItem',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256'\n            }\n        ],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [],\n        name: 'name',\n        outputs: [\n            {\n                internalType: 'string',\n                name: '',\n                type: 'string'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'ownerOf',\n        outputs: [\n            {\n                internalType: 'address',\n                name: '',\n                type: 'address'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'safeTransferFrom',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            },\n            {\n                internalType: 'bytes',\n                name: 'data',\n                type: 'bytes'\n            }\n        ],\n        name: 'safeTransferFrom',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            },\n            {\n                internalType: 'bool',\n                name: 'approved',\n                type: 'bool'\n            }\n        ],\n        name: 'setApprovalForAll',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'bytes4',\n                name: 'interfaceId',\n                type: 'bytes4'\n            }\n        ],\n        name: 'supportsInterface',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [],\n        name: 'symbol',\n        outputs: [\n            {\n                internalType: 'string',\n                name: '',\n                type: 'string'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'tokenURI',\n        outputs: [\n            {\n                internalType: 'string',\n                name: '',\n                type: 'string'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'tokenId',\n                type: 'uint256'\n            }\n        ],\n        name: 'transferFrom',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    }\n] as const;\n\n/**\n * ABI of the ERC1155 token standard.\n *\n * @see [EIP 1155](https://eips.ethereum.org/EIPS/eip-1155)\n */\nconst ERC1155_ABI = [\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'account',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                internalType: 'bool',\n                name: 'approved',\n                type: 'bool'\n            }\n        ],\n        name: 'ApprovalForAll',\n        type: 'event'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                internalType: 'uint256[]',\n                name: 'ids',\n                type: 'uint256[]'\n            },\n            {\n                indexed: false,\n                internalType: 'uint256[]',\n                name: 'values',\n                type: 'uint256[]'\n            }\n        ],\n        name: 'TransferBatch',\n        type: 'event'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                indexed: true,\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'id',\n                type: 'uint256'\n            },\n            {\n                indexed: false,\n                internalType: 'uint256',\n                name: 'value',\n                type: 'uint256'\n            }\n        ],\n        name: 'TransferSingle',\n        type: 'event'\n    },\n    {\n        anonymous: false,\n        inputs: [\n            {\n                indexed: false,\n                internalType: 'string',\n                name: 'value',\n                type: 'string'\n            },\n            {\n                indexed: true,\n                internalType: 'uint256',\n                name: 'id',\n                type: 'uint256'\n            }\n        ],\n        name: 'URI',\n        type: 'event'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'account',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'id',\n                type: 'uint256'\n            }\n        ],\n        name: 'balanceOf',\n        outputs: [\n            {\n                internalType: 'uint256',\n                name: '',\n                type: 'uint256'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address[]',\n                name: 'accounts',\n                type: 'address[]'\n            },\n            {\n                internalType: 'uint256[]',\n                name: 'ids',\n                type: 'uint256[]'\n            }\n        ],\n        name: 'balanceOfBatch',\n        outputs: [\n            {\n                internalType: 'uint256[]',\n                name: '',\n                type: 'uint256[]'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'account',\n                type: 'address'\n            },\n            {\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            }\n        ],\n        name: 'isApprovedForAll',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256[]',\n                name: 'ids',\n                type: 'uint256[]'\n            },\n            {\n                internalType: 'uint256[]',\n                name: 'amounts',\n                type: 'uint256[]'\n            },\n            {\n                internalType: 'bytes',\n                name: 'data',\n                type: 'bytes'\n            }\n        ],\n        name: 'safeBatchTransferFrom',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'from',\n                type: 'address'\n            },\n            {\n                internalType: 'address',\n                name: 'to',\n                type: 'address'\n            },\n            {\n                internalType: 'uint256',\n                name: 'id',\n                type: 'uint256'\n            },\n            {\n                internalType: 'uint256',\n                name: 'amount',\n                type: 'uint256'\n            },\n            {\n                internalType: 'bytes',\n                name: 'data',\n                type: 'bytes'\n            }\n        ],\n        name: 'safeTransferFrom',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'address',\n                name: 'operator',\n                type: 'address'\n            },\n            {\n                internalType: 'bool',\n                name: 'approved',\n                type: 'bool'\n            }\n        ],\n        name: 'setApprovalForAll',\n        outputs: [],\n        stateMutability: 'nonpayable',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'bytes4',\n                name: 'interfaceId',\n                type: 'bytes4'\n            }\n        ],\n        name: 'supportsInterface',\n        outputs: [\n            {\n                internalType: 'bool',\n                name: '',\n                type: 'bool'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    },\n    {\n        inputs: [\n            {\n                internalType: 'uint256',\n                name: 'id',\n                type: 'uint256'\n            }\n        ],\n        name: 'uri',\n        outputs: [\n            {\n                internalType: 'string',\n                name: '',\n                type: 'string'\n            }\n        ],\n        stateMutability: 'view',\n        type: 'function'\n    }\n] as const;\n\n/**\n * ABI of the VIP180 token standard.\n *\n * @see [VIP 180](https://github.com/vechain/VIPs/blob/master/vips/VIP-180.md)\n */\nconst VIP180_ABI = ERC20_ABI;\n\n/**\n * ABI of the VIP181 token standard.\n *\n * @see [VIP 181](https://github.com/vechain/VIPs/blob/master/vips/VIP-181.md)\n */\nconst VIP181_ABI = ERC721_ABI;\n\n/**\n * ABI of the VIP210 token standard.\n *\n * @see [VIP 210](https://github.com/vechain/VIPs/blob/master/vips/VIP-210.md)\n */\nconst VIP210_ABI = ERC1155_ABI;\n\nexport {\n    VIP180_ABI,\n    VIP181_ABI,\n    VIP210_ABI,\n    ERC20_ABI,\n    ERC721_ABI,\n    ERC1155_ABI\n};\n","/**\n * Create a Uint8Array filled with zero bytes of the specified size.\n *\n * @param {number} size - The size of the Uint8Array to create.\n * @returns {Uint8Array} - A Uint8Array filled with zero bytes.\n */\nconst ZERO_BYTES = (size: number): Uint8Array => new Uint8Array(size);\n\n/**\n * Regular expression for matching numeric values expressed as base 10 strings.\n *\n * The regular expression matches the following numeric patterns:\n *    - Whole numbers:\n *      - Positive whole numbers: 1, 2, 3, ...\n *      - Negative whole numbers: -1, -2, -3, ...\n *    - Decimal numbers:\n *      - Positive decimal numbers: 1.0, 2.5, 3.14, ...\n *      - Negative decimal numbers: -1.0, -2.5, -3.14, ...\n *      - Decimal numbers without whole part:\n *        - Positive decimal numbers: .1, .5, .75, ...\n *        - Negative decimal numbers: -.1, -.5, -.75, ...\n *\n * @constant {RegExp} NUMERIC_REGEX\n */\nconst NUMERIC_REGEX = /(^-?\\d+(\\.\\d+)?)$|(^-?\\.\\d+)$/;\n\nexport { NUMERIC_REGEX, ZERO_BYTES };\n","import * as nc_utils from '@noble/curves/abstract/utils';\nimport { InvalidDataType } from '@vechain/sdk-errors';\nimport { Hex } from '../../vcdm/Hex';\nimport { Txt } from '../../vcdm/Txt';\nimport { ZERO_BYTES } from '../const';\n\n/**\n * Decodes a hexadecimal string representing a bytes32 value into a string.\n * The bytes32 string can be padded with zeros to the left or right.\n * An example of usage is to decode a bytes32 string returned by a smart contract function.\n *\n * @param {string} hex - The hexadecimal string to decode.\n * @returns {string} - The decoded string value.\n * @throws {InvalidDataType}\n */\nconst decodeBytes32String = (hex: string): string => {\n    if (!Hex.isValid(hex) || Hex.of(hex).digits.length !== 64)\n        throw new InvalidDataType(\n            'dataUtils.decodeBytes32String()',\n            `Failed to decode value ${hex} to string. Value is not a valid hex string or it is not 64 characters long`,\n            { value: hex }\n        );\n\n    const valueInBytes = Hex.of(hex).bytes;\n    // Find the first zero byte.\n    const firstZeroIndex = valueInBytes.findIndex((byte) => byte === 0);\n    // If the first byte is zero, then the encoded bytes 32 string is padded with zeros to the left.\n    if (firstZeroIndex === 0) {\n        // Find the first non-zero byte.\n        const firstNotZeroIndex = valueInBytes.findIndex((byte) => byte !== 0);\n        // Decode the encoded bytes 32 string to string by removing the padded zeros.\n        return Txt.of(valueInBytes.subarray(firstNotZeroIndex)).toString();\n    } else if (firstZeroIndex !== -1) {\n        // Decode the encoded bytes 32 string to string by removing the padded zeros.\n        return Txt.of(valueInBytes.subarray(0, firstZeroIndex)).toString();\n    } else {\n        return Txt.of(valueInBytes).toString();\n    }\n};\n\n/**\n * Encodes a string into a bytes32 hexadecimal expression with optional zero padding.\n * The encoded bytes32 string can be used as a parameter for a smart contract function.\n *\n * @param {string} value - The value to encode.\n * @param {'left' | 'right'} [zeroPadding='left'] - The type of zero padding to apply.\n * @returns {string} The encoded bytes32 string is a hexadecimal expression prefixed with `0x.\n * @throws {InvalidDataType}\n */\nconst encodeBytes32String = (\n    value: string,\n    zeroPadding: 'left' | 'right' = 'right' // Default to 'right' as ethers.js does.\n): string => {\n    // Wrap any error raised by utf8BytesOf(value).\n    try {\n        const valueInBytes = Txt.of(value).bytes;\n\n        if (valueInBytes.length > 32) {\n            throw new InvalidDataType(\n                'dataUtils.encodeBytes32String()',\n                `Failed to encode value ${value} to bytes32 string. Value exceeds 32 bytes.`,\n                { value }\n            );\n        }\n\n        const pad = ZERO_BYTES(32 - valueInBytes.length);\n        return zeroPadding === 'left'\n            ? Hex.of(nc_utils.concatBytes(pad, valueInBytes)).toString()\n            : Hex.of(nc_utils.concatBytes(valueInBytes, pad)).toString();\n    } catch (e) {\n        throw new InvalidDataType(\n            'dataUtils.encodeBytes32String()',\n            `Failed to encode value ${value} to bytes32 string.`,\n            { value },\n            e\n        );\n    }\n};\n\nexport const dataUtils = {\n    decodeBytes32String,\n    encodeBytes32String\n};\n","/**\n * Constant defining VeChain mainnet chain tag. The chain tag is the last byte of the genesis block ID\n */\nconst VECHAIN_MAINNET_CHAIN_TAG = 0x4a;\n\n/**\n * Constant defining VeChain testnet chain tag. The chain tag is the last byte of the genesis block ID\n */\nconst VECHAIN_TESTNET_CHAIN_TAG = 0x27;\n\n/**\n * Constant defining VeChain testnet chain tag. The chain tag is the last byte of the genesis block ID\n */\nconst VECHAIN_SOLO_CHAIN_TAG = 0xf6;\n\n/**\n * Constant representing the zero address in hexadecimal format\n */\nconst ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';\n\n/**\n * VTHO token address (energy.sol smart contract address)\n */\nconst VTHO_ADDRESS = '0x0000000000000000000000000000456e65726779';\n\n/**\n * Genesis block for VeChain mainnet\n */\nconst mainnetGenesisBlock = {\n    number: 0,\n    id: '0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a',\n    size: 170,\n    parentID:\n        '0xffffffff53616c757465202620526573706563742c20457468657265756d2100',\n    timestamp: 1530316800,\n    gasLimit: 10000000,\n    beneficiary: '0x0000000000000000000000000000000000000000',\n    gasUsed: 0,\n    totalScore: 0,\n    txsRoot:\n        '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n    txsFeatures: 0,\n    stateRoot:\n        '0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c',\n    receiptsRoot:\n        '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n    signer: '0x0000000000000000000000000000000000000000',\n    isTrunk: true,\n    transactions: []\n};\n\n/**\n * Genesis block for VeChain testnet\n */\nconst testnetGenesisBlock = {\n    number: 0,\n    id: '0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127',\n    size: 170,\n    parentID:\n        '0xffffffff00000000000000000000000000000000000000000000000000000000',\n    timestamp: 1530014400,\n    gasLimit: 10000000,\n    beneficiary: '0x0000000000000000000000000000000000000000',\n    gasUsed: 0,\n    totalScore: 0,\n    txsRoot:\n        '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n    txsFeatures: 0,\n    stateRoot:\n        '0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb',\n    receiptsRoot:\n        '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n    signer: '0x0000000000000000000000000000000000000000',\n    isTrunk: true,\n    transactions: []\n};\n\n/**\n * Genesis block for VeChain solo network\n */\nconst soloGenesisBlock = {\n    number: 0,\n    id: '0x00000000c05a20fbca2bf6ae3affba6af4a74b800b585bf7a4988aba7aea69f6',\n    size: 170,\n    parentID:\n        '0xffffffff00000000000000000000000000000000000000000000000000000000',\n    timestamp: 1526400000,\n    gasLimit: 10000000,\n    beneficiary: '0x0000000000000000000000000000000000000000',\n    gasUsed: 0,\n    totalScore: 0,\n    txsRoot:\n        '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n    txsFeatures: 0,\n    stateRoot:\n        '0x93de0ffb1f33bc0af053abc2a87c4af44594f5dcb1cb879dd823686a15d68550',\n    receiptsRoot:\n        '0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0',\n    signer: '0x0000000000000000000000000000000000000000',\n    isTrunk: true,\n    transactions: []\n};\n\n/**\n * Constant defining VeChain mainnet information\n */\nconst MAINNET_NETWORK = {\n    genesisBlock: mainnetGenesisBlock,\n    chainTag: VECHAIN_MAINNET_CHAIN_TAG\n};\n\n/**\n * Constant defining VeChain testnet information\n */\nconst TESTNET_NETWORK = {\n    genesisBlock: testnetGenesisBlock,\n    chainTag: VECHAIN_TESTNET_CHAIN_TAG\n};\n\n/**\n * Constant defining VeChain solo network information\n */\nconst SOLO_NETWORK = {\n    genesisBlock: soloGenesisBlock,\n    chainTag: VECHAIN_SOLO_CHAIN_TAG\n};\n\n/**\n * Constant defining VeChain mainnet and testnet network information\n */\nconst networkInfo = {\n    mainnet: MAINNET_NETWORK,\n    testnet: TESTNET_NETWORK,\n    solo: SOLO_NETWORK\n};\n\nexport {\n    networkInfo,\n    VTHO_ADDRESS,\n    ZERO_ADDRESS,\n    MAINNET_NETWORK,\n    TESTNET_NETWORK,\n    SOLO_NETWORK\n};\n","import { InvalidDataType } from '@vechain/sdk-errors';\nimport { ERC721_ABI, VIP180_ABI } from '../utils';\nimport { VTHO_ADDRESS } from '../utils/const/network';\nimport {\n    ABI,\n    ABIContract,\n    Address,\n    FixedPointNumber,\n    Units,\n    VET,\n    type ABIFunction,\n    type HexUInt,\n    type Token,\n    type VTHO\n} from '../vcdm';\nimport { Hex } from '../vcdm/Hex';\nimport { HexInt } from '../vcdm/HexInt';\nimport type { ClauseOptions } from './ClauseOptions';\nimport type { DeployParams } from './DeployParams';\nimport type { TransactionClause } from './TransactionClause';\n\n/**\n * Represents a contract clause, which includes the clause and the corresponding function ABI.\n */\ninterface ContractClause {\n    clause: TransactionClause;\n    functionAbi: ABIFunction;\n}\n\n/**\n * This class represent a transaction clause.\n *\n * @extends {TransactionClause}\n */\nclass Clause implements TransactionClause {\n    /**\n     * Used internally in {@link Clause.callFunction}.\n     */\n    private static readonly FORMAT_TYPE = 'json';\n\n    /**\n     * Used internally to tag a transaction without data.\n     */\n    private static readonly NO_DATA = Hex.PREFIX;\n\n    /**\n     * Used internally in {@link Clause.transferNFT} method.\n     */\n    private static readonly TRANSFER_NFT_FUNCTION = 'transferFrom';\n\n    /**\n     * Used internally in {@link Clause.transferVTHOToken} method.\n     */\n    private static readonly TRANSFER_TOKEN_FUNCTION = 'transfer';\n\n    /**\n     * Represents the address where:\n     * - transfer token to, or\n     * - invoke contract method on.\n     */\n    readonly to: string | null;\n\n    /**\n     * Return the hexadecimal expression of the amount of VET or VTHO\n     * token in {@link Units.wei} to transfer to the destination.\n     *\n     * @see {Clause.callFunction}\n     * @see {Clause.transferVTHOToken}\n     * @see {Clause.transferVET}\n     */\n    readonly value: string;\n\n    /**\n     * Return the hexadecimal expression of the encoding of the arguments\n     * of the called function of a smart contract.\n     */\n    readonly data: string;\n\n    /**\n     * An optional comment to describe the purpose of the clause.\n     */\n    readonly comment?: string;\n\n    /**\n     * An optional  Application Binary Interface (ABI) of the called\n     * function of a smart contract.\n     */\n    readonly abi?: string;\n\n    /**\n     * Used publicly to tag a transaction not tranferring token amount.\n     */\n    public static readonly NO_VALUE = Hex.PREFIX + '0';\n\n    /**\n     * Creates an instance of the class.\n     *\n     * @param {string|null} to - The address to transfer token\n     * or the smart contract to call, can be null.\n     * @param {string} value - The token amount being transferred in wei units\n     * as hexadecimal expression.\n     * @param {string} data - Arguments of the smart contract function called\n     * as encoded as a hexadecimal expression\n     * @param {string} [comment] - An optional comment.\n     * @param {string} [abi] - An optional ABI string.\n     */\n    protected constructor(\n        to: string | null,\n        value: string,\n        data: string,\n        comment?: string,\n        abi?: string\n    ) {\n        this.to = to;\n        this.value = value;\n        this.data = data;\n        this.comment = comment;\n        this.abi = abi;\n    }\n\n    /**\n     * Return the amount of {@link VET} or {@link VTHO} token\n     * in {@link Units.wei} to transfer to the destination.\n     *\n     * @return {FixedPointNumber} The amount as a fixed-point number.\n     */\n    public amount(): FixedPointNumber {\n        return FixedPointNumber.of(HexInt.of(this.value).bi);\n    }\n\n    /**\n     * Return a new clause to call a function of a smart contract.\n     *\n     * @param {Address} contractAddress - The address of the smart contract.\n     * @param {ABIFunction} functionAbi - The ABI definition of the function to be called.\n     * @param {unknown[]} args - The arguments for the function.\n     * @param {VET} [amount=VET.of(FixedPointNumber.ZERO)] - The amount of VET to be sent with the transaction calling the function.\n     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n     * @return {Clause} A clause object to call the function in a transaction.\n     * @throws {InvalidDataType} Throws an error if the amount is not a finite positive value.\n     */\n    public static callFunction(\n        contractAddress: Address,\n        functionAbi: ABIFunction,\n        args: unknown[],\n        amount: VET = VET.of(FixedPointNumber.ZERO),\n        clauseOptions?: ClauseOptions\n    ): Clause {\n        if (\n            amount.value.isFinite() &&\n            amount.value.gte(FixedPointNumber.ZERO)\n        ) {\n            return new Clause(\n                contractAddress.toString().toLowerCase(),\n                Hex.PREFIX + amount.wei.toString(Hex.RADIX),\n                functionAbi.encodeData(args).toString(),\n                clauseOptions?.comment,\n                clauseOptions?.includeABI === true\n                    ? functionAbi.format(Clause.FORMAT_TYPE)\n                    : undefined\n            );\n        }\n        throw new InvalidDataType(\n            'Clause.callFunction',\n            'not finite positive amount',\n            { amount: `${amount.value}` }\n        );\n    }\n\n    /**\n     * Returns a new clause to deploy a smart contract.\n     *\n     * @param {HexUInt} contractBytecode - The bytecode of the contract to be deployed.\n     * @param {DeployParams} [deployParams] - Optional parameters to pass to the smart contract constructor.\n     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n     * @return {Clause} The clause to deploy the smart contract as part of a transaction.\n     */\n    public static deployContract(\n        contractBytecode: HexUInt,\n        deployParams?: DeployParams,\n        clauseOptions?: ClauseOptions\n    ): Clause {\n        const data =\n            deployParams != null && deployParams !== undefined\n                ? contractBytecode.digits +\n                  ABI.of(deployParams.types, deployParams.values)\n                      .toHex()\n                      .toString()\n                      .replace(Hex.PREFIX, '')\n                : contractBytecode.digits;\n        return new Clause(\n            null,\n            clauseOptions?.value ?? Clause.NO_VALUE,\n            Hex.PREFIX + data,\n            clauseOptions?.comment\n        );\n    }\n\n    /**\n     * Transfers an NFT from the sender to the recipient.\n     *\n     * @param {Address} contractAddress - The address of the NFT contract.\n     * @param {Address} senderAddress - The address of the current owner (sender) of the NFT.\n     * @param {Address} recipientAddress - The address of the new owner (recipient) of the NFT.\n     * @param {HexUInt} tokenId - The unique identifier of the NFT to be transferred.\n     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n     * @return {Clause} The clause object representing the transfer operation as part of a transaction.\n     */\n    public static transferNFT(\n        contractAddress: Address,\n        senderAddress: Address,\n        recipientAddress: Address,\n        tokenId: HexUInt,\n        clauseOptions?: ClauseOptions\n    ): ContractClause {\n        const clause = Clause.callFunction(\n            contractAddress,\n            ABIContract.ofAbi(ERC721_ABI).getFunction(\n                Clause.TRANSFER_NFT_FUNCTION\n            ),\n            [\n                senderAddress.toString(),\n                recipientAddress.toString(),\n                tokenId.bi.toString()\n            ],\n            undefined,\n            clauseOptions\n        );\n\n        return {\n            clause,\n            functionAbi: ABIContract.ofAbi(ERC721_ABI).getFunction(\n                Clause.TRANSFER_NFT_FUNCTION\n            )\n        };\n    }\n\n    /**\n     * Return a new clause to transfers the specified amount of VTHO\n     *\n     * @param {Address} recipientAddress - The address of the recipient.\n     * @param {VTHO} amount - The amount of token to be transferred.\n     * @return {ContractClause} The contract clause to transfer VTHO tokens as part of a transaction.\n     * @throws {InvalidDataType} Throws an error if the amount is not a positive integer.\n     *\n     * @see VTHO.transferTokenTo\n     */\n    public static transferVTHOToken(\n        recipientAddress: Address,\n        amount: VTHO\n    ): ContractClause {\n        if (amount.value.isFinite() && amount.value.isPositive()) {\n            const vthoAddress = Address.of(VTHO_ADDRESS);\n            const functionAbi = ABIContract.ofAbi(VIP180_ABI).getFunction(\n                Clause.TRANSFER_TOKEN_FUNCTION\n            );\n            const clause = Clause.callFunction(\n                vthoAddress,\n                functionAbi,\n                [recipientAddress.toString(), amount.wei],\n                undefined,\n                { comment: 'Transfer VTHO' }\n            );\n\n            return {\n                clause,\n                functionAbi\n            };\n        }\n        throw new InvalidDataType(\n            'Clause.transferVTHOToken',\n            'not positive integer amount',\n            { amount: `${amount.value}` }\n        );\n    }\n\n    /**\n     * Return a new clause to transfer a generic ERC20 Token\n     *\n     * @param {Address} recipientAddress - The address of the recipient.\n     * @param {Token} amount - The amount of token to be transferred.\n     * @return {ContractClause} The contract clause to transfer tokens as part of a transaction.\n     * @throws {InvalidDataType} Throws an error if the amount is not a positive integer.\n     */\n    public static transferToken(\n        recipientAddress: Address,\n        token: Token\n    ): ContractClause {\n        if (token.value >= 0) {\n            const tokenValueWei = Units.convertUnits(\n                FixedPointNumber.of(token.value),\n                token.units,\n                Units.wei\n            );\n            const clause = Clause.callFunction(\n                token.tokenAddress,\n                ABIContract.ofAbi(VIP180_ABI).getFunction(\n                    Clause.TRANSFER_TOKEN_FUNCTION\n                ),\n                [recipientAddress.toString(), tokenValueWei],\n                undefined,\n                { comment: `Transfer ${token.name}` }\n            );\n\n            return {\n                clause,\n                functionAbi: ABIContract.ofAbi(VIP180_ABI).getFunction(\n                    Clause.TRANSFER_TOKEN_FUNCTION\n                )\n            };\n        }\n        throw new InvalidDataType(\n            'Clause.transferToken',\n            'not positive integer amount',\n            { amount: `${token.value}` }\n        );\n    }\n\n    /**\n     * Return a new clause to transfers VET to a specified recipient address.\n     *\n     * @param {Address} recipientAddress - The address of the recipient.\n     * @param {VET} amount - The amount of VET to transfer.\n     * @param {ClauseOptions} [clauseOptions] - Optional clause settings.\n     * @return {Clause} - The clause object to transfer VET as part of a transaction.\n     * @throws {InvalidDataType} - If the amount is not a finite positive value.\n     *\n     * @see VET.transferTo\n     */\n    public static transferVET(\n        recipientAddress: Address,\n        amount: VET,\n        clauseOptions?: ClauseOptions\n    ): Clause {\n        if (amount.value.isFinite() && amount.value.isPositive()) {\n            return new Clause(\n                recipientAddress.toString().toLowerCase(),\n                Hex.PREFIX + amount.wei.toString(Hex.RADIX),\n                Clause.NO_DATA,\n                clauseOptions?.comment\n            );\n        }\n        throw new InvalidDataType(\n            'Clause.transferVET',\n            'not finite positive amount',\n            { amount: `${amount.value}` }\n        );\n    }\n}\n\nexport { Clause, type ContractClause };\n","import { InvalidTransactionType } from '@vechain/sdk-errors';\n\n/**\n * Represents the type of a transaction\n */\nexport enum TransactionType {\n    Legacy = 'legacy',\n    EIP1559 = 'eip1559'\n}\n\n/**\n * Constants for transaction type values\n */\nconst TRANSACTION_TYPE_VALUES = {\n    [TransactionType.Legacy]: 0,\n    [TransactionType.EIP1559]: 81 // 0x51\n} as const;\n\n/**\n * Valid transaction type values\n */\nconst VALID_TRANSACTION_TYPES: number[] = Object.values(\n    TRANSACTION_TYPE_VALUES\n);\n\n/**\n * Converts a transaction type number to TransactionType string.\n * Type 0 represents legacy transactions, type 81 (0x51) represents EIP-1559 transactions\n *\n * @param type - The transaction type number (0 or 81)\n * @returns The transaction type as 'legacy' or 'eip1559'\n * @throws {Error} If the input type is not a valid transaction type\n * @example\n * ```typescript\n * const type = toTransactionType(81); // returns TransactionType.EIP1559\n * const type = toTransactionType(0);  // returns TransactionType.Legacy\n * ```\n */\nexport function toTransactionType(type: number): TransactionType {\n    if (!VALID_TRANSACTION_TYPES.includes(type)) {\n        throw new InvalidTransactionType(\n            'TransactionType.toTransactionType()',\n            'Invalid transaction type',\n            {\n                transactionType: type.toString(),\n                validTypes: VALID_TRANSACTION_TYPES.map((t) =>\n                    t.toString()\n                ).join(', ')\n            }\n        );\n    }\n    return type === TRANSACTION_TYPE_VALUES[TransactionType.Legacy]\n        ? TransactionType.Legacy\n        : TransactionType.EIP1559;\n}\n\n/**\n * Converts a TransactionType string to its corresponding number representation.\n * 'legacy' transactions are type 0, 'eip1559' transactions are type 81 (0x51).\n *\n * @param type - The transaction type as TransactionType\n * @returns The transaction type number (0 for legacy, 81 for eip1559)\n * @example\n * ```typescript\n * const type = fromTransactionType(TransactionType.EIP1559); // returns 81\n * const type = fromTransactionType(TransactionType.Legacy);  // returns 0\n * ```\n */\nexport function fromTransactionType(type: TransactionType): number {\n    return TRANSACTION_TYPE_VALUES[type];\n}\n","import * as nc_utils from '@noble/curves/abstract/utils';\nimport {\n    InvalidDataType,\n    InvalidSecp256k1PrivateKey,\n    InvalidTransactionField,\n    NotDelegatedTransaction,\n    UnavailableTransactionField\n} from '@vechain/sdk-errors';\nimport { Secp256k1 } from '../secp256k1';\nimport {\n    Address,\n    BufferKind,\n    CompactFixedHexBlobKind,\n    Hex,\n    HexBlobKind,\n    HexUInt,\n    NumericKind,\n    OptionalFixedHexBlobKind,\n    type RLPProfile,\n    RLPProfiler,\n    type RLPValidObject,\n    Units,\n    VTHO\n} from '../vcdm';\nimport { Blake2b256 } from '../vcdm/hash/Blake2b256';\nimport type { TransactionClause } from './TransactionClause';\nimport { TransactionType } from './TransactionType';\nimport { type TransactionBody } from './TransactionBody';\n\n/**\n * Represents an immutable transaction entity.\n */\nclass Transaction {\n    /**\n     * Represent the block reference length in bytes.\n     */\n    private static readonly BLOCK_REF_LENGTH = 8;\n\n    /**\n     * A collection of constants used for gas calculations in transactions.\n     *\n     * Properties\n     * - `TX_GAS` - The base gas cost for a transaction.\n     * - `CLAUSE_GAS` - The gas cost for executing a clause in a transaction.\n     * - `CLAUSE_GAS_CONTRACT_CREATION` - The gas cost for creating a contract via a clause.\n     * - `ZERO_GAS_DATA` - The gas cost for transmitting zero bytes of data.\n     * - `NON_ZERO_GAS_DATA` - The gas cost for transmitting non-zero bytes of data.\n     */\n    public static readonly GAS_CONSTANTS = {\n        TX_GAS: 5000n,\n        CLAUSE_GAS: 16000n,\n        CLAUSE_GAS_CONTRACT_CREATION: 48000n,\n        ZERO_GAS_DATA: 4n,\n        NON_ZERO_GAS_DATA: 68n\n    };\n\n    /**\n     * Represents the prefix for raw EIP-1559 transaction type.\n     */\n    private static readonly EIP1559_TX_TYPE_PREFIX = 0x51;\n\n    /**\n     * RLP_FIELDS is an array of objects that defines the structure and encoding scheme\n     * for various components in a transaction using Recursive Length Prefix (RLP) encoding.\n     * Each object in the array represents a field in the transaction, specifying its name and kind.\n     * The `kind` attribute is an instance of an RLP coder that determines how the field is encoded.\n     *\n     * Properties\n     * - `chainTag` - Represent the id of the chain the transaction is sent to.\n     * - `blockRef` - Represent the last block of the chain the transaction is sent to.\n     * - `expiration` -  Represent the expiration date of the transaction.\n     * - `clauses` - List of clause objects, each containing:\n     *   - `to` - Represent the destination of the transaction.\n     *   - `value` - Represent the 'wei' quantity (VET or VTHO) value the transaction is worth.\n     *   - `data` - Represent the content of the transaction.\n     * - `gasPriceCoef` - Represent the gas price coefficient of the transaction.\n     * - `gas` - Represent the gas limit of the transaction.\n     * - `dependsOn` - Represent the hash of the transaction the current transaction depends on.\n     * - `nonce` - Represent the nonce of the transaction.\n     * - `reserved` -  Reserved field.\n     */\n    private static readonly LEGACY_RLP_FIELDS = [\n        { name: 'chainTag', kind: new NumericKind(1) },\n        { name: 'blockRef', kind: new CompactFixedHexBlobKind(8) },\n        { name: 'expiration', kind: new NumericKind(4) },\n        {\n            name: 'clauses',\n            kind: {\n                item: [\n                    {\n                        name: 'to',\n                        kind: new OptionalFixedHexBlobKind(20)\n                    },\n                    { name: 'value', kind: new NumericKind(32) },\n                    { name: 'data', kind: new HexBlobKind() }\n                ]\n            }\n        },\n        { name: 'gasPriceCoef', kind: new NumericKind(1) },\n        { name: 'gas', kind: new NumericKind(8) },\n        { name: 'dependsOn', kind: new OptionalFixedHexBlobKind(32) },\n        { name: 'nonce', kind: new NumericKind(8) },\n        { name: 'reserved', kind: { item: new BufferKind() } }\n    ];\n\n    /**\n     * Represents the RLP fields for EIP-1559 transactions.\n     */\n    private static readonly EIP1559_RLP_FIELDS = [\n        { name: 'chainTag', kind: new NumericKind(1) },\n        { name: 'blockRef', kind: new CompactFixedHexBlobKind(8) },\n        { name: 'expiration', kind: new NumericKind(4) },\n        {\n            name: 'clauses',\n            kind: {\n                item: [\n                    {\n                        name: 'to',\n                        kind: new OptionalFixedHexBlobKind(20)\n                    },\n                    { name: 'value', kind: new NumericKind(32) },\n                    { name: 'data', kind: new HexBlobKind() }\n                ]\n            }\n        },\n        { name: 'maxPriorityFeePerGas', kind: new NumericKind(32) },\n        { name: 'maxFeePerGas', kind: new NumericKind(32) },\n        { name: 'gas', kind: new NumericKind(8) },\n        { name: 'dependsOn', kind: new OptionalFixedHexBlobKind(32) },\n        { name: 'nonce', kind: new NumericKind(8) },\n        { name: 'reserved', kind: { item: new BufferKind() } }\n    ];\n\n    /**\n     * Represent the Recursive Length Prefix (RLP) of the transaction features.\n     *\n     * Properties\n     * - `name` - A string indicating the name of the field in the RLP structure.\n     * - `kind` - RLP profile type.\n     */\n    private static readonly RLP_FEATURES = {\n        name: 'reserved.features',\n        kind: new NumericKind(4)\n    };\n\n    /**\n     * Represents a Recursive Length Prefix (RLP) of the transaction signature.\n     *\n     * Properties\n     * - `name` - A string indicating the name of the field in the RLP structure.\n     * - `kind` - RLP profile type.\n     */\n    private static readonly RLP_SIGNATURE = {\n        name: 'signature',\n        kind: new BufferKind()\n    };\n\n    /**\n     * Represents a Recursive Length Prefix (RLP) of the signed transaction.\n     *\n     * Properties\n     * - `name` - A string indicating the name of the field in the RLP structure.\n     * - `kind` - RLP profile type.\n     */\n    private static readonly RLP_SIGNED_LEGACY_TRANSACTION_PROFILE: RLPProfile =\n        {\n            name: 'tx',\n            kind: Transaction.LEGACY_RLP_FIELDS.concat([\n                Transaction.RLP_SIGNATURE\n            ])\n        };\n\n    /**\n     * Represents a Recursive Length Prefix (RLP) of the unsigned transaction.\n     *\n     * Properties\n     * - `name` - A string indicating the name of the field in the RLP structure.\n     * - `kind` - RLP profile type.\n     */\n    private static readonly RLP_UNSIGNED_LEGACY_TRANSACTION_PROFILE: RLPProfile =\n        {\n            name: 'tx',\n            kind: Transaction.LEGACY_RLP_FIELDS\n        };\n\n    /**\n     * Represents a Recursive Length Prefix (RLP) of the signed EIP-1559 transaction.\n     *\n     * Properties\n     * - `name` - A string indicating the name of the field in the RLP structure.\n     * - `kind` - RLP profile type.\n     */\n    private static readonly RLP_SIGNED_EIP1559_TRANSACTION_PROFILE: RLPProfile =\n        {\n            name: 'tx',\n            kind: Transaction.EIP1559_RLP_FIELDS.concat([\n                Transaction.RLP_SIGNATURE\n            ])\n        };\n\n    /**\n     * Represents a Recursive Length Prefix (RLP) of the unsigned EIP-1559 transaction.\n     *\n     * Properties\n     * - `name` - A string indicating the name of the field in the RLP structure.\n     * - `kind` - RLP profile type.\n     */\n    private static readonly RLP_UNSIGNED_EIP1559_TRANSACTION_PROFILE: RLPProfile =\n        {\n            name: 'tx',\n            kind: Transaction.EIP1559_RLP_FIELDS\n        };\n\n    /**\n     * It represents the content of the transaction.\n     */\n    public readonly body: TransactionBody;\n\n    /**\n     * It represents the type of the transaction.\n     */\n    public readonly transactionType: TransactionType;\n\n    /**\n     * It represents the signature of the transaction content.\n     */\n    public readonly signature?: Uint8Array;\n\n    /**\n     * Creates a new instance of the class with the specified transaction body and optional signature.\n     *\n     * @param {TransactionBody} body The transaction body to be used.\n     * @param {Uint8Array} [signature] The optional signature for the transaction.\n     */\n    protected constructor(\n        body: TransactionBody,\n        type: TransactionType,\n        signature?: Uint8Array\n    ) {\n        this.body = body;\n        this.transactionType = type;\n        this.signature = signature;\n    }\n\n    // ********** GET COMPUTED PROPERTIES **********\n\n    /**\n     * Get the gas payer's address if the transaction is delegated.\n     *\n     * If the transaction is delegated and a signature is available, this method recovers\n     * the gas payer parameter from the signature and subsequently recovers the gas payer's public key\n     * to derive the gas payer's address.\n     *\n     * @return {Address} The address of the gas payer.\n     * @throws {UnavailableTransactionField} If the transaction is delegated but the signature is missing.\n     * @throws {NotDelegatedTransaction} If the transaction is not delegated.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Address.ofPublicKey};\n     * - {@link Secp256k1.recover};\n     * - {@link Transaction.getTransactionHash}.\n     */\n    public get gasPayer(): Address {\n        if (this.isDelegated) {\n            if (this.signature !== undefined) {\n                // Recover the gas payer param from the signature\n                const gasPayer = this.signature.slice(\n                    Secp256k1.SIGNATURE_LENGTH,\n                    this.signature.length\n                );\n                // Recover the gas payer's public key.\n                const gasPayerPublicKey = Secp256k1.recover(\n                    this.getTransactionHash(this.origin).bytes,\n                    gasPayer\n                );\n                return Address.ofPublicKey(gasPayerPublicKey);\n            }\n            throw new UnavailableTransactionField(\n                'Transaction.gasPayer()',\n                'missing gas payer signature',\n                { fieldName: 'gasPayer' }\n            );\n        }\n        throw new NotDelegatedTransaction(\n            'Transaction.gasPayer()',\n            'not delegated transaction',\n            undefined\n        );\n    }\n\n    /**\n     * Get the encoded bytes as a Uint8Array.\n     * The encoding is determined by whether the data is signed.\n     *\n     * @return {Uint8Array} The encoded byte array.\n     *\n     * @see decode\n     */\n    public get encoded(): Uint8Array {\n        return this.encode(this.isSigned);\n    }\n\n    /**\n     * Get transaction ID.\n     *\n     * The ID is the Blake2b256 hash of the transaction's signature\n     * concatenated with the origin's address.\n     * If the transaction is not signed,\n     * it throws an UnavailableTransactionField error.\n     *\n     * @return {Blake2b256} The concatenated hash of the signature\n     * and origin if the transaction is signed.\n     * @throws {UnavailableTransactionField} If the transaction is not signed.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Blake2b256.of}\n     */\n    public get id(): Blake2b256 {\n        if (this.isSigned) {\n            return Blake2b256.of(\n                nc_utils.concatBytes(\n                    this.getTransactionHash().bytes,\n                    this.origin.bytes\n                )\n            );\n        }\n        throw new UnavailableTransactionField(\n            'Transaction.id()',\n            'not signed transaction: id unavailable',\n            { fieldName: 'id' }\n        );\n    }\n\n    /**\n     * Return the intrinsic gas required for this transaction.\n     *\n     * @return {VTHO} The computed intrinsic gas for the transaction.\n     */\n    public get intrinsicGas(): VTHO {\n        return Transaction.intrinsicGas(this.body.clauses);\n    }\n\n    /**\n     * Returns `true` if the transaction is delegated, otherwise `false`.\n     *\n     * @return {boolean} `true` if the transaction is delegated,\n     * otherwise `false`.\n     */\n    public get isDelegated(): boolean {\n        return Transaction.isDelegated(this.body);\n    }\n\n    /**\n     * Return `true` if the signature is defined and complete, otherwise `false`.\n     *\n     * @return {boolean} return `true` if the signature is defined and complete, otherwise `false`.\n     *\n     * @remarks Any delegated transaction signed with {@link signAsSender}\n     * but not yet signed with {@link signAsGasPayer} is not signed.\n     */\n    public get isSigned(): boolean {\n        if (this.signature !== undefined) {\n            return Transaction.isSignatureLengthValid(\n                this.body,\n                this.signature\n            );\n        }\n        return false;\n    }\n\n    /**\n     * Return the origin (also known as sender) address of the transaction.\n     *\n     * The origin is determined by recovering the public key from the transaction's sender.\n     *\n     * @return {Address} The address derived from the public key of the transaction's sender.\n     * @throws {UnavailableTransactionField} If the transaction is not signed, an exception is thrown indicating the absence of the origin field.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Address.ofPublicKey};\n     * - {@link Secp256k1.recover}.\n     */\n    public get origin(): Address {\n        if (this.signature !== undefined) {\n            return Address.ofPublicKey(\n                // Get the origin public key.\n                Secp256k1.recover(\n                    this.getTransactionHash().bytes,\n                    // Get the (r, s) of ECDSA digital signature without gas payer params.\n                    this.signature.slice(0, Secp256k1.SIGNATURE_LENGTH)\n                )\n            );\n        }\n        throw new UnavailableTransactionField(\n            'Transaction.origin()',\n            'not signed transaction, no origin',\n            { fieldName: 'origin' }\n        );\n    }\n\n    // ********** PUBLIC METHODS **********\n\n    /**\n     * Decodes a raw transaction byte array into a new Transaction object.\n     *\n     * @param {Uint8Array} rawTransaction - The raw transaction bytes to decode.\n     * @param {boolean} isSigned - Flag indicating if the transaction is signed.\n     * @return {Transaction} The decoded transaction object.\n     *\n     * @see encoded\n     */\n    public static decode(\n        rawTransaction: Uint8Array,\n        isSigned: boolean\n    ): Transaction {\n        // check prefix to get tx type\n        const rawPrefix = rawTransaction[0];\n        let txType: TransactionType = TransactionType.Legacy;\n        if (Number(rawPrefix) === Transaction.EIP1559_TX_TYPE_PREFIX) {\n            txType = TransactionType.EIP1559;\n        }\n\n        // Get correct decoder profiler\n        const profile = isSigned\n            ? txType === TransactionType.Legacy\n                ? Transaction.RLP_SIGNED_LEGACY_TRANSACTION_PROFILE\n                : Transaction.RLP_SIGNED_EIP1559_TRANSACTION_PROFILE\n            : txType === TransactionType.Legacy\n              ? Transaction.RLP_UNSIGNED_LEGACY_TRANSACTION_PROFILE\n              : Transaction.RLP_UNSIGNED_EIP1559_TRANSACTION_PROFILE;\n\n        // if eip1559, remove prefix\n        if (txType === TransactionType.EIP1559) {\n            rawTransaction = rawTransaction.slice(1);\n        }\n\n        // Get decoded body\n        const decodedRLPBody = RLPProfiler.ofObjectEncoded(\n            rawTransaction,\n            profile\n        ).object as RLPValidObject;\n        // Create correct transaction body without reserved field\n        const bodyWithoutReservedField: TransactionBody = {\n            blockRef: decodedRLPBody.blockRef as string,\n            chainTag: decodedRLPBody.chainTag as number,\n            clauses: decodedRLPBody.clauses as [],\n            dependsOn: decodedRLPBody.dependsOn as string | null,\n            expiration: decodedRLPBody.expiration as number,\n            gas: decodedRLPBody.gas as number,\n            nonce: decodedRLPBody.nonce as number,\n            // Handle both legacy and EIP-1559 gas pricing\n            ...(decodedRLPBody.gasPriceCoef !== undefined\n                ? { gasPriceCoef: decodedRLPBody.gasPriceCoef as number }\n                : {\n                      maxFeePerGas: decodedRLPBody.maxFeePerGas as string,\n                      maxPriorityFeePerGas:\n                          decodedRLPBody.maxPriorityFeePerGas as string\n                  })\n        };\n        // Create correct transaction body (with correct reserved field)\n        const correctTransactionBody: TransactionBody =\n            (decodedRLPBody.reserved as Uint8Array[]).length > 0\n                ? {\n                      ...bodyWithoutReservedField,\n                      reserved: Transaction.decodeReservedField(\n                          decodedRLPBody.reserved as Uint8Array[]\n                      )\n                  }\n                : bodyWithoutReservedField;\n        // Return decoded transaction (with signature or not)\n        return decodedRLPBody.signature !== undefined\n            ? Transaction.of(\n                  correctTransactionBody,\n                  decodedRLPBody.signature as Uint8Array\n              )\n            : Transaction.of(correctTransactionBody);\n    }\n\n    /**\n     * Computes the transaction hash, optionally incorporating a gas payer's address.\n     *\n     * @param {Address} [sender] - Optional transaction origin's address to include in the hash computation.\n     * @return {Blake2b256} - The computed transaction hash.\n     *\n     * @remarks\n     * `sender` is used to sign a transaction on behalf of another account.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Blake2b256.of}.\n     */\n    public getTransactionHash(sender?: Address): Blake2b256 {\n        const txHash = Blake2b256.of(this.encode(false));\n        if (sender !== undefined) {\n            return Blake2b256.of(\n                nc_utils.concatBytes(txHash.bytes, sender.bytes)\n            );\n        }\n        return txHash;\n    }\n\n    /**\n     * Calculates the intrinsic gas required for the given transaction clauses.\n     *\n     * @param {TransactionClause[]} clauses - An array of transaction clauses to calculate the intrinsic gas for.\n     * @return {VTHO} The total intrinsic gas required for the provided clauses.\n     * @throws {InvalidDataType} If clauses have invalid data as invalid addresses.\n     */\n    public static intrinsicGas(clauses: TransactionClause[]): VTHO {\n        if (clauses.length > 0) {\n            // Some clauses.\n            return VTHO.of(\n                clauses.reduce((sum: bigint, clause: TransactionClause) => {\n                    if (clause.to !== null) {\n                        // Invalid address or no vet.domains name\n                        if (\n                            !Address.isValid(clause.to) &&\n                            !clause.to.includes('.')\n                        )\n                            throw new InvalidDataType(\n                                'Transaction.intrinsicGas',\n                                'invalid data type in clause: each `to` field must be a valid address.',\n                                { clause }\n                            );\n\n                        sum += Transaction.GAS_CONSTANTS.CLAUSE_GAS;\n                    } else {\n                        sum +=\n                            Transaction.GAS_CONSTANTS\n                                .CLAUSE_GAS_CONTRACT_CREATION;\n                    }\n                    sum += Transaction.computeUsedGasFor(clause.data);\n                    return sum;\n                }, Transaction.GAS_CONSTANTS.TX_GAS),\n                Units.wei\n            );\n        }\n        // No clauses.\n        return VTHO.of(\n            Transaction.GAS_CONSTANTS.TX_GAS +\n                Transaction.GAS_CONSTANTS.CLAUSE_GAS,\n            Units.wei\n        );\n    }\n\n    /**\n     * Validates the transaction body's fields according to the transaction type.\n     *\n     * @param {TransactionBody} body - The transaction body to validate.\n     * @param {TransactionType} type - The transaction type to validate the body against.\n     * @return {boolean} True if the transaction body is valid for the given type.\n     */\n    public static isValidBody(\n        body: TransactionBody,\n        type: TransactionType\n    ): boolean {\n        // Legacy transactions shouldn't have any EIP-1559 parameters\n        if (\n            type === TransactionType.Legacy &&\n            (body.maxFeePerGas !== undefined ||\n                body.maxPriorityFeePerGas !== undefined)\n        ) {\n            return false;\n        }\n\n        // EIP-1559 transactions shouldn't have legacy parameters\n        if (\n            type === TransactionType.EIP1559 &&\n            body.gasPriceCoef !== undefined\n        ) {\n            return false;\n        }\n\n        // validate common fields\n        const isValidCommonFields =\n            // Chain tag\n            body.chainTag !== undefined &&\n            body.chainTag >= 0 &&\n            body.chainTag <= 255 &&\n            // Block reference\n            body.blockRef !== undefined &&\n            Hex.isValid0x(body.blockRef) &&\n            HexUInt.of(body.blockRef).bytes.length ===\n                Transaction.BLOCK_REF_LENGTH &&\n            // Expiration\n            body.expiration !== undefined &&\n            // Clauses\n            body.clauses !== undefined &&\n            // Gas\n            body.gas !== undefined &&\n            // Depends on\n            body.dependsOn !== undefined &&\n            // Nonce\n            body.nonce !== undefined;\n\n        // validate eip1559 fields\n        const isValidEip1559Fields =\n            type === TransactionType.EIP1559 &&\n            body.maxFeePerGas !== undefined &&\n            body.maxPriorityFeePerGas !== undefined &&\n            ((typeof body.maxFeePerGas === 'string' &&\n                Hex.isValid0x(body.maxFeePerGas)) ||\n                typeof body.maxFeePerGas === 'number') &&\n            ((typeof body.maxPriorityFeePerGas === 'string' &&\n                Hex.isValid0x(body.maxPriorityFeePerGas)) ||\n                typeof body.maxPriorityFeePerGas === 'number');\n\n        // validate legacy fields\n        const isValidLegacyFields =\n            type === TransactionType.Legacy && body.gasPriceCoef !== undefined;\n\n        // return true if the transaction body is valid\n        if (type === TransactionType.EIP1559) {\n            return isValidCommonFields && isValidEip1559Fields;\n        }\n        return isValidCommonFields && isValidLegacyFields;\n    }\n\n    /**\n     * Returns the type of the transaction.\n     *\n     * @param {TransactionBody} body - The transaction body to get the type of.\n     * @return {TransactionType} The type of the transaction.\n     */\n    private static getTransactionType(body: TransactionBody): TransactionType {\n        if (body.gasPriceCoef !== undefined) {\n            return TransactionType.Legacy;\n        }\n        if (\n            body.maxFeePerGas !== undefined &&\n            body.maxPriorityFeePerGas !== undefined\n        ) {\n            return TransactionType.EIP1559;\n        }\n        throw new InvalidTransactionField(\n            'Transaction.getTransactionType',\n            'invalid transaction body',\n            {\n                fieldName: 'body',\n                body\n            }\n        );\n    }\n\n    /**\n     * Creates a new Transaction instance if the provided body is valid.\n     *\n     * @param {TransactionBody} body - The transaction body to be validated.\n     * @param {Uint8Array} [signature] - Optional signature.\n     * @return {Transaction} A new Transaction instance if validation is successful.\n     * @throws {InvalidTransactionField} If the provided body is invalid.\n     */\n    public static of(\n        body: TransactionBody,\n        signature?: Uint8Array\n    ): Transaction {\n        const txType = Transaction.getTransactionType(body);\n        if (Transaction.isValidBody(body, txType)) {\n            return new Transaction(body, txType, signature);\n        }\n        throw new InvalidTransactionField('Transaction.of', 'invalid body', {\n            fieldName: 'body',\n            body\n        });\n    }\n\n    /**\n     * Signs the transaction using the provided private key of the transaction sender.\n     *\n     * @param {Uint8Array} senderPrivateKey - The private key used to sign the transaction.\n     * @return {Transaction} The signed transaction.\n     * @throws {InvalidTransactionField} If attempting to sign a delegated transaction.\n     * @throws {InvalidSecp256k1PrivateKey} If the provided private key is not valid.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Secp256k1.isValidPrivateKey};\n     * - {@link Secp256k1.sign}.\n     */\n    public sign(senderPrivateKey: Uint8Array): Transaction {\n        // Check if the private key is valid.\n        if (Secp256k1.isValidPrivateKey(senderPrivateKey)) {\n            if (!this.isDelegated) {\n                // Sign transaction\n                const signature = Secp256k1.sign(\n                    this.getTransactionHash().bytes,\n                    senderPrivateKey\n                );\n                // Return new signed transaction.\n                return Transaction.of(this.body, signature);\n            }\n            throw new InvalidTransactionField(\n                `Transaction.sign`,\n                'delegated transaction: use signAsSenderAndGasPayer method',\n                { fieldName: 'gasPayer', body: this.body }\n            );\n        }\n        throw new InvalidSecp256k1PrivateKey(\n            `Transaction.sign`,\n            'invalid private key: ensure it is a secp256k1 key',\n            undefined\n        );\n    }\n\n    /**\n     * Signs a transaction as a gas payer using the provided private key. This is applicable only if the transaction\n     * has been marked as delegated and already contains the signature of the transaction sender\n     * that needs to be extended with the gas payer's signature.\n     *\n     * @param {Address} sender - The address of the sender for whom the transaction hash is generated.\n     * @param {Uint8Array} gasPayerPrivateKey - The private key of the gas payer. Must be a valid secp256k1 key.\n     *\n     * @return {Transaction} - A new transaction object with the gas payer's signature appended.\n     *\n     * @throws {InvalidSecp256k1PrivateKey} If the provided gas payer private key is not valid.\n     * @throws {InvalidTransactionField} If the transaction is unsigned or lacks a valid signature.\n     * @throws {NotDelegatedTransaction} If the transaction is not set as delegated.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Secp256k1.isValidPrivateKey};\n     * - {@link Secp256k1.sign}.\n     */\n    public signAsGasPayer(\n        sender: Address,\n        gasPayerPrivateKey: Uint8Array\n    ): Transaction {\n        if (Secp256k1.isValidPrivateKey(gasPayerPrivateKey)) {\n            if (this.isDelegated) {\n                const senderHash = this.getTransactionHash(sender).bytes;\n                if (this.signature !== undefined) {\n                    return new Transaction(\n                        this.body,\n                        this.transactionType,\n                        nc_utils.concatBytes(\n                            // Drop any previous gas payer signature.\n                            this.signature.slice(0, Secp256k1.SIGNATURE_LENGTH),\n                            Secp256k1.sign(senderHash, gasPayerPrivateKey)\n                        )\n                    );\n                } else {\n                    return new Transaction(\n                        this.body,\n                        this.transactionType,\n                        Secp256k1.sign(senderHash, gasPayerPrivateKey)\n                    );\n                }\n            }\n            throw new NotDelegatedTransaction(\n                'Transaction.signAsGasPayer',\n                'not delegated transaction: use sign method',\n                undefined\n            );\n        }\n        throw new InvalidSecp256k1PrivateKey(\n            `Transaction.signAsGasPayer`,\n            'invalid gas payer private key: ensure it is a secp256k1 key',\n            undefined\n        );\n    }\n\n    /**\n     * Signs a delegated transaction using the provided transaction sender's private key,\n     * call the {@link signAsGasPayer} to complete the signature,\n     * before such call {@link isDelegated} returns `true` but\n     * {@link isSigned} returns `false`.\n     *\n     * @param senderPrivateKey The private key of the transaction sender, represented as a Uint8Array. It must be a valid secp256k1 private key.\n     * @return A new Transaction object with the signature applied, if the transaction is delegated and the private key is valid.\n     * @throws NotDelegatedTransaction if the current transaction is not marked as delegated, instructing to use the regular sign method instead.\n     * @throws InvalidSecp256k1PrivateKey if the provided senderPrivateKey is not a valid secp256k1 private key.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Secp256k1.isValidPrivateKey};\n     * - {@link Secp256k1.sign}.\n     */\n    public signAsSender(senderPrivateKey: Uint8Array): Transaction {\n        if (Secp256k1.isValidPrivateKey(senderPrivateKey)) {\n            if (this.isDelegated) {\n                const transactionHash = this.getTransactionHash().bytes;\n                return new Transaction(\n                    this.body,\n                    this.transactionType,\n                    Secp256k1.sign(transactionHash, senderPrivateKey)\n                );\n            }\n            throw new NotDelegatedTransaction(\n                'Transaction.signAsSender',\n                'not delegated transaction: use sign method',\n                undefined\n            );\n        }\n        throw new InvalidSecp256k1PrivateKey(\n            `Transaction.signAsSender`,\n            'invalid sender private key: ensure it is a secp256k1 key',\n            undefined\n        );\n    }\n\n    /**\n     * Signs the transaction using both the transaction sender and the gas payer private keys.\n     *\n     * @param {Uint8Array} senderPrivateKey - The private key of the transaction sender.\n     * @param {Uint8Array} gasPayerPrivateKey - The private key of the gas payer.\n     * @return {Transaction} A new transaction with the concatenated signatures\n     * of the transaction sender and the gas payer.\n     * @throws {InvalidSecp256k1PrivateKey} - If either the private key of the transaction sender or gas payer is invalid.\n     * @throws {NotDelegatedTransaction} - If the transaction is not delegated.\n     *\n     * @remarks Security auditable method, depends on\n     * - {@link Address.ofPublicKey}\n     * - {@link Secp256k1.isValidPrivateKey};\n     * - {@link Secp256k1.sign}.\n     */\n    public signAsSenderAndGasPayer(\n        senderPrivateKey: Uint8Array,\n        gasPayerPrivateKey: Uint8Array\n    ): Transaction {\n        // Check if the private key of the sender is valid.\n        if (Secp256k1.isValidPrivateKey(senderPrivateKey)) {\n            // Check if the private key of the gas payer is valid.\n            if (Secp256k1.isValidPrivateKey(gasPayerPrivateKey)) {\n                if (this.isDelegated) {\n                    const senderHash = this.getTransactionHash().bytes;\n                    const gasPayerHash = this.getTransactionHash(\n                        Address.ofPublicKey(\n                            Secp256k1.derivePublicKey(senderPrivateKey)\n                        )\n                    ).bytes;\n                    // Return new signed transaction\n                    return Transaction.of(\n                        this.body,\n                        nc_utils.concatBytes(\n                            Secp256k1.sign(senderHash, senderPrivateKey),\n                            Secp256k1.sign(gasPayerHash, gasPayerPrivateKey)\n                        )\n                    );\n                }\n                throw new NotDelegatedTransaction(\n                    'Transaction.signAsSenderAndGasPayer',\n                    'not delegated transaction: use sign method',\n                    undefined\n                );\n            }\n            throw new InvalidSecp256k1PrivateKey(\n                `Transaction.signAsSenderAndGasPayer`,\n                'invalid gas payer private key: ensure it is a secp256k1 key',\n                undefined\n            );\n        }\n        throw new InvalidSecp256k1PrivateKey(\n            `Transaction.signAsSenderAndGasPayer`,\n            'invalid sender private key: ensure it is a secp256k1 key',\n            undefined\n        );\n    }\n\n    // ********** PRIVATE FUNCTIONS **********\n\n    /**\n     * Computes the amount of gas used for the given data.\n     *\n     * @param {string} data - The hexadecimal string data for which the gas usage is computed.\n     * @return {bigint} The total gas used for the provided data.\n     * @throws {InvalidDataType} If the data is not a valid hexadecimal string.\n     *\n     * @remarks gas value is expressed in {@link Units.wei} unit.\n     */\n    private static computeUsedGasFor(data: string): bigint {\n        // Invalid data\n        if (data !== '' && !Hex.isValid(data))\n            throw new InvalidDataType(\n                'calculateDataUsedGas()',\n                `Invalid data type for gas calculation. Data should be a hexadecimal string.`,\n                { data }\n            );\n\n        let sum = 0n;\n        for (let i = 2; i < data.length; i += 2) {\n            if (data.substring(i, i + 2) === '00') {\n                sum += Transaction.GAS_CONSTANTS.ZERO_GAS_DATA;\n            } else {\n                sum += Transaction.GAS_CONSTANTS.NON_ZERO_GAS_DATA;\n            }\n        }\n        return sum;\n    }\n\n    /**\n     * Decodes the {@link TransactionBody.reserved} field from the given buffer array.\n     *\n     * @param {Buffer[]} reserved  - An array of Uint8Array objects representing the reserved field data.\n     * @return {Object} An object containing the decoded features and any unused buffer data.\n     * @return {number} [return.features] The decoded features from the reserved field.\n     * @return {Buffer[]} [return.unused] An array of Buffer objects representing unused data, if any.\n     * @throws {InvalidTransactionField} Thrown if the reserved field is not properly trimmed.\n     */\n    private static decodeReservedField(reserved: Uint8Array[]): {\n        features?: number;\n        unused?: Uint8Array[];\n    } {\n        // Not trimmed reserved field\n        if (reserved[reserved.length - 1].length > 0) {\n            // Get features field.\n            const featuresField = Transaction.RLP_FEATURES.kind\n                .buffer(reserved[0], Transaction.RLP_FEATURES.name)\n                .decode() as number;\n            // Return encoded reserved field\n            return reserved.length > 1\n                ? {\n                      features: featuresField,\n                      unused: reserved.slice(1)\n                  }\n                : { features: featuresField };\n        }\n        throw new InvalidTransactionField(\n            'Transaction.decodeReservedField',\n            'invalid reserved field: fields in the `reserved` property must be properly trimmed',\n            { fieldName: 'reserved', reserved }\n        );\n    }\n\n    /**\n     * Encodes the transaction body using RLP encoding.\n     *\n     * @param {boolean} isSigned - Indicates whether the transaction is signed.\n     * @return {Uint8Array} The RLP encoded transaction body.\n     *\n     * @see encoded\n     */\n    private encode(isSigned: boolean): Uint8Array {\n        // Encode transaction body with RLP\n        const encodedBody = this.encodeBodyField(\n            {\n                // Existing body and the optional `reserved` field if present.\n                ...this.body,\n                /*\n                 * The `body.clauses` property is already an array,\n                 * albeit TypeScript realize, hence cast is needed\n                 * otherwise encodeObject will throw an error.\n                 */\n                clauses: this.body.clauses as Array<{\n                    to: string | null;\n                    value: string | number;\n                    data: string;\n                }>,\n                // New reserved field.\n                reserved: this.encodeReservedField()\n            },\n            isSigned\n        );\n        // add prefix if eip1559\n        if (this.transactionType === TransactionType.EIP1559) {\n            return nc_utils.concatBytes(\n                Uint8Array.from([Transaction.EIP1559_TX_TYPE_PREFIX]),\n                encodedBody\n            );\n        }\n        return encodedBody;\n    }\n\n    /**\n     * Encodes the given transaction body into a Uint8Array, depending on whether\n     * the transaction is signed or not.\n     *\n     * @param body - The transaction object adhering to the RLPValidObject structure.\n     * @param isSigned - A boolean indicating if the transaction is signed.\n     * @return A Uint8Array representing the encoded transaction.\n     *\n     * @see encoded\n     */\n    private encodeBodyField(\n        body: RLPValidObject,\n        isSigned: boolean\n    ): Uint8Array {\n        // Encode transaction object - SIGNED\n        if (isSigned) {\n            return RLPProfiler.ofObject(\n                {\n                    ...body,\n                    signature: Uint8Array.from(this.signature as Uint8Array)\n                },\n                this.transactionType === TransactionType.EIP1559\n                    ? Transaction.RLP_SIGNED_EIP1559_TRANSACTION_PROFILE\n                    : Transaction.RLP_SIGNED_LEGACY_TRANSACTION_PROFILE\n            ).encoded;\n        }\n        // Encode transaction object - UNSIGNED\n        return RLPProfiler.ofObject(\n            body,\n            this.transactionType === TransactionType.EIP1559\n                ? Transaction.RLP_UNSIGNED_EIP1559_TRANSACTION_PROFILE\n                : Transaction.RLP_UNSIGNED_LEGACY_TRANSACTION_PROFILE\n        ).encoded;\n    }\n\n    /**\n     * Encodes the {@link TransactionBody.reserved} field data for a transaction.\n     *\n     * @return {Uint8Array[]} The encoded list of reserved features.\n     * It removes any trailing unused features that have zero length from the list.\n     *\n     * @remarks The {@link TransactionBody.reserved} is optional, albeit\n     * is required to perform RLP encoding.\n     *\n     * @see encode\n     */\n    private encodeReservedField(): Uint8Array[] {\n        // Check if is reserved or not\n        const reserved = this.body.reserved ?? {};\n        // Init kind for features\n        const featuresKind = Transaction.RLP_FEATURES.kind;\n        // Features list\n        const featuresList = [\n            featuresKind\n                .data(reserved.features ?? 0, Transaction.RLP_FEATURES.name)\n                .encode(),\n            ...(reserved.unused ?? [])\n        ];\n        // Trim features list\n        while (featuresList.length > 0) {\n            if (featuresList[featuresList.length - 1].length === 0) {\n                featuresList.pop();\n            } else {\n                break;\n            }\n        }\n        return featuresList;\n    }\n\n    /**\n     * Return `true` if the transaction is delegated, else `false`.\n     *\n     * @param {TransactionBody} body - The transaction body.\n     * @return {boolean} `true` if the transaction is delegated, else `false`.\n     */\n    private static isDelegated(body: TransactionBody): boolean {\n        // Check if is reserved or not\n        const reserved = body.reserved ?? {};\n        // Features\n        const features = reserved.features ?? 0;\n        // Fashion bitwise way to check if a number is even or not\n        return (features & 1) === 1;\n    }\n\n    /**\n     * Validates the length of a given signature against the expected length.\n     *\n     * @param {TransactionBody} body - The body of the transaction being validated.\n     * @param {Uint8Array} signature - The signature to verify the length of.\n     * @return {boolean} Returns true if the signature length matches the expected length, otherwise false.\n     */\n    private static isSignatureLengthValid(\n        body: TransactionBody,\n        signature: Uint8Array\n    ): boolean {\n        // Verify signature length\n        const expectedSignatureLength = this.isDelegated(body)\n            ? Secp256k1.SIGNATURE_LENGTH * 2\n            : Secp256k1.SIGNATURE_LENGTH;\n\n        return signature.length === expectedSignatureLength;\n    }\n}\n\nexport { Transaction };\n"]}