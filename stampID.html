<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Page Title</title>
</head>
<body>
    <script>
    // === CONFIGURATION ===
  const CONFIG = {
    BACKEND_URL: "http://localhost:3000",
    SUPABASE_URL: "https://mfrefbmnxygeahaluhzr.supabase.co",
    SUPABASE_ANON_KEY: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1mcmVmYm1ueHlnZWFoYWx1aHpyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI1NDIxOTUsImV4cCI6MjA2ODExODE5NX0.Ur3hl7rVEWk6U-ydNbKymFmXtxUlx6RTn0pU0EnP7u0",
    STRIPE_KEY: "", // Optional: "pk_test_..." to bypass /config
    DEBUG_MODE: true // Enable console logging
  };

  // === STATE MANAGEMENT ===
  const state = {
    stripe: null,
    elements: null,
    cardElement: null,
    uploadedFile: null,
    fileHash: null,
    currentUser: null
  };

  // === DOM ELEMENTS ===
  const dom = {
    status: document.getElementById('status'),
    authSection: document.getElementById('auth-section'),
    uploadSection: document.getElementById('upload-section'),
    paymentSection: document.getElementById('payment-section'),
    paymentElement: document.getElementById('payment-element'),
    notarizeBtn: document.getElementById('notarize-btn'),
    fileInput: document.getElementById('fileInput'),
    dropZone: document.getElementById('drop-zone'),
    fileInfo: document.getElementById('file-info'),
    hashInfo: document.getElementById('hash-info'),
    resultsSection: document.getElementById('results-section'),
    resultsInfo: document.getElementById('results-info')
  };

  // === SUPABASE CLIENT ===
  const sb = window.supabase.createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_ANON_KEY);

  // === UTILITY FUNCTIONS ===
  function log(...args) {
    if (CONFIG.DEBUG_MODE) console.log('[DEBUG]', ...args);
  }

  function setStatus(message, type = 'info') {
    dom.status.textContent = `Status: ${message}`;
    dom.status.className = `status ${type}`;
    log(`Status [${type}]:`, message);
  }

  async function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // === AUTH FUNCTIONS ===
  async function checkAuth() {
    try {
      const { data: { user }, error } = await sb.auth.getUser();
      if (error) throw error;
      
      state.currentUser = user;
      
      if (user) {
        setStatus(`Authenticated as ${user.email}`, 'success');
        dom.authSection.style.display = 'none';
        dom.uploadSection.style.display = 'block';
        return true;
      } else {
        setStatus('Please log in to continue', 'info');
        return false;
      }
    } catch (err) {
      log('Auth check error:', err);
      setStatus('Authentication check failed', 'error');
      return false;
    }
  }

  async function loginUser() {
    const email = document.getElementById('email').value?.trim();
    const password = document.getElementById('password').value;
    
    if (!email || !password) {
      setStatus('Please enter email and password', 'warning');
      return;
    }
    
    setStatus('Authenticating...', 'info');
    
    try {
      // Try login first
      let { data, error } = await sb.auth.signInWithPassword({ email, password });
      
      // If login fails, try signup
      if (error) {
        log('Login failed, attempting signup:', error);
        const { data: signUpData, error: signUpError } = await sb.auth.signUp({ email, password });
        if (signUpError) throw signUpError;
        data = signUpData;
        setStatus('Account created successfully', 'success');
      }
      
      await delay(500); // Small delay for auth to propagate
      await checkAuth();
    } catch (err) {
      log('Auth error:', err);
      setStatus(`Authentication failed: ${err.message}`, 'error');
    }
  }

  // === FILE HANDLING ===
  async function handleFile(file) {
    if (!file) {
      setStatus('No file selected', 'warning');
      return;
    }
    
    // File size check (e.g., 10MB limit)
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      setStatus('File too large (max 10MB)', 'error');
      return;
    }
    
    state.uploadedFile = file;
    dom.fileInfo.innerHTML = `
      <strong>File:</strong> ${file.name}<br>
      <strong>Size:</strong> ${(file.size/1024/1024).toFixed(2)} MB<br>
      <strong>Type:</strong> ${file.type || 'unknown'}
    `;
    
    setStatus('Generating cryptographic hash...', 'info');
    dom.notarizeBtn.disabled = true;
    
    try {
      state.fileHash = await getFileHash(file);
      dom.hashInfo.style.display = 'block';
      dom.hashInfo.innerHTML = `
        <strong>SHA-256 Hash:</strong><br>
        <code style="word-break: break-all;">${state.fileHash}</code>
      `;
      setStatus('Hash generated successfully', 'success');
      dom.paymentSection.style.display = 'block';
      dom.notarizeBtn.disabled = false;
    } catch (err) {
      log('Hash error:', err);
      setStatus(`Failed to generate hash: ${err.message}`, 'error');
    }
  }

  async function getFileHash(file) {
    const buffer = await file.arrayBuffer();
    const digest = await crypto.subtle.digest('SHA-256', buffer);
    return Array.from(new Uint8Array(digest))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

  // === STRIPE FUNCTIONS ===
  async function initStripe() {
    if (state.stripe) return true;
    
    try {
      let stripeKey = CONFIG.STRIPE_KEY;
      
      if (!stripeKey) {
        setStatus('Fetching payment configuration...', 'info');
        const res = await fetch(`${CONFIG.BACKEND_URL}/config`);
        
        if (!res.ok) {
          const errorText = await res.text().catch(() => 'No error details');
          throw new Error(`Config fetch failed (${res.status}): ${errorText}`);
        }
        
        const config = await res.json();
        stripeKey = config.stripePublicKey;
        
        if (!stripeKey) {
          throw new Error('No Stripe key in config response');
        }
      }
      
      state.stripe = Stripe(stripeKey);
      state.elements = state.stripe.elements();
      state.cardElement = state.elements.create('card', {
        style: {
          base: {
            fontSize: '16px',
            color: '#32325d',
            '::placeholder': { color: '#aab7c4' }
          }
        }
      });
      state.cardElement.mount(dom.paymentElement);
      
      log('Stripe initialized successfully');
      return true;
    } catch (err) {
      log('Stripe init error:', err);
      setStatus(`Payment system error: ${err.message}`, 'error');
      return false;
    }
  }

  // === PAYMENT & NOTARIZATION ===
  async function processPaymentAndNotarize() {
    if (!state.uploadedFile || !state.fileHash) {
      setStatus('Please upload a file first', 'warning');
      return;
    }
    
    dom.notarizeBtn.disabled = true;
    
    try {
      // Initialize Stripe if needed
      if (!await initStripe()) {
        dom.notarizeBtn.disabled = false;
        return;
      }
      
      // Create payment intent
      setStatus('Creating payment...', 'info');
      const paymentRes = await fetch(`${CONFIG.BACKEND_URL}/create-payment`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ document_hash: state.fileHash })
      });
      
      if (!paymentRes.ok) {
        const errorText = await paymentRes.text().catch(() => 'No error details');
        throw new Error(`Payment creation failed (${paymentRes.status}): ${errorText}`);
      }
      
      const { clientSecret } = await paymentRes.json();
      if (!clientSecret) throw new Error('No client secret received');
      
      // Confirm payment
      setStatus('Processing payment...', 'info');
      const { paymentIntent, error } = await state.stripe.confirmCardPayment(clientSecret, {
        payment_method: { card: state.cardElement }
      });
      
      if (error) {
        throw new Error(`Payment failed: ${error.message}`);
      }
      
      if (paymentIntent?.status !== 'succeeded') {
        throw new Error('Payment did not complete successfully');
      }
      
      setStatus('Payment successful! Notarizing document...', 'success');
      await notarizeDocument();
      
    } catch (err) {
      log('Payment/Notarization error:', err);
      setStatus(err.message, 'error');
      dom.notarizeBtn.disabled = false;
    }
  }

  async function notarizeDocument() {
    const formData = new FormData();
    formData.append('document', state.uploadedFile);
    formData.append('name', state.uploadedFile.name);
    
    if (state.currentUser?.email) {
      formData.append('email', state.currentUser.email);
    }
    
    try {
      const response = await fetch(`${CONFIG.BACKEND_URL}/notarize`, {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        const errorText = await response.text().catch(() => 'No error details');
        throw new Error(`Notarization failed (${response.status}): ${errorText}`);
      }
      
      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.details || result.error || 'Notarization failed');
      }
      
      // Display results
      dom.resultsSection.style.display = 'block';
      dom.resultsInfo.innerHTML = `
        <div class="status success">
          <h3>âœ… Notarization Complete!</h3>
          <div class="result-details">
            <p><strong>Transaction ID:</strong><br>
              <a href="${result.explorerUrl}" target="_blank" rel="noopener">
                ${result.vechainTx}
              </a>
            </p>
            <p><strong>Document Hash:</strong><br>
              <code>${result.documentHash}</code>
            </p>
            <p><strong>Timestamp:</strong> ${new Date().toISOString()}</p>
            <p><strong>Document:</strong><br>
              <a href="${result.documentUrl}" target="_blank" rel="noopener">
                View Stored File
              </a>
            </p>
          </div>
        </div>
      `;
      
      setStatus('Document successfully notarized on blockchain!', 'success');
      dom.notarizeBtn.disabled = false;
      
    } catch (err) {
      log('Notarization error:', err);
      throw err;
    }
  }

  // === EVENT LISTENERS ===
  dom.dropZone?.addEventListener('click', () => dom.fileInput.click());
  
  dom.fileInput?.addEventListener('change', (e) => {
    handleFile(e.target.files[0]);
  });
  
  dom.dropZone?.addEventListener('dragover', (e) => {
    e.preventDefault();
    dom.dropZone.classList.add('dragover');
  });
  
  dom.dropZone?.addEventListener('dragleave', () => {
    dom.dropZone.classList.remove('dragover');
  });
  
  dom.dropZone?.addEventListener('drop', (e) => {
    e.preventDefault();
    dom.dropZone.classList.remove('dragover');
    handleFile(e.dataTransfer.files[0]);
  });
  
  dom.notarizeBtn?.addEventListener('click', processPaymentAndNotarize);
  
  // Expose login function globally
  window.loginUser = loginUser;
  
  // === INITIALIZATION ===
  async function initialize() {
    log('Initializing application...');
    setStatus('Initializing...', 'info');
    
    try {
      await checkAuth();
      log('Application ready');
      setStatus('Ready', 'info');
    } catch (err) {
      log('Init error:', err);
      setStatus('Initialization error', 'error');
    }
  }
  
  // Start app
  initialize();
</script>
